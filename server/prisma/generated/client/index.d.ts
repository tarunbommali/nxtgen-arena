
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model EventCategory
 * 
 */
export type EventCategory = $Result.DefaultSelection<Prisma.$EventCategoryPayload>
/**
 * Model EventType
 * 
 */
export type EventType = $Result.DefaultSelection<Prisma.$EventTypePayload>
/**
 * Model Event
 * 
 */
export type Event = $Result.DefaultSelection<Prisma.$EventPayload>
/**
 * Model Team
 * 
 */
export type Team = $Result.DefaultSelection<Prisma.$TeamPayload>
/**
 * Model TeamMember
 * 
 */
export type TeamMember = $Result.DefaultSelection<Prisma.$TeamMemberPayload>
/**
 * Model TeamJoinRequest
 * 
 */
export type TeamJoinRequest = $Result.DefaultSelection<Prisma.$TeamJoinRequestPayload>
/**
 * Model EventRegistration
 * 
 */
export type EventRegistration = $Result.DefaultSelection<Prisma.$EventRegistrationPayload>
/**
 * Model EventSubmission
 * 
 */
export type EventSubmission = $Result.DefaultSelection<Prisma.$EventSubmissionPayload>
/**
 * Model Challenge
 * 
 */
export type Challenge = $Result.DefaultSelection<Prisma.$ChallengePayload>
/**
 * Model ChallengeTask
 * 
 */
export type ChallengeTask = $Result.DefaultSelection<Prisma.$ChallengeTaskPayload>
/**
 * Model UserChallengeProgress
 * 
 */
export type UserChallengeProgress = $Result.DefaultSelection<Prisma.$UserChallengeProgressPayload>
/**
 * Model UserTaskCompletion
 * 
 */
export type UserTaskCompletion = $Result.DefaultSelection<Prisma.$UserTaskCompletionPayload>
/**
 * Model UserBadge
 * 
 */
export type UserBadge = $Result.DefaultSelection<Prisma.$UserBadgePayload>
/**
 * Model UserAchievement
 * 
 */
export type UserAchievement = $Result.DefaultSelection<Prisma.$UserAchievementPayload>
/**
 * Model Leaderboard
 * 
 */
export type Leaderboard = $Result.DefaultSelection<Prisma.$LeaderboardPayload>
/**
 * Model EventChallenge
 * 
 */
export type EventChallenge = $Result.DefaultSelection<Prisma.$EventChallengePayload>
/**
 * Model Roadmap
 * 
 */
export type Roadmap = $Result.DefaultSelection<Prisma.$RoadmapPayload>
/**
 * Model RoadmapPhase
 * 
 */
export type RoadmapPhase = $Result.DefaultSelection<Prisma.$RoadmapPhasePayload>
/**
 * Model PhaseSection
 * 
 */
export type PhaseSection = $Result.DefaultSelection<Prisma.$PhaseSectionPayload>
/**
 * Model SectionItem
 * 
 */
export type SectionItem = $Result.DefaultSelection<Prisma.$SectionItemPayload>
/**
 * Model SubItem
 * 
 */
export type SubItem = $Result.DefaultSelection<Prisma.$SubItemPayload>
/**
 * Model PhasePlaylist
 * 
 */
export type PhasePlaylist = $Result.DefaultSelection<Prisma.$PhasePlaylistPayload>
/**
 * Model PhaseProject
 * 
 */
export type PhaseProject = $Result.DefaultSelection<Prisma.$PhaseProjectPayload>
/**
 * Model DSASheet
 * 
 */
export type DSASheet = $Result.DefaultSelection<Prisma.$DSASheetPayload>
/**
 * Model DSATopic
 * 
 */
export type DSATopic = $Result.DefaultSelection<Prisma.$DSATopicPayload>
/**
 * Model DSAProblem
 * 
 */
export type DSAProblem = $Result.DefaultSelection<Prisma.$DSAProblemPayload>
/**
 * Model DSASolution
 * 
 */
export type DSASolution = $Result.DefaultSelection<Prisma.$DSASolutionPayload>
/**
 * Model Certificate
 * 
 */
export type Certificate = $Result.DefaultSelection<Prisma.$CertificatePayload>
/**
 * Model EmailLog
 * 
 */
export type EmailLog = $Result.DefaultSelection<Prisma.$EmailLogPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.eventCategory`: Exposes CRUD operations for the **EventCategory** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventCategories
    * const eventCategories = await prisma.eventCategory.findMany()
    * ```
    */
  get eventCategory(): Prisma.EventCategoryDelegate<ExtArgs>;

  /**
   * `prisma.eventType`: Exposes CRUD operations for the **EventType** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventTypes
    * const eventTypes = await prisma.eventType.findMany()
    * ```
    */
  get eventType(): Prisma.EventTypeDelegate<ExtArgs>;

  /**
   * `prisma.event`: Exposes CRUD operations for the **Event** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Events
    * const events = await prisma.event.findMany()
    * ```
    */
  get event(): Prisma.EventDelegate<ExtArgs>;

  /**
   * `prisma.team`: Exposes CRUD operations for the **Team** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Teams
    * const teams = await prisma.team.findMany()
    * ```
    */
  get team(): Prisma.TeamDelegate<ExtArgs>;

  /**
   * `prisma.teamMember`: Exposes CRUD operations for the **TeamMember** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamMembers
    * const teamMembers = await prisma.teamMember.findMany()
    * ```
    */
  get teamMember(): Prisma.TeamMemberDelegate<ExtArgs>;

  /**
   * `prisma.teamJoinRequest`: Exposes CRUD operations for the **TeamJoinRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TeamJoinRequests
    * const teamJoinRequests = await prisma.teamJoinRequest.findMany()
    * ```
    */
  get teamJoinRequest(): Prisma.TeamJoinRequestDelegate<ExtArgs>;

  /**
   * `prisma.eventRegistration`: Exposes CRUD operations for the **EventRegistration** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventRegistrations
    * const eventRegistrations = await prisma.eventRegistration.findMany()
    * ```
    */
  get eventRegistration(): Prisma.EventRegistrationDelegate<ExtArgs>;

  /**
   * `prisma.eventSubmission`: Exposes CRUD operations for the **EventSubmission** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventSubmissions
    * const eventSubmissions = await prisma.eventSubmission.findMany()
    * ```
    */
  get eventSubmission(): Prisma.EventSubmissionDelegate<ExtArgs>;

  /**
   * `prisma.challenge`: Exposes CRUD operations for the **Challenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Challenges
    * const challenges = await prisma.challenge.findMany()
    * ```
    */
  get challenge(): Prisma.ChallengeDelegate<ExtArgs>;

  /**
   * `prisma.challengeTask`: Exposes CRUD operations for the **ChallengeTask** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ChallengeTasks
    * const challengeTasks = await prisma.challengeTask.findMany()
    * ```
    */
  get challengeTask(): Prisma.ChallengeTaskDelegate<ExtArgs>;

  /**
   * `prisma.userChallengeProgress`: Exposes CRUD operations for the **UserChallengeProgress** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserChallengeProgresses
    * const userChallengeProgresses = await prisma.userChallengeProgress.findMany()
    * ```
    */
  get userChallengeProgress(): Prisma.UserChallengeProgressDelegate<ExtArgs>;

  /**
   * `prisma.userTaskCompletion`: Exposes CRUD operations for the **UserTaskCompletion** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserTaskCompletions
    * const userTaskCompletions = await prisma.userTaskCompletion.findMany()
    * ```
    */
  get userTaskCompletion(): Prisma.UserTaskCompletionDelegate<ExtArgs>;

  /**
   * `prisma.userBadge`: Exposes CRUD operations for the **UserBadge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserBadges
    * const userBadges = await prisma.userBadge.findMany()
    * ```
    */
  get userBadge(): Prisma.UserBadgeDelegate<ExtArgs>;

  /**
   * `prisma.userAchievement`: Exposes CRUD operations for the **UserAchievement** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more UserAchievements
    * const userAchievements = await prisma.userAchievement.findMany()
    * ```
    */
  get userAchievement(): Prisma.UserAchievementDelegate<ExtArgs>;

  /**
   * `prisma.leaderboard`: Exposes CRUD operations for the **Leaderboard** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Leaderboards
    * const leaderboards = await prisma.leaderboard.findMany()
    * ```
    */
  get leaderboard(): Prisma.LeaderboardDelegate<ExtArgs>;

  /**
   * `prisma.eventChallenge`: Exposes CRUD operations for the **EventChallenge** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EventChallenges
    * const eventChallenges = await prisma.eventChallenge.findMany()
    * ```
    */
  get eventChallenge(): Prisma.EventChallengeDelegate<ExtArgs>;

  /**
   * `prisma.roadmap`: Exposes CRUD operations for the **Roadmap** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Roadmaps
    * const roadmaps = await prisma.roadmap.findMany()
    * ```
    */
  get roadmap(): Prisma.RoadmapDelegate<ExtArgs>;

  /**
   * `prisma.roadmapPhase`: Exposes CRUD operations for the **RoadmapPhase** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more RoadmapPhases
    * const roadmapPhases = await prisma.roadmapPhase.findMany()
    * ```
    */
  get roadmapPhase(): Prisma.RoadmapPhaseDelegate<ExtArgs>;

  /**
   * `prisma.phaseSection`: Exposes CRUD operations for the **PhaseSection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhaseSections
    * const phaseSections = await prisma.phaseSection.findMany()
    * ```
    */
  get phaseSection(): Prisma.PhaseSectionDelegate<ExtArgs>;

  /**
   * `prisma.sectionItem`: Exposes CRUD operations for the **SectionItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SectionItems
    * const sectionItems = await prisma.sectionItem.findMany()
    * ```
    */
  get sectionItem(): Prisma.SectionItemDelegate<ExtArgs>;

  /**
   * `prisma.subItem`: Exposes CRUD operations for the **SubItem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more SubItems
    * const subItems = await prisma.subItem.findMany()
    * ```
    */
  get subItem(): Prisma.SubItemDelegate<ExtArgs>;

  /**
   * `prisma.phasePlaylist`: Exposes CRUD operations for the **PhasePlaylist** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhasePlaylists
    * const phasePlaylists = await prisma.phasePlaylist.findMany()
    * ```
    */
  get phasePlaylist(): Prisma.PhasePlaylistDelegate<ExtArgs>;

  /**
   * `prisma.phaseProject`: Exposes CRUD operations for the **PhaseProject** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PhaseProjects
    * const phaseProjects = await prisma.phaseProject.findMany()
    * ```
    */
  get phaseProject(): Prisma.PhaseProjectDelegate<ExtArgs>;

  /**
   * `prisma.dSASheet`: Exposes CRUD operations for the **DSASheet** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DSASheets
    * const dSASheets = await prisma.dSASheet.findMany()
    * ```
    */
  get dSASheet(): Prisma.DSASheetDelegate<ExtArgs>;

  /**
   * `prisma.dSATopic`: Exposes CRUD operations for the **DSATopic** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DSATopics
    * const dSATopics = await prisma.dSATopic.findMany()
    * ```
    */
  get dSATopic(): Prisma.DSATopicDelegate<ExtArgs>;

  /**
   * `prisma.dSAProblem`: Exposes CRUD operations for the **DSAProblem** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DSAProblems
    * const dSAProblems = await prisma.dSAProblem.findMany()
    * ```
    */
  get dSAProblem(): Prisma.DSAProblemDelegate<ExtArgs>;

  /**
   * `prisma.dSASolution`: Exposes CRUD operations for the **DSASolution** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more DSASolutions
    * const dSASolutions = await prisma.dSASolution.findMany()
    * ```
    */
  get dSASolution(): Prisma.DSASolutionDelegate<ExtArgs>;

  /**
   * `prisma.certificate`: Exposes CRUD operations for the **Certificate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Certificates
    * const certificates = await prisma.certificate.findMany()
    * ```
    */
  get certificate(): Prisma.CertificateDelegate<ExtArgs>;

  /**
   * `prisma.emailLog`: Exposes CRUD operations for the **EmailLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmailLogs
    * const emailLogs = await prisma.emailLog.findMany()
    * ```
    */
  get emailLog(): Prisma.EmailLogDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    EventCategory: 'EventCategory',
    EventType: 'EventType',
    Event: 'Event',
    Team: 'Team',
    TeamMember: 'TeamMember',
    TeamJoinRequest: 'TeamJoinRequest',
    EventRegistration: 'EventRegistration',
    EventSubmission: 'EventSubmission',
    Challenge: 'Challenge',
    ChallengeTask: 'ChallengeTask',
    UserChallengeProgress: 'UserChallengeProgress',
    UserTaskCompletion: 'UserTaskCompletion',
    UserBadge: 'UserBadge',
    UserAchievement: 'UserAchievement',
    Leaderboard: 'Leaderboard',
    EventChallenge: 'EventChallenge',
    Roadmap: 'Roadmap',
    RoadmapPhase: 'RoadmapPhase',
    PhaseSection: 'PhaseSection',
    SectionItem: 'SectionItem',
    SubItem: 'SubItem',
    PhasePlaylist: 'PhasePlaylist',
    PhaseProject: 'PhaseProject',
    DSASheet: 'DSASheet',
    DSATopic: 'DSATopic',
    DSAProblem: 'DSAProblem',
    DSASolution: 'DSASolution',
    Certificate: 'Certificate',
    EmailLog: 'EmailLog'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "eventCategory" | "eventType" | "event" | "team" | "teamMember" | "teamJoinRequest" | "eventRegistration" | "eventSubmission" | "challenge" | "challengeTask" | "userChallengeProgress" | "userTaskCompletion" | "userBadge" | "userAchievement" | "leaderboard" | "eventChallenge" | "roadmap" | "roadmapPhase" | "phaseSection" | "sectionItem" | "subItem" | "phasePlaylist" | "phaseProject" | "dSASheet" | "dSATopic" | "dSAProblem" | "dSASolution" | "certificate" | "emailLog"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      EventCategory: {
        payload: Prisma.$EventCategoryPayload<ExtArgs>
        fields: Prisma.EventCategoryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventCategoryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventCategoryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          findFirst: {
            args: Prisma.EventCategoryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventCategoryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          findMany: {
            args: Prisma.EventCategoryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>[]
          }
          create: {
            args: Prisma.EventCategoryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          createMany: {
            args: Prisma.EventCategoryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventCategoryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          update: {
            args: Prisma.EventCategoryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          deleteMany: {
            args: Prisma.EventCategoryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventCategoryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventCategoryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventCategoryPayload>
          }
          aggregate: {
            args: Prisma.EventCategoryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventCategory>
          }
          groupBy: {
            args: Prisma.EventCategoryGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventCategoryGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCategoryCountArgs<ExtArgs>
            result: $Utils.Optional<EventCategoryCountAggregateOutputType> | number
          }
        }
      }
      EventType: {
        payload: Prisma.$EventTypePayload<ExtArgs>
        fields: Prisma.EventTypeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventTypeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventTypeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          findFirst: {
            args: Prisma.EventTypeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventTypeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          findMany: {
            args: Prisma.EventTypeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>[]
          }
          create: {
            args: Prisma.EventTypeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          createMany: {
            args: Prisma.EventTypeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventTypeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          update: {
            args: Prisma.EventTypeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          deleteMany: {
            args: Prisma.EventTypeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventTypeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventTypeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventTypePayload>
          }
          aggregate: {
            args: Prisma.EventTypeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventType>
          }
          groupBy: {
            args: Prisma.EventTypeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventTypeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventTypeCountArgs<ExtArgs>
            result: $Utils.Optional<EventTypeCountAggregateOutputType> | number
          }
        }
      }
      Event: {
        payload: Prisma.$EventPayload<ExtArgs>
        fields: Prisma.EventFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findFirst: {
            args: Prisma.EventFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          findMany: {
            args: Prisma.EventFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>[]
          }
          create: {
            args: Prisma.EventCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          createMany: {
            args: Prisma.EventCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          update: {
            args: Prisma.EventUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          deleteMany: {
            args: Prisma.EventDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventPayload>
          }
          aggregate: {
            args: Prisma.EventAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEvent>
          }
          groupBy: {
            args: Prisma.EventGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventCountArgs<ExtArgs>
            result: $Utils.Optional<EventCountAggregateOutputType> | number
          }
        }
      }
      Team: {
        payload: Prisma.$TeamPayload<ExtArgs>
        fields: Prisma.TeamFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findFirst: {
            args: Prisma.TeamFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          findMany: {
            args: Prisma.TeamFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>[]
          }
          create: {
            args: Prisma.TeamCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          createMany: {
            args: Prisma.TeamCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          update: {
            args: Prisma.TeamUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          deleteMany: {
            args: Prisma.TeamDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamPayload>
          }
          aggregate: {
            args: Prisma.TeamAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeam>
          }
          groupBy: {
            args: Prisma.TeamGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamCountArgs<ExtArgs>
            result: $Utils.Optional<TeamCountAggregateOutputType> | number
          }
        }
      }
      TeamMember: {
        payload: Prisma.$TeamMemberPayload<ExtArgs>
        fields: Prisma.TeamMemberFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamMemberFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamMemberFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findFirst: {
            args: Prisma.TeamMemberFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamMemberFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          findMany: {
            args: Prisma.TeamMemberFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>[]
          }
          create: {
            args: Prisma.TeamMemberCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          createMany: {
            args: Prisma.TeamMemberCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamMemberDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          update: {
            args: Prisma.TeamMemberUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          deleteMany: {
            args: Prisma.TeamMemberDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamMemberUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamMemberUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamMemberPayload>
          }
          aggregate: {
            args: Prisma.TeamMemberAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamMember>
          }
          groupBy: {
            args: Prisma.TeamMemberGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamMemberCountArgs<ExtArgs>
            result: $Utils.Optional<TeamMemberCountAggregateOutputType> | number
          }
        }
      }
      TeamJoinRequest: {
        payload: Prisma.$TeamJoinRequestPayload<ExtArgs>
        fields: Prisma.TeamJoinRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TeamJoinRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TeamJoinRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>
          }
          findFirst: {
            args: Prisma.TeamJoinRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TeamJoinRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>
          }
          findMany: {
            args: Prisma.TeamJoinRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>[]
          }
          create: {
            args: Prisma.TeamJoinRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>
          }
          createMany: {
            args: Prisma.TeamJoinRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.TeamJoinRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>
          }
          update: {
            args: Prisma.TeamJoinRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>
          }
          deleteMany: {
            args: Prisma.TeamJoinRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TeamJoinRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TeamJoinRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TeamJoinRequestPayload>
          }
          aggregate: {
            args: Prisma.TeamJoinRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTeamJoinRequest>
          }
          groupBy: {
            args: Prisma.TeamJoinRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<TeamJoinRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.TeamJoinRequestCountArgs<ExtArgs>
            result: $Utils.Optional<TeamJoinRequestCountAggregateOutputType> | number
          }
        }
      }
      EventRegistration: {
        payload: Prisma.$EventRegistrationPayload<ExtArgs>
        fields: Prisma.EventRegistrationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventRegistrationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventRegistrationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          findFirst: {
            args: Prisma.EventRegistrationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventRegistrationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          findMany: {
            args: Prisma.EventRegistrationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>[]
          }
          create: {
            args: Prisma.EventRegistrationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          createMany: {
            args: Prisma.EventRegistrationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventRegistrationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          update: {
            args: Prisma.EventRegistrationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          deleteMany: {
            args: Prisma.EventRegistrationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventRegistrationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventRegistrationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventRegistrationPayload>
          }
          aggregate: {
            args: Prisma.EventRegistrationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventRegistration>
          }
          groupBy: {
            args: Prisma.EventRegistrationGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventRegistrationGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventRegistrationCountArgs<ExtArgs>
            result: $Utils.Optional<EventRegistrationCountAggregateOutputType> | number
          }
        }
      }
      EventSubmission: {
        payload: Prisma.$EventSubmissionPayload<ExtArgs>
        fields: Prisma.EventSubmissionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventSubmissionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSubmissionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventSubmissionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSubmissionPayload>
          }
          findFirst: {
            args: Prisma.EventSubmissionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSubmissionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventSubmissionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSubmissionPayload>
          }
          findMany: {
            args: Prisma.EventSubmissionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSubmissionPayload>[]
          }
          create: {
            args: Prisma.EventSubmissionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSubmissionPayload>
          }
          createMany: {
            args: Prisma.EventSubmissionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventSubmissionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSubmissionPayload>
          }
          update: {
            args: Prisma.EventSubmissionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSubmissionPayload>
          }
          deleteMany: {
            args: Prisma.EventSubmissionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventSubmissionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventSubmissionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventSubmissionPayload>
          }
          aggregate: {
            args: Prisma.EventSubmissionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventSubmission>
          }
          groupBy: {
            args: Prisma.EventSubmissionGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventSubmissionGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventSubmissionCountArgs<ExtArgs>
            result: $Utils.Optional<EventSubmissionCountAggregateOutputType> | number
          }
        }
      }
      Challenge: {
        payload: Prisma.$ChallengePayload<ExtArgs>
        fields: Prisma.ChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findFirst: {
            args: Prisma.ChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          findMany: {
            args: Prisma.ChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>[]
          }
          create: {
            args: Prisma.ChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          createMany: {
            args: Prisma.ChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          update: {
            args: Prisma.ChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          deleteMany: {
            args: Prisma.ChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengePayload>
          }
          aggregate: {
            args: Prisma.ChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallenge>
          }
          groupBy: {
            args: Prisma.ChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeCountAggregateOutputType> | number
          }
        }
      }
      ChallengeTask: {
        payload: Prisma.$ChallengeTaskPayload<ExtArgs>
        fields: Prisma.ChallengeTaskFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ChallengeTaskFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTaskPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ChallengeTaskFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTaskPayload>
          }
          findFirst: {
            args: Prisma.ChallengeTaskFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTaskPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ChallengeTaskFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTaskPayload>
          }
          findMany: {
            args: Prisma.ChallengeTaskFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTaskPayload>[]
          }
          create: {
            args: Prisma.ChallengeTaskCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTaskPayload>
          }
          createMany: {
            args: Prisma.ChallengeTaskCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.ChallengeTaskDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTaskPayload>
          }
          update: {
            args: Prisma.ChallengeTaskUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTaskPayload>
          }
          deleteMany: {
            args: Prisma.ChallengeTaskDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ChallengeTaskUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ChallengeTaskUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ChallengeTaskPayload>
          }
          aggregate: {
            args: Prisma.ChallengeTaskAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChallengeTask>
          }
          groupBy: {
            args: Prisma.ChallengeTaskGroupByArgs<ExtArgs>
            result: $Utils.Optional<ChallengeTaskGroupByOutputType>[]
          }
          count: {
            args: Prisma.ChallengeTaskCountArgs<ExtArgs>
            result: $Utils.Optional<ChallengeTaskCountAggregateOutputType> | number
          }
        }
      }
      UserChallengeProgress: {
        payload: Prisma.$UserChallengeProgressPayload<ExtArgs>
        fields: Prisma.UserChallengeProgressFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserChallengeProgressFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserChallengeProgressFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>
          }
          findFirst: {
            args: Prisma.UserChallengeProgressFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserChallengeProgressFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>
          }
          findMany: {
            args: Prisma.UserChallengeProgressFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>[]
          }
          create: {
            args: Prisma.UserChallengeProgressCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>
          }
          createMany: {
            args: Prisma.UserChallengeProgressCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserChallengeProgressDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>
          }
          update: {
            args: Prisma.UserChallengeProgressUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>
          }
          deleteMany: {
            args: Prisma.UserChallengeProgressDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserChallengeProgressUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserChallengeProgressUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserChallengeProgressPayload>
          }
          aggregate: {
            args: Prisma.UserChallengeProgressAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserChallengeProgress>
          }
          groupBy: {
            args: Prisma.UserChallengeProgressGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserChallengeProgressGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserChallengeProgressCountArgs<ExtArgs>
            result: $Utils.Optional<UserChallengeProgressCountAggregateOutputType> | number
          }
        }
      }
      UserTaskCompletion: {
        payload: Prisma.$UserTaskCompletionPayload<ExtArgs>
        fields: Prisma.UserTaskCompletionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserTaskCompletionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskCompletionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserTaskCompletionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskCompletionPayload>
          }
          findFirst: {
            args: Prisma.UserTaskCompletionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskCompletionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserTaskCompletionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskCompletionPayload>
          }
          findMany: {
            args: Prisma.UserTaskCompletionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskCompletionPayload>[]
          }
          create: {
            args: Prisma.UserTaskCompletionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskCompletionPayload>
          }
          createMany: {
            args: Prisma.UserTaskCompletionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserTaskCompletionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskCompletionPayload>
          }
          update: {
            args: Prisma.UserTaskCompletionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskCompletionPayload>
          }
          deleteMany: {
            args: Prisma.UserTaskCompletionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserTaskCompletionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserTaskCompletionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserTaskCompletionPayload>
          }
          aggregate: {
            args: Prisma.UserTaskCompletionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserTaskCompletion>
          }
          groupBy: {
            args: Prisma.UserTaskCompletionGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserTaskCompletionGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserTaskCompletionCountArgs<ExtArgs>
            result: $Utils.Optional<UserTaskCompletionCountAggregateOutputType> | number
          }
        }
      }
      UserBadge: {
        payload: Prisma.$UserBadgePayload<ExtArgs>
        fields: Prisma.UserBadgeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserBadgeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserBadgeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findFirst: {
            args: Prisma.UserBadgeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserBadgeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          findMany: {
            args: Prisma.UserBadgeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>[]
          }
          create: {
            args: Prisma.UserBadgeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          createMany: {
            args: Prisma.UserBadgeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserBadgeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          update: {
            args: Prisma.UserBadgeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          deleteMany: {
            args: Prisma.UserBadgeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserBadgeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserBadgeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserBadgePayload>
          }
          aggregate: {
            args: Prisma.UserBadgeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserBadge>
          }
          groupBy: {
            args: Prisma.UserBadgeGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserBadgeCountArgs<ExtArgs>
            result: $Utils.Optional<UserBadgeCountAggregateOutputType> | number
          }
        }
      }
      UserAchievement: {
        payload: Prisma.$UserAchievementPayload<ExtArgs>
        fields: Prisma.UserAchievementFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserAchievementFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserAchievementFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findFirst: {
            args: Prisma.UserAchievementFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserAchievementFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          findMany: {
            args: Prisma.UserAchievementFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>[]
          }
          create: {
            args: Prisma.UserAchievementCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          createMany: {
            args: Prisma.UserAchievementCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.UserAchievementDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          update: {
            args: Prisma.UserAchievementUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          deleteMany: {
            args: Prisma.UserAchievementDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserAchievementUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserAchievementUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserAchievementPayload>
          }
          aggregate: {
            args: Prisma.UserAchievementAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUserAchievement>
          }
          groupBy: {
            args: Prisma.UserAchievementGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserAchievementCountArgs<ExtArgs>
            result: $Utils.Optional<UserAchievementCountAggregateOutputType> | number
          }
        }
      }
      Leaderboard: {
        payload: Prisma.$LeaderboardPayload<ExtArgs>
        fields: Prisma.LeaderboardFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaderboardFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaderboardFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          findFirst: {
            args: Prisma.LeaderboardFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaderboardFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          findMany: {
            args: Prisma.LeaderboardFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>[]
          }
          create: {
            args: Prisma.LeaderboardCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          createMany: {
            args: Prisma.LeaderboardCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.LeaderboardDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          update: {
            args: Prisma.LeaderboardUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          deleteMany: {
            args: Prisma.LeaderboardDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaderboardUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaderboardUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaderboardPayload>
          }
          aggregate: {
            args: Prisma.LeaderboardAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaderboard>
          }
          groupBy: {
            args: Prisma.LeaderboardGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaderboardCountArgs<ExtArgs>
            result: $Utils.Optional<LeaderboardCountAggregateOutputType> | number
          }
        }
      }
      EventChallenge: {
        payload: Prisma.$EventChallengePayload<ExtArgs>
        fields: Prisma.EventChallengeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EventChallengeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventChallengePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EventChallengeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventChallengePayload>
          }
          findFirst: {
            args: Prisma.EventChallengeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventChallengePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EventChallengeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventChallengePayload>
          }
          findMany: {
            args: Prisma.EventChallengeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventChallengePayload>[]
          }
          create: {
            args: Prisma.EventChallengeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventChallengePayload>
          }
          createMany: {
            args: Prisma.EventChallengeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EventChallengeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventChallengePayload>
          }
          update: {
            args: Prisma.EventChallengeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventChallengePayload>
          }
          deleteMany: {
            args: Prisma.EventChallengeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EventChallengeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EventChallengeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EventChallengePayload>
          }
          aggregate: {
            args: Prisma.EventChallengeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEventChallenge>
          }
          groupBy: {
            args: Prisma.EventChallengeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EventChallengeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EventChallengeCountArgs<ExtArgs>
            result: $Utils.Optional<EventChallengeCountAggregateOutputType> | number
          }
        }
      }
      Roadmap: {
        payload: Prisma.$RoadmapPayload<ExtArgs>
        fields: Prisma.RoadmapFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          findFirst: {
            args: Prisma.RoadmapFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          findMany: {
            args: Prisma.RoadmapFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>[]
          }
          create: {
            args: Prisma.RoadmapCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          createMany: {
            args: Prisma.RoadmapCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoadmapDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          update: {
            args: Prisma.RoadmapUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          deleteMany: {
            args: Prisma.RoadmapDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadmapUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPayload>
          }
          aggregate: {
            args: Prisma.RoadmapAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmap>
          }
          groupBy: {
            args: Prisma.RoadmapGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapCountAggregateOutputType> | number
          }
        }
      }
      RoadmapPhase: {
        payload: Prisma.$RoadmapPhasePayload<ExtArgs>
        fields: Prisma.RoadmapPhaseFieldRefs
        operations: {
          findUnique: {
            args: Prisma.RoadmapPhaseFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.RoadmapPhaseFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>
          }
          findFirst: {
            args: Prisma.RoadmapPhaseFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.RoadmapPhaseFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>
          }
          findMany: {
            args: Prisma.RoadmapPhaseFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>[]
          }
          create: {
            args: Prisma.RoadmapPhaseCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>
          }
          createMany: {
            args: Prisma.RoadmapPhaseCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.RoadmapPhaseDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>
          }
          update: {
            args: Prisma.RoadmapPhaseUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>
          }
          deleteMany: {
            args: Prisma.RoadmapPhaseDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.RoadmapPhaseUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.RoadmapPhaseUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$RoadmapPhasePayload>
          }
          aggregate: {
            args: Prisma.RoadmapPhaseAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateRoadmapPhase>
          }
          groupBy: {
            args: Prisma.RoadmapPhaseGroupByArgs<ExtArgs>
            result: $Utils.Optional<RoadmapPhaseGroupByOutputType>[]
          }
          count: {
            args: Prisma.RoadmapPhaseCountArgs<ExtArgs>
            result: $Utils.Optional<RoadmapPhaseCountAggregateOutputType> | number
          }
        }
      }
      PhaseSection: {
        payload: Prisma.$PhaseSectionPayload<ExtArgs>
        fields: Prisma.PhaseSectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhaseSectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseSectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhaseSectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseSectionPayload>
          }
          findFirst: {
            args: Prisma.PhaseSectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseSectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhaseSectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseSectionPayload>
          }
          findMany: {
            args: Prisma.PhaseSectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseSectionPayload>[]
          }
          create: {
            args: Prisma.PhaseSectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseSectionPayload>
          }
          createMany: {
            args: Prisma.PhaseSectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PhaseSectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseSectionPayload>
          }
          update: {
            args: Prisma.PhaseSectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseSectionPayload>
          }
          deleteMany: {
            args: Prisma.PhaseSectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhaseSectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhaseSectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseSectionPayload>
          }
          aggregate: {
            args: Prisma.PhaseSectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhaseSection>
          }
          groupBy: {
            args: Prisma.PhaseSectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhaseSectionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhaseSectionCountArgs<ExtArgs>
            result: $Utils.Optional<PhaseSectionCountAggregateOutputType> | number
          }
        }
      }
      SectionItem: {
        payload: Prisma.$SectionItemPayload<ExtArgs>
        fields: Prisma.SectionItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SectionItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SectionItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionItemPayload>
          }
          findFirst: {
            args: Prisma.SectionItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SectionItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionItemPayload>
          }
          findMany: {
            args: Prisma.SectionItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionItemPayload>[]
          }
          create: {
            args: Prisma.SectionItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionItemPayload>
          }
          createMany: {
            args: Prisma.SectionItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SectionItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionItemPayload>
          }
          update: {
            args: Prisma.SectionItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionItemPayload>
          }
          deleteMany: {
            args: Prisma.SectionItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SectionItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SectionItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SectionItemPayload>
          }
          aggregate: {
            args: Prisma.SectionItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSectionItem>
          }
          groupBy: {
            args: Prisma.SectionItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SectionItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SectionItemCountArgs<ExtArgs>
            result: $Utils.Optional<SectionItemCountAggregateOutputType> | number
          }
        }
      }
      SubItem: {
        payload: Prisma.$SubItemPayload<ExtArgs>
        fields: Prisma.SubItemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SubItemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubItemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SubItemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubItemPayload>
          }
          findFirst: {
            args: Prisma.SubItemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubItemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SubItemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubItemPayload>
          }
          findMany: {
            args: Prisma.SubItemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubItemPayload>[]
          }
          create: {
            args: Prisma.SubItemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubItemPayload>
          }
          createMany: {
            args: Prisma.SubItemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.SubItemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubItemPayload>
          }
          update: {
            args: Prisma.SubItemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubItemPayload>
          }
          deleteMany: {
            args: Prisma.SubItemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SubItemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SubItemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SubItemPayload>
          }
          aggregate: {
            args: Prisma.SubItemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSubItem>
          }
          groupBy: {
            args: Prisma.SubItemGroupByArgs<ExtArgs>
            result: $Utils.Optional<SubItemGroupByOutputType>[]
          }
          count: {
            args: Prisma.SubItemCountArgs<ExtArgs>
            result: $Utils.Optional<SubItemCountAggregateOutputType> | number
          }
        }
      }
      PhasePlaylist: {
        payload: Prisma.$PhasePlaylistPayload<ExtArgs>
        fields: Prisma.PhasePlaylistFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhasePlaylistFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePlaylistPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhasePlaylistFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePlaylistPayload>
          }
          findFirst: {
            args: Prisma.PhasePlaylistFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePlaylistPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhasePlaylistFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePlaylistPayload>
          }
          findMany: {
            args: Prisma.PhasePlaylistFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePlaylistPayload>[]
          }
          create: {
            args: Prisma.PhasePlaylistCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePlaylistPayload>
          }
          createMany: {
            args: Prisma.PhasePlaylistCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PhasePlaylistDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePlaylistPayload>
          }
          update: {
            args: Prisma.PhasePlaylistUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePlaylistPayload>
          }
          deleteMany: {
            args: Prisma.PhasePlaylistDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhasePlaylistUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhasePlaylistUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhasePlaylistPayload>
          }
          aggregate: {
            args: Prisma.PhasePlaylistAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhasePlaylist>
          }
          groupBy: {
            args: Prisma.PhasePlaylistGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhasePlaylistGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhasePlaylistCountArgs<ExtArgs>
            result: $Utils.Optional<PhasePlaylistCountAggregateOutputType> | number
          }
        }
      }
      PhaseProject: {
        payload: Prisma.$PhaseProjectPayload<ExtArgs>
        fields: Prisma.PhaseProjectFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PhaseProjectFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseProjectPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PhaseProjectFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseProjectPayload>
          }
          findFirst: {
            args: Prisma.PhaseProjectFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseProjectPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PhaseProjectFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseProjectPayload>
          }
          findMany: {
            args: Prisma.PhaseProjectFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseProjectPayload>[]
          }
          create: {
            args: Prisma.PhaseProjectCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseProjectPayload>
          }
          createMany: {
            args: Prisma.PhaseProjectCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.PhaseProjectDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseProjectPayload>
          }
          update: {
            args: Prisma.PhaseProjectUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseProjectPayload>
          }
          deleteMany: {
            args: Prisma.PhaseProjectDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PhaseProjectUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PhaseProjectUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PhaseProjectPayload>
          }
          aggregate: {
            args: Prisma.PhaseProjectAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePhaseProject>
          }
          groupBy: {
            args: Prisma.PhaseProjectGroupByArgs<ExtArgs>
            result: $Utils.Optional<PhaseProjectGroupByOutputType>[]
          }
          count: {
            args: Prisma.PhaseProjectCountArgs<ExtArgs>
            result: $Utils.Optional<PhaseProjectCountAggregateOutputType> | number
          }
        }
      }
      DSASheet: {
        payload: Prisma.$DSASheetPayload<ExtArgs>
        fields: Prisma.DSASheetFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DSASheetFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASheetPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DSASheetFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASheetPayload>
          }
          findFirst: {
            args: Prisma.DSASheetFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASheetPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DSASheetFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASheetPayload>
          }
          findMany: {
            args: Prisma.DSASheetFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASheetPayload>[]
          }
          create: {
            args: Prisma.DSASheetCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASheetPayload>
          }
          createMany: {
            args: Prisma.DSASheetCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DSASheetDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASheetPayload>
          }
          update: {
            args: Prisma.DSASheetUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASheetPayload>
          }
          deleteMany: {
            args: Prisma.DSASheetDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DSASheetUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DSASheetUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASheetPayload>
          }
          aggregate: {
            args: Prisma.DSASheetAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDSASheet>
          }
          groupBy: {
            args: Prisma.DSASheetGroupByArgs<ExtArgs>
            result: $Utils.Optional<DSASheetGroupByOutputType>[]
          }
          count: {
            args: Prisma.DSASheetCountArgs<ExtArgs>
            result: $Utils.Optional<DSASheetCountAggregateOutputType> | number
          }
        }
      }
      DSATopic: {
        payload: Prisma.$DSATopicPayload<ExtArgs>
        fields: Prisma.DSATopicFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DSATopicFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DSATopicFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>
          }
          findFirst: {
            args: Prisma.DSATopicFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DSATopicFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>
          }
          findMany: {
            args: Prisma.DSATopicFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>[]
          }
          create: {
            args: Prisma.DSATopicCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>
          }
          createMany: {
            args: Prisma.DSATopicCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DSATopicDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>
          }
          update: {
            args: Prisma.DSATopicUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>
          }
          deleteMany: {
            args: Prisma.DSATopicDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DSATopicUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DSATopicUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSATopicPayload>
          }
          aggregate: {
            args: Prisma.DSATopicAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDSATopic>
          }
          groupBy: {
            args: Prisma.DSATopicGroupByArgs<ExtArgs>
            result: $Utils.Optional<DSATopicGroupByOutputType>[]
          }
          count: {
            args: Prisma.DSATopicCountArgs<ExtArgs>
            result: $Utils.Optional<DSATopicCountAggregateOutputType> | number
          }
        }
      }
      DSAProblem: {
        payload: Prisma.$DSAProblemPayload<ExtArgs>
        fields: Prisma.DSAProblemFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DSAProblemFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSAProblemPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DSAProblemFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSAProblemPayload>
          }
          findFirst: {
            args: Prisma.DSAProblemFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSAProblemPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DSAProblemFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSAProblemPayload>
          }
          findMany: {
            args: Prisma.DSAProblemFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSAProblemPayload>[]
          }
          create: {
            args: Prisma.DSAProblemCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSAProblemPayload>
          }
          createMany: {
            args: Prisma.DSAProblemCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DSAProblemDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSAProblemPayload>
          }
          update: {
            args: Prisma.DSAProblemUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSAProblemPayload>
          }
          deleteMany: {
            args: Prisma.DSAProblemDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DSAProblemUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DSAProblemUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSAProblemPayload>
          }
          aggregate: {
            args: Prisma.DSAProblemAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDSAProblem>
          }
          groupBy: {
            args: Prisma.DSAProblemGroupByArgs<ExtArgs>
            result: $Utils.Optional<DSAProblemGroupByOutputType>[]
          }
          count: {
            args: Prisma.DSAProblemCountArgs<ExtArgs>
            result: $Utils.Optional<DSAProblemCountAggregateOutputType> | number
          }
        }
      }
      DSASolution: {
        payload: Prisma.$DSASolutionPayload<ExtArgs>
        fields: Prisma.DSASolutionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DSASolutionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASolutionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DSASolutionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASolutionPayload>
          }
          findFirst: {
            args: Prisma.DSASolutionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASolutionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DSASolutionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASolutionPayload>
          }
          findMany: {
            args: Prisma.DSASolutionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASolutionPayload>[]
          }
          create: {
            args: Prisma.DSASolutionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASolutionPayload>
          }
          createMany: {
            args: Prisma.DSASolutionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.DSASolutionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASolutionPayload>
          }
          update: {
            args: Prisma.DSASolutionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASolutionPayload>
          }
          deleteMany: {
            args: Prisma.DSASolutionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DSASolutionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DSASolutionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DSASolutionPayload>
          }
          aggregate: {
            args: Prisma.DSASolutionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDSASolution>
          }
          groupBy: {
            args: Prisma.DSASolutionGroupByArgs<ExtArgs>
            result: $Utils.Optional<DSASolutionGroupByOutputType>[]
          }
          count: {
            args: Prisma.DSASolutionCountArgs<ExtArgs>
            result: $Utils.Optional<DSASolutionCountAggregateOutputType> | number
          }
        }
      }
      Certificate: {
        payload: Prisma.$CertificatePayload<ExtArgs>
        fields: Prisma.CertificateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.CertificateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.CertificateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findFirst: {
            args: Prisma.CertificateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.CertificateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          findMany: {
            args: Prisma.CertificateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>[]
          }
          create: {
            args: Prisma.CertificateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          createMany: {
            args: Prisma.CertificateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.CertificateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          update: {
            args: Prisma.CertificateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          deleteMany: {
            args: Prisma.CertificateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.CertificateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.CertificateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$CertificatePayload>
          }
          aggregate: {
            args: Prisma.CertificateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCertificate>
          }
          groupBy: {
            args: Prisma.CertificateGroupByArgs<ExtArgs>
            result: $Utils.Optional<CertificateGroupByOutputType>[]
          }
          count: {
            args: Prisma.CertificateCountArgs<ExtArgs>
            result: $Utils.Optional<CertificateCountAggregateOutputType> | number
          }
        }
      }
      EmailLog: {
        payload: Prisma.$EmailLogPayload<ExtArgs>
        fields: Prisma.EmailLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmailLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmailLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findFirst: {
            args: Prisma.EmailLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmailLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          findMany: {
            args: Prisma.EmailLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>[]
          }
          create: {
            args: Prisma.EmailLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          createMany: {
            args: Prisma.EmailLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.EmailLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          update: {
            args: Prisma.EmailLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          deleteMany: {
            args: Prisma.EmailLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmailLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmailLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmailLogPayload>
          }
          aggregate: {
            args: Prisma.EmailLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmailLog>
          }
          groupBy: {
            args: Prisma.EmailLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmailLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmailLogCountArgs<ExtArgs>
            result: $Utils.Optional<EmailLogCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    eventRegistrations: number
    teamsLeading: number
    teamMemberships: number
    teamJoinRequests: number
    submissions: number
    challengeProgress: number
    taskCompletions: number
    badges: number
    achievements: number
    leaderboardEntries: number
    eventsCreated: number
    challengesCreated: number
    certificates: number
    emailsSent: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventRegistrations?: boolean | UserCountOutputTypeCountEventRegistrationsArgs
    teamsLeading?: boolean | UserCountOutputTypeCountTeamsLeadingArgs
    teamMemberships?: boolean | UserCountOutputTypeCountTeamMembershipsArgs
    teamJoinRequests?: boolean | UserCountOutputTypeCountTeamJoinRequestsArgs
    submissions?: boolean | UserCountOutputTypeCountSubmissionsArgs
    challengeProgress?: boolean | UserCountOutputTypeCountChallengeProgressArgs
    taskCompletions?: boolean | UserCountOutputTypeCountTaskCompletionsArgs
    badges?: boolean | UserCountOutputTypeCountBadgesArgs
    achievements?: boolean | UserCountOutputTypeCountAchievementsArgs
    leaderboardEntries?: boolean | UserCountOutputTypeCountLeaderboardEntriesArgs
    eventsCreated?: boolean | UserCountOutputTypeCountEventsCreatedArgs
    challengesCreated?: boolean | UserCountOutputTypeCountChallengesCreatedArgs
    certificates?: boolean | UserCountOutputTypeCountCertificatesArgs
    emailsSent?: boolean | UserCountOutputTypeCountEmailsSentArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamsLeadingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTeamJoinRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamJoinRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventSubmissionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChallengeProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeProgressWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTaskCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTaskCompletionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountBadgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAchievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEventsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountChallengesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountEmailsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
  }


  /**
   * Count Type EventCategoryCountOutputType
   */

  export type EventCategoryCountOutputType = {
    children: number
    events: number
    eventTypes: number
  }

  export type EventCategoryCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    children?: boolean | EventCategoryCountOutputTypeCountChildrenArgs
    events?: boolean | EventCategoryCountOutputTypeCountEventsArgs
    eventTypes?: boolean | EventCategoryCountOutputTypeCountEventTypesArgs
  }

  // Custom InputTypes
  /**
   * EventCategoryCountOutputType without action
   */
  export type EventCategoryCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategoryCountOutputType
     */
    select?: EventCategoryCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCategoryCountOutputType without action
   */
  export type EventCategoryCountOutputTypeCountChildrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCategoryWhereInput
  }

  /**
   * EventCategoryCountOutputType without action
   */
  export type EventCategoryCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }

  /**
   * EventCategoryCountOutputType without action
   */
  export type EventCategoryCountOutputTypeCountEventTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventTypeWhereInput
  }


  /**
   * Count Type EventCountOutputType
   */

  export type EventCountOutputType = {
    registrations: number
    teams: number
    submissions: number
    eventChallenges: number
    emailLogs: number
    certificates: number
  }

  export type EventCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    registrations?: boolean | EventCountOutputTypeCountRegistrationsArgs
    teams?: boolean | EventCountOutputTypeCountTeamsArgs
    submissions?: boolean | EventCountOutputTypeCountSubmissionsArgs
    eventChallenges?: boolean | EventCountOutputTypeCountEventChallengesArgs
    emailLogs?: boolean | EventCountOutputTypeCountEmailLogsArgs
    certificates?: boolean | EventCountOutputTypeCountCertificatesArgs
  }

  // Custom InputTypes
  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCountOutputType
     */
    select?: EventCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountTeamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventSubmissionWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEventChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventChallengeWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountEmailLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
  }

  /**
   * EventCountOutputType without action
   */
  export type EventCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Count Type TeamCountOutputType
   */

  export type TeamCountOutputType = {
    members: number
    joinRequests: number
    registrations: number
    submissions: number
    certificates: number
  }

  export type TeamCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    members?: boolean | TeamCountOutputTypeCountMembersArgs
    joinRequests?: boolean | TeamCountOutputTypeCountJoinRequestsArgs
    registrations?: boolean | TeamCountOutputTypeCountRegistrationsArgs
    submissions?: boolean | TeamCountOutputTypeCountSubmissionsArgs
    certificates?: boolean | TeamCountOutputTypeCountCertificatesArgs
  }

  // Custom InputTypes
  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamCountOutputType
     */
    select?: TeamCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountMembersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountJoinRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamJoinRequestWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountSubmissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventSubmissionWhereInput
  }

  /**
   * TeamCountOutputType without action
   */
  export type TeamCountOutputTypeCountCertificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
  }


  /**
   * Count Type ChallengeCountOutputType
   */

  export type ChallengeCountOutputType = {
    tasks: number
    userProgress: number
    eventChallenges: number
  }

  export type ChallengeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    tasks?: boolean | ChallengeCountOutputTypeCountTasksArgs
    userProgress?: boolean | ChallengeCountOutputTypeCountUserProgressArgs
    eventChallenges?: boolean | ChallengeCountOutputTypeCountEventChallengesArgs
  }

  // Custom InputTypes
  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeCountOutputType
     */
    select?: ChallengeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountTasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeTaskWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountUserProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeProgressWhereInput
  }

  /**
   * ChallengeCountOutputType without action
   */
  export type ChallengeCountOutputTypeCountEventChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventChallengeWhereInput
  }


  /**
   * Count Type ChallengeTaskCountOutputType
   */

  export type ChallengeTaskCountOutputType = {
    completions: number
  }

  export type ChallengeTaskCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    completions?: boolean | ChallengeTaskCountOutputTypeCountCompletionsArgs
  }

  // Custom InputTypes
  /**
   * ChallengeTaskCountOutputType without action
   */
  export type ChallengeTaskCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTaskCountOutputType
     */
    select?: ChallengeTaskCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ChallengeTaskCountOutputType without action
   */
  export type ChallengeTaskCountOutputTypeCountCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTaskCompletionWhereInput
  }


  /**
   * Count Type UserChallengeProgressCountOutputType
   */

  export type UserChallengeProgressCountOutputType = {
    taskCompletions: number
  }

  export type UserChallengeProgressCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    taskCompletions?: boolean | UserChallengeProgressCountOutputTypeCountTaskCompletionsArgs
  }

  // Custom InputTypes
  /**
   * UserChallengeProgressCountOutputType without action
   */
  export type UserChallengeProgressCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgressCountOutputType
     */
    select?: UserChallengeProgressCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserChallengeProgressCountOutputType without action
   */
  export type UserChallengeProgressCountOutputTypeCountTaskCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTaskCompletionWhereInput
  }


  /**
   * Count Type RoadmapCountOutputType
   */

  export type RoadmapCountOutputType = {
    phases: number
    events: number
  }

  export type RoadmapCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | RoadmapCountOutputTypeCountPhasesArgs
    events?: boolean | RoadmapCountOutputTypeCountEventsArgs
  }

  // Custom InputTypes
  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapCountOutputType
     */
    select?: RoadmapCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountPhasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapPhaseWhereInput
  }

  /**
   * RoadmapCountOutputType without action
   */
  export type RoadmapCountOutputTypeCountEventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
  }


  /**
   * Count Type RoadmapPhaseCountOutputType
   */

  export type RoadmapPhaseCountOutputType = {
    sections: number
    playlists: number
    projects: number
  }

  export type RoadmapPhaseCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sections?: boolean | RoadmapPhaseCountOutputTypeCountSectionsArgs
    playlists?: boolean | RoadmapPhaseCountOutputTypeCountPlaylistsArgs
    projects?: boolean | RoadmapPhaseCountOutputTypeCountProjectsArgs
  }

  // Custom InputTypes
  /**
   * RoadmapPhaseCountOutputType without action
   */
  export type RoadmapPhaseCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhaseCountOutputType
     */
    select?: RoadmapPhaseCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * RoadmapPhaseCountOutputType without action
   */
  export type RoadmapPhaseCountOutputTypeCountSectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhaseSectionWhereInput
  }

  /**
   * RoadmapPhaseCountOutputType without action
   */
  export type RoadmapPhaseCountOutputTypeCountPlaylistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhasePlaylistWhereInput
  }

  /**
   * RoadmapPhaseCountOutputType without action
   */
  export type RoadmapPhaseCountOutputTypeCountProjectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhaseProjectWhereInput
  }


  /**
   * Count Type PhaseSectionCountOutputType
   */

  export type PhaseSectionCountOutputType = {
    items: number
  }

  export type PhaseSectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    items?: boolean | PhaseSectionCountOutputTypeCountItemsArgs
  }

  // Custom InputTypes
  /**
   * PhaseSectionCountOutputType without action
   */
  export type PhaseSectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseSectionCountOutputType
     */
    select?: PhaseSectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * PhaseSectionCountOutputType without action
   */
  export type PhaseSectionCountOutputTypeCountItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionItemWhereInput
  }


  /**
   * Count Type SectionItemCountOutputType
   */

  export type SectionItemCountOutputType = {
    subItems: number
  }

  export type SectionItemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    subItems?: boolean | SectionItemCountOutputTypeCountSubItemsArgs
  }

  // Custom InputTypes
  /**
   * SectionItemCountOutputType without action
   */
  export type SectionItemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionItemCountOutputType
     */
    select?: SectionItemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * SectionItemCountOutputType without action
   */
  export type SectionItemCountOutputTypeCountSubItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubItemWhereInput
  }


  /**
   * Count Type DSASheetCountOutputType
   */

  export type DSASheetCountOutputType = {
    topics: number
  }

  export type DSASheetCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | DSASheetCountOutputTypeCountTopicsArgs
  }

  // Custom InputTypes
  /**
   * DSASheetCountOutputType without action
   */
  export type DSASheetCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASheetCountOutputType
     */
    select?: DSASheetCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DSASheetCountOutputType without action
   */
  export type DSASheetCountOutputTypeCountTopicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DSATopicWhereInput
  }


  /**
   * Count Type DSATopicCountOutputType
   */

  export type DSATopicCountOutputType = {
    problems: number
  }

  export type DSATopicCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problems?: boolean | DSATopicCountOutputTypeCountProblemsArgs
  }

  // Custom InputTypes
  /**
   * DSATopicCountOutputType without action
   */
  export type DSATopicCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopicCountOutputType
     */
    select?: DSATopicCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DSATopicCountOutputType without action
   */
  export type DSATopicCountOutputTypeCountProblemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DSAProblemWhereInput
  }


  /**
   * Count Type DSAProblemCountOutputType
   */

  export type DSAProblemCountOutputType = {
    solutions: number
  }

  export type DSAProblemCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    solutions?: boolean | DSAProblemCountOutputTypeCountSolutionsArgs
  }

  // Custom InputTypes
  /**
   * DSAProblemCountOutputType without action
   */
  export type DSAProblemCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSAProblemCountOutputType
     */
    select?: DSAProblemCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DSAProblemCountOutputType without action
   */
  export type DSAProblemCountOutputTypeCountSolutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DSASolutionWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserAvgAggregateOutputType = {
    totalPoints: number | null
    currentStreak: number | null
    longestStreak: number | null
    level: number | null
  }

  export type UserSumAggregateOutputType = {
    totalPoints: number | null
    currentStreak: number | null
    longestStreak: number | null
    level: number | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    whatsapp: string | null
    gender: string | null
    graduation: string | null
    specialization: string | null
    year: string | null
    regNumber: string | null
    domain: string | null
    githubUrl: string | null
    codingUrl: string | null
    profilePicture: string | null
    totalPoints: number | null
    currentStreak: number | null
    longestStreak: number | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastActive: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    fullName: string | null
    whatsapp: string | null
    gender: string | null
    graduation: string | null
    specialization: string | null
    year: string | null
    regNumber: string | null
    domain: string | null
    githubUrl: string | null
    codingUrl: string | null
    profilePicture: string | null
    totalPoints: number | null
    currentStreak: number | null
    longestStreak: number | null
    level: number | null
    createdAt: Date | null
    updatedAt: Date | null
    lastActive: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    fullName: number
    whatsapp: number
    gender: number
    graduation: number
    specialization: number
    year: number
    regNumber: number
    skills: number
    domain: number
    githubUrl: number
    codingUrl: number
    profilePicture: number
    totalPoints: number
    currentStreak: number
    longestStreak: number
    level: number
    createdAt: number
    updatedAt: number
    lastActive: number
    _all: number
  }


  export type UserAvgAggregateInputType = {
    totalPoints?: true
    currentStreak?: true
    longestStreak?: true
    level?: true
  }

  export type UserSumAggregateInputType = {
    totalPoints?: true
    currentStreak?: true
    longestStreak?: true
    level?: true
  }

  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    whatsapp?: true
    gender?: true
    graduation?: true
    specialization?: true
    year?: true
    regNumber?: true
    domain?: true
    githubUrl?: true
    codingUrl?: true
    profilePicture?: true
    totalPoints?: true
    currentStreak?: true
    longestStreak?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    lastActive?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    whatsapp?: true
    gender?: true
    graduation?: true
    specialization?: true
    year?: true
    regNumber?: true
    domain?: true
    githubUrl?: true
    codingUrl?: true
    profilePicture?: true
    totalPoints?: true
    currentStreak?: true
    longestStreak?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    lastActive?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    fullName?: true
    whatsapp?: true
    gender?: true
    graduation?: true
    specialization?: true
    year?: true
    regNumber?: true
    skills?: true
    domain?: true
    githubUrl?: true
    codingUrl?: true
    profilePicture?: true
    totalPoints?: true
    currentStreak?: true
    longestStreak?: true
    level?: true
    createdAt?: true
    updatedAt?: true
    lastActive?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _avg?: UserAvgAggregateInputType
    _sum?: UserSumAggregateInputType
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    fullName: string
    whatsapp: string | null
    gender: string | null
    graduation: string | null
    specialization: string | null
    year: string | null
    regNumber: string | null
    skills: JsonValue | null
    domain: string | null
    githubUrl: string | null
    codingUrl: string | null
    profilePicture: string | null
    totalPoints: number
    currentStreak: number
    longestStreak: number
    level: number
    createdAt: Date
    updatedAt: Date
    lastActive: Date | null
    _count: UserCountAggregateOutputType | null
    _avg: UserAvgAggregateOutputType | null
    _sum: UserSumAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    fullName?: boolean
    whatsapp?: boolean
    gender?: boolean
    graduation?: boolean
    specialization?: boolean
    year?: boolean
    regNumber?: boolean
    skills?: boolean
    domain?: boolean
    githubUrl?: boolean
    codingUrl?: boolean
    profilePicture?: boolean
    totalPoints?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActive?: boolean
    eventRegistrations?: boolean | User$eventRegistrationsArgs<ExtArgs>
    teamsLeading?: boolean | User$teamsLeadingArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    teamJoinRequests?: boolean | User$teamJoinRequestsArgs<ExtArgs>
    submissions?: boolean | User$submissionsArgs<ExtArgs>
    challengeProgress?: boolean | User$challengeProgressArgs<ExtArgs>
    taskCompletions?: boolean | User$taskCompletionsArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    leaderboardEntries?: boolean | User$leaderboardEntriesArgs<ExtArgs>
    eventsCreated?: boolean | User$eventsCreatedArgs<ExtArgs>
    challengesCreated?: boolean | User$challengesCreatedArgs<ExtArgs>
    certificates?: boolean | User$certificatesArgs<ExtArgs>
    emailsSent?: boolean | User$emailsSentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>


  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    fullName?: boolean
    whatsapp?: boolean
    gender?: boolean
    graduation?: boolean
    specialization?: boolean
    year?: boolean
    regNumber?: boolean
    skills?: boolean
    domain?: boolean
    githubUrl?: boolean
    codingUrl?: boolean
    profilePicture?: boolean
    totalPoints?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    level?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    lastActive?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    eventRegistrations?: boolean | User$eventRegistrationsArgs<ExtArgs>
    teamsLeading?: boolean | User$teamsLeadingArgs<ExtArgs>
    teamMemberships?: boolean | User$teamMembershipsArgs<ExtArgs>
    teamJoinRequests?: boolean | User$teamJoinRequestsArgs<ExtArgs>
    submissions?: boolean | User$submissionsArgs<ExtArgs>
    challengeProgress?: boolean | User$challengeProgressArgs<ExtArgs>
    taskCompletions?: boolean | User$taskCompletionsArgs<ExtArgs>
    badges?: boolean | User$badgesArgs<ExtArgs>
    achievements?: boolean | User$achievementsArgs<ExtArgs>
    leaderboardEntries?: boolean | User$leaderboardEntriesArgs<ExtArgs>
    eventsCreated?: boolean | User$eventsCreatedArgs<ExtArgs>
    challengesCreated?: boolean | User$challengesCreatedArgs<ExtArgs>
    certificates?: boolean | User$certificatesArgs<ExtArgs>
    emailsSent?: boolean | User$emailsSentArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      eventRegistrations: Prisma.$EventRegistrationPayload<ExtArgs>[]
      teamsLeading: Prisma.$TeamPayload<ExtArgs>[]
      teamMemberships: Prisma.$TeamMemberPayload<ExtArgs>[]
      teamJoinRequests: Prisma.$TeamJoinRequestPayload<ExtArgs>[]
      submissions: Prisma.$EventSubmissionPayload<ExtArgs>[]
      challengeProgress: Prisma.$UserChallengeProgressPayload<ExtArgs>[]
      taskCompletions: Prisma.$UserTaskCompletionPayload<ExtArgs>[]
      badges: Prisma.$UserBadgePayload<ExtArgs>[]
      achievements: Prisma.$UserAchievementPayload<ExtArgs>[]
      leaderboardEntries: Prisma.$LeaderboardPayload<ExtArgs>[]
      eventsCreated: Prisma.$EventPayload<ExtArgs>[]
      challengesCreated: Prisma.$ChallengePayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
      emailsSent: Prisma.$EmailLogPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      fullName: string
      whatsapp: string | null
      gender: string | null
      graduation: string | null
      specialization: string | null
      year: string | null
      regNumber: string | null
      skills: Prisma.JsonValue | null
      domain: string | null
      githubUrl: string | null
      codingUrl: string | null
      profilePicture: string | null
      totalPoints: number
      currentStreak: number
      longestStreak: number
      level: number
      createdAt: Date
      updatedAt: Date
      lastActive: Date | null
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    eventRegistrations<T extends User$eventRegistrationsArgs<ExtArgs> = {}>(args?: Subset<T, User$eventRegistrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findMany"> | Null>
    teamsLeading<T extends User$teamsLeadingArgs<ExtArgs> = {}>(args?: Subset<T, User$teamsLeadingArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany"> | Null>
    teamMemberships<T extends User$teamMembershipsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamMembershipsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany"> | Null>
    teamJoinRequests<T extends User$teamJoinRequestsArgs<ExtArgs> = {}>(args?: Subset<T, User$teamJoinRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamJoinRequestPayload<ExtArgs>, T, "findMany"> | Null>
    submissions<T extends User$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, User$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventSubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    challengeProgress<T extends User$challengeProgressArgs<ExtArgs> = {}>(args?: Subset<T, User$challengeProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengeProgressPayload<ExtArgs>, T, "findMany"> | Null>
    taskCompletions<T extends User$taskCompletionsArgs<ExtArgs> = {}>(args?: Subset<T, User$taskCompletionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTaskCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    badges<T extends User$badgesArgs<ExtArgs> = {}>(args?: Subset<T, User$badgesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany"> | Null>
    achievements<T extends User$achievementsArgs<ExtArgs> = {}>(args?: Subset<T, User$achievementsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany"> | Null>
    leaderboardEntries<T extends User$leaderboardEntriesArgs<ExtArgs> = {}>(args?: Subset<T, User$leaderboardEntriesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findMany"> | Null>
    eventsCreated<T extends User$eventsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$eventsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    challengesCreated<T extends User$challengesCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$challengesCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany"> | Null>
    certificates<T extends User$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, User$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    emailsSent<T extends User$emailsSentArgs<ExtArgs> = {}>(args?: Subset<T, User$emailsSentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly fullName: FieldRef<"User", 'String'>
    readonly whatsapp: FieldRef<"User", 'String'>
    readonly gender: FieldRef<"User", 'String'>
    readonly graduation: FieldRef<"User", 'String'>
    readonly specialization: FieldRef<"User", 'String'>
    readonly year: FieldRef<"User", 'String'>
    readonly regNumber: FieldRef<"User", 'String'>
    readonly skills: FieldRef<"User", 'Json'>
    readonly domain: FieldRef<"User", 'String'>
    readonly githubUrl: FieldRef<"User", 'String'>
    readonly codingUrl: FieldRef<"User", 'String'>
    readonly profilePicture: FieldRef<"User", 'String'>
    readonly totalPoints: FieldRef<"User", 'Int'>
    readonly currentStreak: FieldRef<"User", 'Int'>
    readonly longestStreak: FieldRef<"User", 'Int'>
    readonly level: FieldRef<"User", 'Int'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
    readonly lastActive: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.eventRegistrations
   */
  export type User$eventRegistrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    where?: EventRegistrationWhereInput
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    cursor?: EventRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * User.teamsLeading
   */
  export type User$teamsLeadingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * User.teamMemberships
   */
  export type User$teamMembershipsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * User.teamJoinRequests
   */
  export type User$teamJoinRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null
    where?: TeamJoinRequestWhereInput
    orderBy?: TeamJoinRequestOrderByWithRelationInput | TeamJoinRequestOrderByWithRelationInput[]
    cursor?: TeamJoinRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamJoinRequestScalarFieldEnum | TeamJoinRequestScalarFieldEnum[]
  }

  /**
   * User.submissions
   */
  export type User$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
    where?: EventSubmissionWhereInput
    orderBy?: EventSubmissionOrderByWithRelationInput | EventSubmissionOrderByWithRelationInput[]
    cursor?: EventSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventSubmissionScalarFieldEnum | EventSubmissionScalarFieldEnum[]
  }

  /**
   * User.challengeProgress
   */
  export type User$challengeProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgress
     */
    select?: UserChallengeProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeProgressInclude<ExtArgs> | null
    where?: UserChallengeProgressWhereInput
    orderBy?: UserChallengeProgressOrderByWithRelationInput | UserChallengeProgressOrderByWithRelationInput[]
    cursor?: UserChallengeProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserChallengeProgressScalarFieldEnum | UserChallengeProgressScalarFieldEnum[]
  }

  /**
   * User.taskCompletions
   */
  export type User$taskCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
    where?: UserTaskCompletionWhereInput
    orderBy?: UserTaskCompletionOrderByWithRelationInput | UserTaskCompletionOrderByWithRelationInput[]
    cursor?: UserTaskCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTaskCompletionScalarFieldEnum | UserTaskCompletionScalarFieldEnum[]
  }

  /**
   * User.badges
   */
  export type User$badgesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    cursor?: UserBadgeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * User.achievements
   */
  export type User$achievementsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    cursor?: UserAchievementWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * User.leaderboardEntries
   */
  export type User$leaderboardEntriesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    where?: LeaderboardWhereInput
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    cursor?: LeaderboardWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * User.eventsCreated
   */
  export type User$eventsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * User.challengesCreated
   */
  export type User$challengesCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    cursor?: ChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * User.certificates
   */
  export type User$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * User.emailsSent
   */
  export type User$emailsSentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    cursor?: EmailLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model EventCategory
   */

  export type AggregateEventCategory = {
    _count: EventCategoryCountAggregateOutputType | null
    _min: EventCategoryMinAggregateOutputType | null
    _max: EventCategoryMaxAggregateOutputType | null
  }

  export type EventCategoryMinAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    createdAt: Date | null
  }

  export type EventCategoryMaxAggregateOutputType = {
    id: string | null
    name: string | null
    slug: string | null
    description: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    createdAt: Date | null
  }

  export type EventCategoryCountAggregateOutputType = {
    id: number
    name: number
    slug: number
    description: number
    icon: number
    color: number
    parentId: number
    createdAt: number
    _all: number
  }


  export type EventCategoryMinAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    color?: true
    parentId?: true
    createdAt?: true
  }

  export type EventCategoryMaxAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    color?: true
    parentId?: true
    createdAt?: true
  }

  export type EventCategoryCountAggregateInputType = {
    id?: true
    name?: true
    slug?: true
    description?: true
    icon?: true
    color?: true
    parentId?: true
    createdAt?: true
    _all?: true
  }

  export type EventCategoryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventCategory to aggregate.
     */
    where?: EventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventCategories
    **/
    _count?: true | EventCategoryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventCategoryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventCategoryMaxAggregateInputType
  }

  export type GetEventCategoryAggregateType<T extends EventCategoryAggregateArgs> = {
        [P in keyof T & keyof AggregateEventCategory]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventCategory[P]>
      : GetScalarType<T[P], AggregateEventCategory[P]>
  }




  export type EventCategoryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventCategoryWhereInput
    orderBy?: EventCategoryOrderByWithAggregationInput | EventCategoryOrderByWithAggregationInput[]
    by: EventCategoryScalarFieldEnum[] | EventCategoryScalarFieldEnum
    having?: EventCategoryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCategoryCountAggregateInputType | true
    _min?: EventCategoryMinAggregateInputType
    _max?: EventCategoryMaxAggregateInputType
  }

  export type EventCategoryGroupByOutputType = {
    id: string
    name: string
    slug: string
    description: string | null
    icon: string | null
    color: string | null
    parentId: string | null
    createdAt: Date
    _count: EventCategoryCountAggregateOutputType | null
    _min: EventCategoryMinAggregateOutputType | null
    _max: EventCategoryMaxAggregateOutputType | null
  }

  type GetEventCategoryGroupByPayload<T extends EventCategoryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventCategoryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventCategoryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventCategoryGroupByOutputType[P]>
            : GetScalarType<T[P], EventCategoryGroupByOutputType[P]>
        }
      >
    >


  export type EventCategorySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    createdAt?: boolean
    parent?: boolean | EventCategory$parentArgs<ExtArgs>
    children?: boolean | EventCategory$childrenArgs<ExtArgs>
    events?: boolean | EventCategory$eventsArgs<ExtArgs>
    eventTypes?: boolean | EventCategory$eventTypesArgs<ExtArgs>
    _count?: boolean | EventCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventCategory"]>


  export type EventCategorySelectScalar = {
    id?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    icon?: boolean
    color?: boolean
    parentId?: boolean
    createdAt?: boolean
  }

  export type EventCategoryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    parent?: boolean | EventCategory$parentArgs<ExtArgs>
    children?: boolean | EventCategory$childrenArgs<ExtArgs>
    events?: boolean | EventCategory$eventsArgs<ExtArgs>
    eventTypes?: boolean | EventCategory$eventTypesArgs<ExtArgs>
    _count?: boolean | EventCategoryCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EventCategoryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventCategory"
    objects: {
      parent: Prisma.$EventCategoryPayload<ExtArgs> | null
      children: Prisma.$EventCategoryPayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
      eventTypes: Prisma.$EventTypePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      slug: string
      description: string | null
      icon: string | null
      color: string | null
      parentId: string | null
      createdAt: Date
    }, ExtArgs["result"]["eventCategory"]>
    composites: {}
  }

  type EventCategoryGetPayload<S extends boolean | null | undefined | EventCategoryDefaultArgs> = $Result.GetResult<Prisma.$EventCategoryPayload, S>

  type EventCategoryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventCategoryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCategoryCountAggregateInputType | true
    }

  export interface EventCategoryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventCategory'], meta: { name: 'EventCategory' } }
    /**
     * Find zero or one EventCategory that matches the filter.
     * @param {EventCategoryFindUniqueArgs} args - Arguments to find a EventCategory
     * @example
     * // Get one EventCategory
     * const eventCategory = await prisma.eventCategory.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventCategoryFindUniqueArgs>(args: SelectSubset<T, EventCategoryFindUniqueArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventCategory that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventCategoryFindUniqueOrThrowArgs} args - Arguments to find a EventCategory
     * @example
     * // Get one EventCategory
     * const eventCategory = await prisma.eventCategory.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventCategoryFindUniqueOrThrowArgs>(args: SelectSubset<T, EventCategoryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventCategory that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryFindFirstArgs} args - Arguments to find a EventCategory
     * @example
     * // Get one EventCategory
     * const eventCategory = await prisma.eventCategory.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventCategoryFindFirstArgs>(args?: SelectSubset<T, EventCategoryFindFirstArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventCategory that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryFindFirstOrThrowArgs} args - Arguments to find a EventCategory
     * @example
     * // Get one EventCategory
     * const eventCategory = await prisma.eventCategory.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventCategoryFindFirstOrThrowArgs>(args?: SelectSubset<T, EventCategoryFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventCategories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventCategories
     * const eventCategories = await prisma.eventCategory.findMany()
     * 
     * // Get first 10 EventCategories
     * const eventCategories = await prisma.eventCategory.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventCategoryWithIdOnly = await prisma.eventCategory.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventCategoryFindManyArgs>(args?: SelectSubset<T, EventCategoryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventCategory.
     * @param {EventCategoryCreateArgs} args - Arguments to create a EventCategory.
     * @example
     * // Create one EventCategory
     * const EventCategory = await prisma.eventCategory.create({
     *   data: {
     *     // ... data to create a EventCategory
     *   }
     * })
     * 
     */
    create<T extends EventCategoryCreateArgs>(args: SelectSubset<T, EventCategoryCreateArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventCategories.
     * @param {EventCategoryCreateManyArgs} args - Arguments to create many EventCategories.
     * @example
     * // Create many EventCategories
     * const eventCategory = await prisma.eventCategory.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCategoryCreateManyArgs>(args?: SelectSubset<T, EventCategoryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventCategory.
     * @param {EventCategoryDeleteArgs} args - Arguments to delete one EventCategory.
     * @example
     * // Delete one EventCategory
     * const EventCategory = await prisma.eventCategory.delete({
     *   where: {
     *     // ... filter to delete one EventCategory
     *   }
     * })
     * 
     */
    delete<T extends EventCategoryDeleteArgs>(args: SelectSubset<T, EventCategoryDeleteArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventCategory.
     * @param {EventCategoryUpdateArgs} args - Arguments to update one EventCategory.
     * @example
     * // Update one EventCategory
     * const eventCategory = await prisma.eventCategory.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventCategoryUpdateArgs>(args: SelectSubset<T, EventCategoryUpdateArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventCategories.
     * @param {EventCategoryDeleteManyArgs} args - Arguments to filter EventCategories to delete.
     * @example
     * // Delete a few EventCategories
     * const { count } = await prisma.eventCategory.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventCategoryDeleteManyArgs>(args?: SelectSubset<T, EventCategoryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventCategories
     * const eventCategory = await prisma.eventCategory.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventCategoryUpdateManyArgs>(args: SelectSubset<T, EventCategoryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventCategory.
     * @param {EventCategoryUpsertArgs} args - Arguments to update or create a EventCategory.
     * @example
     * // Update or create a EventCategory
     * const eventCategory = await prisma.eventCategory.upsert({
     *   create: {
     *     // ... data to create a EventCategory
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventCategory we want to update
     *   }
     * })
     */
    upsert<T extends EventCategoryUpsertArgs>(args: SelectSubset<T, EventCategoryUpsertArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventCategories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryCountArgs} args - Arguments to filter EventCategories to count.
     * @example
     * // Count the number of EventCategories
     * const count = await prisma.eventCategory.count({
     *   where: {
     *     // ... the filter for the EventCategories we want to count
     *   }
     * })
    **/
    count<T extends EventCategoryCountArgs>(
      args?: Subset<T, EventCategoryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCategoryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventCategoryAggregateArgs>(args: Subset<T, EventCategoryAggregateArgs>): Prisma.PrismaPromise<GetEventCategoryAggregateType<T>>

    /**
     * Group by EventCategory.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCategoryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventCategoryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventCategoryGroupByArgs['orderBy'] }
        : { orderBy?: EventCategoryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventCategoryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventCategoryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventCategory model
   */
  readonly fields: EventCategoryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventCategory.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventCategoryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    parent<T extends EventCategory$parentArgs<ExtArgs> = {}>(args?: Subset<T, EventCategory$parentArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    children<T extends EventCategory$childrenArgs<ExtArgs> = {}>(args?: Subset<T, EventCategory$childrenArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends EventCategory$eventsArgs<ExtArgs> = {}>(args?: Subset<T, EventCategory$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    eventTypes<T extends EventCategory$eventTypesArgs<ExtArgs> = {}>(args?: Subset<T, EventCategory$eventTypesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventCategory model
   */ 
  interface EventCategoryFieldRefs {
    readonly id: FieldRef<"EventCategory", 'String'>
    readonly name: FieldRef<"EventCategory", 'String'>
    readonly slug: FieldRef<"EventCategory", 'String'>
    readonly description: FieldRef<"EventCategory", 'String'>
    readonly icon: FieldRef<"EventCategory", 'String'>
    readonly color: FieldRef<"EventCategory", 'String'>
    readonly parentId: FieldRef<"EventCategory", 'String'>
    readonly createdAt: FieldRef<"EventCategory", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventCategory findUnique
   */
  export type EventCategoryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategory to fetch.
     */
    where: EventCategoryWhereUniqueInput
  }

  /**
   * EventCategory findUniqueOrThrow
   */
  export type EventCategoryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategory to fetch.
     */
    where: EventCategoryWhereUniqueInput
  }

  /**
   * EventCategory findFirst
   */
  export type EventCategoryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategory to fetch.
     */
    where?: EventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventCategories.
     */
    cursor?: EventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventCategories.
     */
    distinct?: EventCategoryScalarFieldEnum | EventCategoryScalarFieldEnum[]
  }

  /**
   * EventCategory findFirstOrThrow
   */
  export type EventCategoryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategory to fetch.
     */
    where?: EventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventCategories.
     */
    cursor?: EventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventCategories.
     */
    distinct?: EventCategoryScalarFieldEnum | EventCategoryScalarFieldEnum[]
  }

  /**
   * EventCategory findMany
   */
  export type EventCategoryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter, which EventCategories to fetch.
     */
    where?: EventCategoryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventCategories to fetch.
     */
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventCategories.
     */
    cursor?: EventCategoryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventCategories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventCategories.
     */
    skip?: number
    distinct?: EventCategoryScalarFieldEnum | EventCategoryScalarFieldEnum[]
  }

  /**
   * EventCategory create
   */
  export type EventCategoryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * The data needed to create a EventCategory.
     */
    data: XOR<EventCategoryCreateInput, EventCategoryUncheckedCreateInput>
  }

  /**
   * EventCategory createMany
   */
  export type EventCategoryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventCategories.
     */
    data: EventCategoryCreateManyInput | EventCategoryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventCategory update
   */
  export type EventCategoryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * The data needed to update a EventCategory.
     */
    data: XOR<EventCategoryUpdateInput, EventCategoryUncheckedUpdateInput>
    /**
     * Choose, which EventCategory to update.
     */
    where: EventCategoryWhereUniqueInput
  }

  /**
   * EventCategory updateMany
   */
  export type EventCategoryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventCategories.
     */
    data: XOR<EventCategoryUpdateManyMutationInput, EventCategoryUncheckedUpdateManyInput>
    /**
     * Filter which EventCategories to update
     */
    where?: EventCategoryWhereInput
  }

  /**
   * EventCategory upsert
   */
  export type EventCategoryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * The filter to search for the EventCategory to update in case it exists.
     */
    where: EventCategoryWhereUniqueInput
    /**
     * In case the EventCategory found by the `where` argument doesn't exist, create a new EventCategory with this data.
     */
    create: XOR<EventCategoryCreateInput, EventCategoryUncheckedCreateInput>
    /**
     * In case the EventCategory was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventCategoryUpdateInput, EventCategoryUncheckedUpdateInput>
  }

  /**
   * EventCategory delete
   */
  export type EventCategoryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    /**
     * Filter which EventCategory to delete.
     */
    where: EventCategoryWhereUniqueInput
  }

  /**
   * EventCategory deleteMany
   */
  export type EventCategoryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventCategories to delete
     */
    where?: EventCategoryWhereInput
  }

  /**
   * EventCategory.parent
   */
  export type EventCategory$parentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    where?: EventCategoryWhereInput
  }

  /**
   * EventCategory.children
   */
  export type EventCategory$childrenArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
    where?: EventCategoryWhereInput
    orderBy?: EventCategoryOrderByWithRelationInput | EventCategoryOrderByWithRelationInput[]
    cursor?: EventCategoryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventCategoryScalarFieldEnum | EventCategoryScalarFieldEnum[]
  }

  /**
   * EventCategory.events
   */
  export type EventCategory$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * EventCategory.eventTypes
   */
  export type EventCategory$eventTypesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    where?: EventTypeWhereInput
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    cursor?: EventTypeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventCategory without action
   */
  export type EventCategoryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventCategory
     */
    select?: EventCategorySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventCategoryInclude<ExtArgs> | null
  }


  /**
   * Model EventType
   */

  export type AggregateEventType = {
    _count: EventTypeCountAggregateOutputType | null
    _avg: EventTypeAvgAggregateOutputType | null
    _sum: EventTypeSumAggregateOutputType | null
    _min: EventTypeMinAggregateOutputType | null
    _max: EventTypeMaxAggregateOutputType | null
  }

  export type EventTypeAvgAggregateOutputType = {
    defaultDurationHours: number | null
  }

  export type EventTypeSumAggregateOutputType = {
    defaultDurationHours: number | null
  }

  export type EventTypeMinAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    slug: string | null
    description: string | null
    defaultDurationHours: number | null
    createdAt: Date | null
  }

  export type EventTypeMaxAggregateOutputType = {
    id: string | null
    categoryId: string | null
    name: string | null
    slug: string | null
    description: string | null
    defaultDurationHours: number | null
    createdAt: Date | null
  }

  export type EventTypeCountAggregateOutputType = {
    id: number
    categoryId: number
    name: number
    slug: number
    description: number
    defaultDurationHours: number
    createdAt: number
    _all: number
  }


  export type EventTypeAvgAggregateInputType = {
    defaultDurationHours?: true
  }

  export type EventTypeSumAggregateInputType = {
    defaultDurationHours?: true
  }

  export type EventTypeMinAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    slug?: true
    description?: true
    defaultDurationHours?: true
    createdAt?: true
  }

  export type EventTypeMaxAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    slug?: true
    description?: true
    defaultDurationHours?: true
    createdAt?: true
  }

  export type EventTypeCountAggregateInputType = {
    id?: true
    categoryId?: true
    name?: true
    slug?: true
    description?: true
    defaultDurationHours?: true
    createdAt?: true
    _all?: true
  }

  export type EventTypeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventType to aggregate.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventTypes
    **/
    _count?: true | EventTypeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventTypeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventTypeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventTypeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventTypeMaxAggregateInputType
  }

  export type GetEventTypeAggregateType<T extends EventTypeAggregateArgs> = {
        [P in keyof T & keyof AggregateEventType]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventType[P]>
      : GetScalarType<T[P], AggregateEventType[P]>
  }




  export type EventTypeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventTypeWhereInput
    orderBy?: EventTypeOrderByWithAggregationInput | EventTypeOrderByWithAggregationInput[]
    by: EventTypeScalarFieldEnum[] | EventTypeScalarFieldEnum
    having?: EventTypeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventTypeCountAggregateInputType | true
    _avg?: EventTypeAvgAggregateInputType
    _sum?: EventTypeSumAggregateInputType
    _min?: EventTypeMinAggregateInputType
    _max?: EventTypeMaxAggregateInputType
  }

  export type EventTypeGroupByOutputType = {
    id: string
    categoryId: string
    name: string
    slug: string
    description: string | null
    defaultDurationHours: number | null
    createdAt: Date
    _count: EventTypeCountAggregateOutputType | null
    _avg: EventTypeAvgAggregateOutputType | null
    _sum: EventTypeSumAggregateOutputType | null
    _min: EventTypeMinAggregateOutputType | null
    _max: EventTypeMaxAggregateOutputType | null
  }

  type GetEventTypeGroupByPayload<T extends EventTypeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventTypeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventTypeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventTypeGroupByOutputType[P]>
            : GetScalarType<T[P], EventTypeGroupByOutputType[P]>
        }
      >
    >


  export type EventTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    categoryId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    defaultDurationHours?: boolean
    createdAt?: boolean
    category?: boolean | EventCategoryDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventType"]>


  export type EventTypeSelectScalar = {
    id?: boolean
    categoryId?: boolean
    name?: boolean
    slug?: boolean
    description?: boolean
    defaultDurationHours?: boolean
    createdAt?: boolean
  }

  export type EventTypeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | EventCategoryDefaultArgs<ExtArgs>
  }

  export type $EventTypePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventType"
    objects: {
      category: Prisma.$EventCategoryPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      categoryId: string
      name: string
      slug: string
      description: string | null
      defaultDurationHours: number | null
      createdAt: Date
    }, ExtArgs["result"]["eventType"]>
    composites: {}
  }

  type EventTypeGetPayload<S extends boolean | null | undefined | EventTypeDefaultArgs> = $Result.GetResult<Prisma.$EventTypePayload, S>

  type EventTypeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventTypeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventTypeCountAggregateInputType | true
    }

  export interface EventTypeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventType'], meta: { name: 'EventType' } }
    /**
     * Find zero or one EventType that matches the filter.
     * @param {EventTypeFindUniqueArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventTypeFindUniqueArgs>(args: SelectSubset<T, EventTypeFindUniqueArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventType that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventTypeFindUniqueOrThrowArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventTypeFindUniqueOrThrowArgs>(args: SelectSubset<T, EventTypeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventType that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeFindFirstArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventTypeFindFirstArgs>(args?: SelectSubset<T, EventTypeFindFirstArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventType that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeFindFirstOrThrowArgs} args - Arguments to find a EventType
     * @example
     * // Get one EventType
     * const eventType = await prisma.eventType.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventTypeFindFirstOrThrowArgs>(args?: SelectSubset<T, EventTypeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventTypes that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventTypes
     * const eventTypes = await prisma.eventType.findMany()
     * 
     * // Get first 10 EventTypes
     * const eventTypes = await prisma.eventType.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventTypeWithIdOnly = await prisma.eventType.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventTypeFindManyArgs>(args?: SelectSubset<T, EventTypeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventType.
     * @param {EventTypeCreateArgs} args - Arguments to create a EventType.
     * @example
     * // Create one EventType
     * const EventType = await prisma.eventType.create({
     *   data: {
     *     // ... data to create a EventType
     *   }
     * })
     * 
     */
    create<T extends EventTypeCreateArgs>(args: SelectSubset<T, EventTypeCreateArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventTypes.
     * @param {EventTypeCreateManyArgs} args - Arguments to create many EventTypes.
     * @example
     * // Create many EventTypes
     * const eventType = await prisma.eventType.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventTypeCreateManyArgs>(args?: SelectSubset<T, EventTypeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventType.
     * @param {EventTypeDeleteArgs} args - Arguments to delete one EventType.
     * @example
     * // Delete one EventType
     * const EventType = await prisma.eventType.delete({
     *   where: {
     *     // ... filter to delete one EventType
     *   }
     * })
     * 
     */
    delete<T extends EventTypeDeleteArgs>(args: SelectSubset<T, EventTypeDeleteArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventType.
     * @param {EventTypeUpdateArgs} args - Arguments to update one EventType.
     * @example
     * // Update one EventType
     * const eventType = await prisma.eventType.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventTypeUpdateArgs>(args: SelectSubset<T, EventTypeUpdateArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventTypes.
     * @param {EventTypeDeleteManyArgs} args - Arguments to filter EventTypes to delete.
     * @example
     * // Delete a few EventTypes
     * const { count } = await prisma.eventType.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventTypeDeleteManyArgs>(args?: SelectSubset<T, EventTypeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventTypes
     * const eventType = await prisma.eventType.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventTypeUpdateManyArgs>(args: SelectSubset<T, EventTypeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventType.
     * @param {EventTypeUpsertArgs} args - Arguments to update or create a EventType.
     * @example
     * // Update or create a EventType
     * const eventType = await prisma.eventType.upsert({
     *   create: {
     *     // ... data to create a EventType
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventType we want to update
     *   }
     * })
     */
    upsert<T extends EventTypeUpsertArgs>(args: SelectSubset<T, EventTypeUpsertArgs<ExtArgs>>): Prisma__EventTypeClient<$Result.GetResult<Prisma.$EventTypePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventTypes.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeCountArgs} args - Arguments to filter EventTypes to count.
     * @example
     * // Count the number of EventTypes
     * const count = await prisma.eventType.count({
     *   where: {
     *     // ... the filter for the EventTypes we want to count
     *   }
     * })
    **/
    count<T extends EventTypeCountArgs>(
      args?: Subset<T, EventTypeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventTypeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventTypeAggregateArgs>(args: Subset<T, EventTypeAggregateArgs>): Prisma.PrismaPromise<GetEventTypeAggregateType<T>>

    /**
     * Group by EventType.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventTypeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventTypeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventTypeGroupByArgs['orderBy'] }
        : { orderBy?: EventTypeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventTypeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventTypeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventType model
   */
  readonly fields: EventTypeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventType.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventTypeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends EventCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventCategoryDefaultArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventType model
   */ 
  interface EventTypeFieldRefs {
    readonly id: FieldRef<"EventType", 'String'>
    readonly categoryId: FieldRef<"EventType", 'String'>
    readonly name: FieldRef<"EventType", 'String'>
    readonly slug: FieldRef<"EventType", 'String'>
    readonly description: FieldRef<"EventType", 'String'>
    readonly defaultDurationHours: FieldRef<"EventType", 'Int'>
    readonly createdAt: FieldRef<"EventType", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventType findUnique
   */
  export type EventTypeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType findUniqueOrThrow
   */
  export type EventTypeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType findFirst
   */
  export type EventTypeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTypes.
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTypes.
     */
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventType findFirstOrThrow
   */
  export type EventTypeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventType to fetch.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventTypes.
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventTypes.
     */
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventType findMany
   */
  export type EventTypeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter, which EventTypes to fetch.
     */
    where?: EventTypeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventTypes to fetch.
     */
    orderBy?: EventTypeOrderByWithRelationInput | EventTypeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventTypes.
     */
    cursor?: EventTypeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventTypes from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventTypes.
     */
    skip?: number
    distinct?: EventTypeScalarFieldEnum | EventTypeScalarFieldEnum[]
  }

  /**
   * EventType create
   */
  export type EventTypeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * The data needed to create a EventType.
     */
    data: XOR<EventTypeCreateInput, EventTypeUncheckedCreateInput>
  }

  /**
   * EventType createMany
   */
  export type EventTypeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventTypes.
     */
    data: EventTypeCreateManyInput | EventTypeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventType update
   */
  export type EventTypeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * The data needed to update a EventType.
     */
    data: XOR<EventTypeUpdateInput, EventTypeUncheckedUpdateInput>
    /**
     * Choose, which EventType to update.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType updateMany
   */
  export type EventTypeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventTypes.
     */
    data: XOR<EventTypeUpdateManyMutationInput, EventTypeUncheckedUpdateManyInput>
    /**
     * Filter which EventTypes to update
     */
    where?: EventTypeWhereInput
  }

  /**
   * EventType upsert
   */
  export type EventTypeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * The filter to search for the EventType to update in case it exists.
     */
    where: EventTypeWhereUniqueInput
    /**
     * In case the EventType found by the `where` argument doesn't exist, create a new EventType with this data.
     */
    create: XOR<EventTypeCreateInput, EventTypeUncheckedCreateInput>
    /**
     * In case the EventType was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventTypeUpdateInput, EventTypeUncheckedUpdateInput>
  }

  /**
   * EventType delete
   */
  export type EventTypeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
    /**
     * Filter which EventType to delete.
     */
    where: EventTypeWhereUniqueInput
  }

  /**
   * EventType deleteMany
   */
  export type EventTypeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventTypes to delete
     */
    where?: EventTypeWhereInput
  }

  /**
   * EventType without action
   */
  export type EventTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventType
     */
    select?: EventTypeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventTypeInclude<ExtArgs> | null
  }


  /**
   * Model Event
   */

  export type AggregateEvent = {
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  export type EventAvgAggregateOutputType = {
    maxParticipants: number | null
    minTeamSize: number | null
    maxTeamSize: number | null
    registrationFee: Decimal | null
    problemCount: number | null
  }

  export type EventSumAggregateOutputType = {
    maxParticipants: number | null
    minTeamSize: number | null
    maxTeamSize: number | null
    registrationFee: Decimal | null
    problemCount: number | null
  }

  export type EventMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    categoryId: string | null
    eventType: string | null
    mode: string | null
    registrationStart: Date | null
    registrationEnd: Date | null
    maxParticipants: number | null
    isTeamEvent: boolean | null
    allowIndividual: boolean | null
    minTeamSize: number | null
    maxTeamSize: number | null
    teamFormationDeadline: Date | null
    restrictSameCollege: boolean | null
    eventStart: Date | null
    eventEnd: Date | null
    isPaid: boolean | null
    registrationFee: Decimal | null
    currency: string | null
    hasSubmission: boolean | null
    submissionStart: Date | null
    submissionDeadline: Date | null
    submissionTemplateUrl: string | null
    rules: string | null
    eligibility: string | null
    rewards: string | null
    venue: string | null
    meetingLink: string | null
    bannerImage: string | null
    status: string | null
    isFeatured: boolean | null
    hasRoadmap: boolean | null
    roadmapId: string | null
    hasChallenges: boolean | null
    problemCount: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    categoryId: string | null
    eventType: string | null
    mode: string | null
    registrationStart: Date | null
    registrationEnd: Date | null
    maxParticipants: number | null
    isTeamEvent: boolean | null
    allowIndividual: boolean | null
    minTeamSize: number | null
    maxTeamSize: number | null
    teamFormationDeadline: Date | null
    restrictSameCollege: boolean | null
    eventStart: Date | null
    eventEnd: Date | null
    isPaid: boolean | null
    registrationFee: Decimal | null
    currency: string | null
    hasSubmission: boolean | null
    submissionStart: Date | null
    submissionDeadline: Date | null
    submissionTemplateUrl: string | null
    rules: string | null
    eligibility: string | null
    rewards: string | null
    venue: string | null
    meetingLink: string | null
    bannerImage: string | null
    status: string | null
    isFeatured: boolean | null
    hasRoadmap: boolean | null
    roadmapId: string | null
    hasChallenges: boolean | null
    problemCount: number | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EventCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    categoryId: number
    eventType: number
    mode: number
    registrationStart: number
    registrationEnd: number
    maxParticipants: number
    isTeamEvent: number
    allowIndividual: number
    minTeamSize: number
    maxTeamSize: number
    teamFormationDeadline: number
    restrictSameCollege: number
    eventStart: number
    eventEnd: number
    isPaid: number
    registrationFee: number
    currency: number
    hasSubmission: number
    submissionStart: number
    submissionDeadline: number
    submissionTemplateUrl: number
    rules: number
    eligibility: number
    rewards: number
    prizes: number
    venue: number
    meetingLink: number
    resourceLinks: number
    bannerImage: number
    images: number
    status: number
    isFeatured: number
    hasRoadmap: number
    roadmapId: number
    hasChallenges: number
    problemCount: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EventAvgAggregateInputType = {
    maxParticipants?: true
    minTeamSize?: true
    maxTeamSize?: true
    registrationFee?: true
    problemCount?: true
  }

  export type EventSumAggregateInputType = {
    maxParticipants?: true
    minTeamSize?: true
    maxTeamSize?: true
    registrationFee?: true
    problemCount?: true
  }

  export type EventMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    categoryId?: true
    eventType?: true
    mode?: true
    registrationStart?: true
    registrationEnd?: true
    maxParticipants?: true
    isTeamEvent?: true
    allowIndividual?: true
    minTeamSize?: true
    maxTeamSize?: true
    teamFormationDeadline?: true
    restrictSameCollege?: true
    eventStart?: true
    eventEnd?: true
    isPaid?: true
    registrationFee?: true
    currency?: true
    hasSubmission?: true
    submissionStart?: true
    submissionDeadline?: true
    submissionTemplateUrl?: true
    rules?: true
    eligibility?: true
    rewards?: true
    venue?: true
    meetingLink?: true
    bannerImage?: true
    status?: true
    isFeatured?: true
    hasRoadmap?: true
    roadmapId?: true
    hasChallenges?: true
    problemCount?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    categoryId?: true
    eventType?: true
    mode?: true
    registrationStart?: true
    registrationEnd?: true
    maxParticipants?: true
    isTeamEvent?: true
    allowIndividual?: true
    minTeamSize?: true
    maxTeamSize?: true
    teamFormationDeadline?: true
    restrictSameCollege?: true
    eventStart?: true
    eventEnd?: true
    isPaid?: true
    registrationFee?: true
    currency?: true
    hasSubmission?: true
    submissionStart?: true
    submissionDeadline?: true
    submissionTemplateUrl?: true
    rules?: true
    eligibility?: true
    rewards?: true
    venue?: true
    meetingLink?: true
    bannerImage?: true
    status?: true
    isFeatured?: true
    hasRoadmap?: true
    roadmapId?: true
    hasChallenges?: true
    problemCount?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EventCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    categoryId?: true
    eventType?: true
    mode?: true
    registrationStart?: true
    registrationEnd?: true
    maxParticipants?: true
    isTeamEvent?: true
    allowIndividual?: true
    minTeamSize?: true
    maxTeamSize?: true
    teamFormationDeadline?: true
    restrictSameCollege?: true
    eventStart?: true
    eventEnd?: true
    isPaid?: true
    registrationFee?: true
    currency?: true
    hasSubmission?: true
    submissionStart?: true
    submissionDeadline?: true
    submissionTemplateUrl?: true
    rules?: true
    eligibility?: true
    rewards?: true
    prizes?: true
    venue?: true
    meetingLink?: true
    resourceLinks?: true
    bannerImage?: true
    images?: true
    status?: true
    isFeatured?: true
    hasRoadmap?: true
    roadmapId?: true
    hasChallenges?: true
    problemCount?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EventAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Event to aggregate.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Events
    **/
    _count?: true | EventCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventMaxAggregateInputType
  }

  export type GetEventAggregateType<T extends EventAggregateArgs> = {
        [P in keyof T & keyof AggregateEvent]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEvent[P]>
      : GetScalarType<T[P], AggregateEvent[P]>
  }




  export type EventGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventWhereInput
    orderBy?: EventOrderByWithAggregationInput | EventOrderByWithAggregationInput[]
    by: EventScalarFieldEnum[] | EventScalarFieldEnum
    having?: EventScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventCountAggregateInputType | true
    _avg?: EventAvgAggregateInputType
    _sum?: EventSumAggregateInputType
    _min?: EventMinAggregateInputType
    _max?: EventMaxAggregateInputType
  }

  export type EventGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date
    registrationEnd: Date
    maxParticipants: number | null
    isTeamEvent: boolean
    allowIndividual: boolean
    minTeamSize: number
    maxTeamSize: number
    teamFormationDeadline: Date | null
    restrictSameCollege: boolean
    eventStart: Date
    eventEnd: Date
    isPaid: boolean
    registrationFee: Decimal | null
    currency: string
    hasSubmission: boolean
    submissionStart: Date | null
    submissionDeadline: Date | null
    submissionTemplateUrl: string | null
    rules: string | null
    eligibility: string | null
    rewards: string | null
    prizes: JsonValue | null
    venue: string | null
    meetingLink: string | null
    resourceLinks: JsonValue | null
    bannerImage: string | null
    images: JsonValue | null
    status: string
    isFeatured: boolean
    hasRoadmap: boolean
    roadmapId: string | null
    hasChallenges: boolean
    problemCount: number
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: EventCountAggregateOutputType | null
    _avg: EventAvgAggregateOutputType | null
    _sum: EventSumAggregateOutputType | null
    _min: EventMinAggregateOutputType | null
    _max: EventMaxAggregateOutputType | null
  }

  type GetEventGroupByPayload<T extends EventGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventGroupByOutputType[P]>
            : GetScalarType<T[P], EventGroupByOutputType[P]>
        }
      >
    >


  export type EventSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    categoryId?: boolean
    eventType?: boolean
    mode?: boolean
    registrationStart?: boolean
    registrationEnd?: boolean
    maxParticipants?: boolean
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: boolean
    maxTeamSize?: boolean
    teamFormationDeadline?: boolean
    restrictSameCollege?: boolean
    eventStart?: boolean
    eventEnd?: boolean
    isPaid?: boolean
    registrationFee?: boolean
    currency?: boolean
    hasSubmission?: boolean
    submissionStart?: boolean
    submissionDeadline?: boolean
    submissionTemplateUrl?: boolean
    rules?: boolean
    eligibility?: boolean
    rewards?: boolean
    prizes?: boolean
    venue?: boolean
    meetingLink?: boolean
    resourceLinks?: boolean
    bannerImage?: boolean
    images?: boolean
    status?: boolean
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: boolean
    hasChallenges?: boolean
    problemCount?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | EventCategoryDefaultArgs<ExtArgs>
    creator?: boolean | Event$creatorArgs<ExtArgs>
    roadmap?: boolean | Event$roadmapArgs<ExtArgs>
    registrations?: boolean | Event$registrationsArgs<ExtArgs>
    teams?: boolean | Event$teamsArgs<ExtArgs>
    submissions?: boolean | Event$submissionsArgs<ExtArgs>
    eventChallenges?: boolean | Event$eventChallengesArgs<ExtArgs>
    emailLogs?: boolean | Event$emailLogsArgs<ExtArgs>
    certificates?: boolean | Event$certificatesArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["event"]>


  export type EventSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    categoryId?: boolean
    eventType?: boolean
    mode?: boolean
    registrationStart?: boolean
    registrationEnd?: boolean
    maxParticipants?: boolean
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: boolean
    maxTeamSize?: boolean
    teamFormationDeadline?: boolean
    restrictSameCollege?: boolean
    eventStart?: boolean
    eventEnd?: boolean
    isPaid?: boolean
    registrationFee?: boolean
    currency?: boolean
    hasSubmission?: boolean
    submissionStart?: boolean
    submissionDeadline?: boolean
    submissionTemplateUrl?: boolean
    rules?: boolean
    eligibility?: boolean
    rewards?: boolean
    prizes?: boolean
    venue?: boolean
    meetingLink?: boolean
    resourceLinks?: boolean
    bannerImage?: boolean
    images?: boolean
    status?: boolean
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: boolean
    hasChallenges?: boolean
    problemCount?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EventInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | EventCategoryDefaultArgs<ExtArgs>
    creator?: boolean | Event$creatorArgs<ExtArgs>
    roadmap?: boolean | Event$roadmapArgs<ExtArgs>
    registrations?: boolean | Event$registrationsArgs<ExtArgs>
    teams?: boolean | Event$teamsArgs<ExtArgs>
    submissions?: boolean | Event$submissionsArgs<ExtArgs>
    eventChallenges?: boolean | Event$eventChallengesArgs<ExtArgs>
    emailLogs?: boolean | Event$emailLogsArgs<ExtArgs>
    certificates?: boolean | Event$certificatesArgs<ExtArgs>
    _count?: boolean | EventCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $EventPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Event"
    objects: {
      category: Prisma.$EventCategoryPayload<ExtArgs>
      creator: Prisma.$UserPayload<ExtArgs> | null
      roadmap: Prisma.$RoadmapPayload<ExtArgs> | null
      registrations: Prisma.$EventRegistrationPayload<ExtArgs>[]
      teams: Prisma.$TeamPayload<ExtArgs>[]
      submissions: Prisma.$EventSubmissionPayload<ExtArgs>[]
      eventChallenges: Prisma.$EventChallengePayload<ExtArgs>[]
      emailLogs: Prisma.$EmailLogPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string
      categoryId: string
      eventType: string
      mode: string
      registrationStart: Date
      registrationEnd: Date
      maxParticipants: number | null
      isTeamEvent: boolean
      allowIndividual: boolean
      minTeamSize: number
      maxTeamSize: number
      teamFormationDeadline: Date | null
      restrictSameCollege: boolean
      eventStart: Date
      eventEnd: Date
      isPaid: boolean
      registrationFee: Prisma.Decimal | null
      currency: string
      hasSubmission: boolean
      submissionStart: Date | null
      submissionDeadline: Date | null
      submissionTemplateUrl: string | null
      rules: string | null
      eligibility: string | null
      rewards: string | null
      prizes: Prisma.JsonValue | null
      venue: string | null
      meetingLink: string | null
      resourceLinks: Prisma.JsonValue | null
      bannerImage: string | null
      images: Prisma.JsonValue | null
      status: string
      isFeatured: boolean
      hasRoadmap: boolean
      roadmapId: string | null
      hasChallenges: boolean
      problemCount: number
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["event"]>
    composites: {}
  }

  type EventGetPayload<S extends boolean | null | undefined | EventDefaultArgs> = $Result.GetResult<Prisma.$EventPayload, S>

  type EventCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventCountAggregateInputType | true
    }

  export interface EventDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Event'], meta: { name: 'Event' } }
    /**
     * Find zero or one Event that matches the filter.
     * @param {EventFindUniqueArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventFindUniqueArgs>(args: SelectSubset<T, EventFindUniqueArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Event that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventFindUniqueOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventFindUniqueOrThrowArgs>(args: SelectSubset<T, EventFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Event that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventFindFirstArgs>(args?: SelectSubset<T, EventFindFirstArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Event that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindFirstOrThrowArgs} args - Arguments to find a Event
     * @example
     * // Get one Event
     * const event = await prisma.event.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventFindFirstOrThrowArgs>(args?: SelectSubset<T, EventFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Events that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Events
     * const events = await prisma.event.findMany()
     * 
     * // Get first 10 Events
     * const events = await prisma.event.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventWithIdOnly = await prisma.event.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventFindManyArgs>(args?: SelectSubset<T, EventFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Event.
     * @param {EventCreateArgs} args - Arguments to create a Event.
     * @example
     * // Create one Event
     * const Event = await prisma.event.create({
     *   data: {
     *     // ... data to create a Event
     *   }
     * })
     * 
     */
    create<T extends EventCreateArgs>(args: SelectSubset<T, EventCreateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Events.
     * @param {EventCreateManyArgs} args - Arguments to create many Events.
     * @example
     * // Create many Events
     * const event = await prisma.event.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventCreateManyArgs>(args?: SelectSubset<T, EventCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Event.
     * @param {EventDeleteArgs} args - Arguments to delete one Event.
     * @example
     * // Delete one Event
     * const Event = await prisma.event.delete({
     *   where: {
     *     // ... filter to delete one Event
     *   }
     * })
     * 
     */
    delete<T extends EventDeleteArgs>(args: SelectSubset<T, EventDeleteArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Event.
     * @param {EventUpdateArgs} args - Arguments to update one Event.
     * @example
     * // Update one Event
     * const event = await prisma.event.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventUpdateArgs>(args: SelectSubset<T, EventUpdateArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Events.
     * @param {EventDeleteManyArgs} args - Arguments to filter Events to delete.
     * @example
     * // Delete a few Events
     * const { count } = await prisma.event.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventDeleteManyArgs>(args?: SelectSubset<T, EventDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Events
     * const event = await prisma.event.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventUpdateManyArgs>(args: SelectSubset<T, EventUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Event.
     * @param {EventUpsertArgs} args - Arguments to update or create a Event.
     * @example
     * // Update or create a Event
     * const event = await prisma.event.upsert({
     *   create: {
     *     // ... data to create a Event
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Event we want to update
     *   }
     * })
     */
    upsert<T extends EventUpsertArgs>(args: SelectSubset<T, EventUpsertArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Events.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventCountArgs} args - Arguments to filter Events to count.
     * @example
     * // Count the number of Events
     * const count = await prisma.event.count({
     *   where: {
     *     // ... the filter for the Events we want to count
     *   }
     * })
    **/
    count<T extends EventCountArgs>(
      args?: Subset<T, EventCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventAggregateArgs>(args: Subset<T, EventAggregateArgs>): Prisma.PrismaPromise<GetEventAggregateType<T>>

    /**
     * Group by Event.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventGroupByArgs['orderBy'] }
        : { orderBy?: EventGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Event model
   */
  readonly fields: EventFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Event.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends EventCategoryDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventCategoryDefaultArgs<ExtArgs>>): Prisma__EventCategoryClient<$Result.GetResult<Prisma.$EventCategoryPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    creator<T extends Event$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Event$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    roadmap<T extends Event$roadmapArgs<ExtArgs> = {}>(args?: Subset<T, Event$roadmapArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    registrations<T extends Event$registrationsArgs<ExtArgs> = {}>(args?: Subset<T, Event$registrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findMany"> | Null>
    teams<T extends Event$teamsArgs<ExtArgs> = {}>(args?: Subset<T, Event$teamsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany"> | Null>
    submissions<T extends Event$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Event$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventSubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    eventChallenges<T extends Event$eventChallengesArgs<ExtArgs> = {}>(args?: Subset<T, Event$eventChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventChallengePayload<ExtArgs>, T, "findMany"> | Null>
    emailLogs<T extends Event$emailLogsArgs<ExtArgs> = {}>(args?: Subset<T, Event$emailLogsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany"> | Null>
    certificates<T extends Event$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Event$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Event model
   */ 
  interface EventFieldRefs {
    readonly id: FieldRef<"Event", 'String'>
    readonly title: FieldRef<"Event", 'String'>
    readonly slug: FieldRef<"Event", 'String'>
    readonly description: FieldRef<"Event", 'String'>
    readonly categoryId: FieldRef<"Event", 'String'>
    readonly eventType: FieldRef<"Event", 'String'>
    readonly mode: FieldRef<"Event", 'String'>
    readonly registrationStart: FieldRef<"Event", 'DateTime'>
    readonly registrationEnd: FieldRef<"Event", 'DateTime'>
    readonly maxParticipants: FieldRef<"Event", 'Int'>
    readonly isTeamEvent: FieldRef<"Event", 'Boolean'>
    readonly allowIndividual: FieldRef<"Event", 'Boolean'>
    readonly minTeamSize: FieldRef<"Event", 'Int'>
    readonly maxTeamSize: FieldRef<"Event", 'Int'>
    readonly teamFormationDeadline: FieldRef<"Event", 'DateTime'>
    readonly restrictSameCollege: FieldRef<"Event", 'Boolean'>
    readonly eventStart: FieldRef<"Event", 'DateTime'>
    readonly eventEnd: FieldRef<"Event", 'DateTime'>
    readonly isPaid: FieldRef<"Event", 'Boolean'>
    readonly registrationFee: FieldRef<"Event", 'Decimal'>
    readonly currency: FieldRef<"Event", 'String'>
    readonly hasSubmission: FieldRef<"Event", 'Boolean'>
    readonly submissionStart: FieldRef<"Event", 'DateTime'>
    readonly submissionDeadline: FieldRef<"Event", 'DateTime'>
    readonly submissionTemplateUrl: FieldRef<"Event", 'String'>
    readonly rules: FieldRef<"Event", 'String'>
    readonly eligibility: FieldRef<"Event", 'String'>
    readonly rewards: FieldRef<"Event", 'String'>
    readonly prizes: FieldRef<"Event", 'Json'>
    readonly venue: FieldRef<"Event", 'String'>
    readonly meetingLink: FieldRef<"Event", 'String'>
    readonly resourceLinks: FieldRef<"Event", 'Json'>
    readonly bannerImage: FieldRef<"Event", 'String'>
    readonly images: FieldRef<"Event", 'Json'>
    readonly status: FieldRef<"Event", 'String'>
    readonly isFeatured: FieldRef<"Event", 'Boolean'>
    readonly hasRoadmap: FieldRef<"Event", 'Boolean'>
    readonly roadmapId: FieldRef<"Event", 'String'>
    readonly hasChallenges: FieldRef<"Event", 'Boolean'>
    readonly problemCount: FieldRef<"Event", 'Int'>
    readonly createdBy: FieldRef<"Event", 'String'>
    readonly createdAt: FieldRef<"Event", 'DateTime'>
    readonly updatedAt: FieldRef<"Event", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Event findUnique
   */
  export type EventFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findUniqueOrThrow
   */
  export type EventFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event findFirst
   */
  export type EventFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findFirstOrThrow
   */
  export type EventFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Event to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Events.
     */
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event findMany
   */
  export type EventFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter, which Events to fetch.
     */
    where?: EventWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Events to fetch.
     */
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Events.
     */
    cursor?: EventWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Events from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Events.
     */
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Event create
   */
  export type EventCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to create a Event.
     */
    data: XOR<EventCreateInput, EventUncheckedCreateInput>
  }

  /**
   * Event createMany
   */
  export type EventCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Events.
     */
    data: EventCreateManyInput | EventCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Event update
   */
  export type EventUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The data needed to update a Event.
     */
    data: XOR<EventUpdateInput, EventUncheckedUpdateInput>
    /**
     * Choose, which Event to update.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event updateMany
   */
  export type EventUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Events.
     */
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyInput>
    /**
     * Filter which Events to update
     */
    where?: EventWhereInput
  }

  /**
   * Event upsert
   */
  export type EventUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * The filter to search for the Event to update in case it exists.
     */
    where: EventWhereUniqueInput
    /**
     * In case the Event found by the `where` argument doesn't exist, create a new Event with this data.
     */
    create: XOR<EventCreateInput, EventUncheckedCreateInput>
    /**
     * In case the Event was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventUpdateInput, EventUncheckedUpdateInput>
  }

  /**
   * Event delete
   */
  export type EventDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    /**
     * Filter which Event to delete.
     */
    where: EventWhereUniqueInput
  }

  /**
   * Event deleteMany
   */
  export type EventDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Events to delete
     */
    where?: EventWhereInput
  }

  /**
   * Event.creator
   */
  export type Event$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Event.roadmap
   */
  export type Event$roadmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    where?: RoadmapWhereInput
  }

  /**
   * Event.registrations
   */
  export type Event$registrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    where?: EventRegistrationWhereInput
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    cursor?: EventRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * Event.teams
   */
  export type Event$teamsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    cursor?: TeamWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Event.submissions
   */
  export type Event$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
    where?: EventSubmissionWhereInput
    orderBy?: EventSubmissionOrderByWithRelationInput | EventSubmissionOrderByWithRelationInput[]
    cursor?: EventSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventSubmissionScalarFieldEnum | EventSubmissionScalarFieldEnum[]
  }

  /**
   * Event.eventChallenges
   */
  export type Event$eventChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventChallenge
     */
    select?: EventChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventChallengeInclude<ExtArgs> | null
    where?: EventChallengeWhereInput
    orderBy?: EventChallengeOrderByWithRelationInput | EventChallengeOrderByWithRelationInput[]
    cursor?: EventChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventChallengeScalarFieldEnum | EventChallengeScalarFieldEnum[]
  }

  /**
   * Event.emailLogs
   */
  export type Event$emailLogsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    cursor?: EmailLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * Event.certificates
   */
  export type Event$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Event without action
   */
  export type EventDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
  }


  /**
   * Model Team
   */

  export type AggregateTeam = {
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  export type TeamMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    teamName: string | null
    teamLeaderId: string | null
    isComplete: boolean | null
    isLocked: boolean | null
    collegeName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    teamName: string | null
    teamLeaderId: string | null
    isComplete: boolean | null
    isLocked: boolean | null
    collegeName: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TeamCountAggregateOutputType = {
    id: number
    eventId: number
    teamName: number
    teamLeaderId: number
    isComplete: number
    isLocked: number
    collegeName: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TeamMinAggregateInputType = {
    id?: true
    eventId?: true
    teamName?: true
    teamLeaderId?: true
    isComplete?: true
    isLocked?: true
    collegeName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamMaxAggregateInputType = {
    id?: true
    eventId?: true
    teamName?: true
    teamLeaderId?: true
    isComplete?: true
    isLocked?: true
    collegeName?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TeamCountAggregateInputType = {
    id?: true
    eventId?: true
    teamName?: true
    teamLeaderId?: true
    isComplete?: true
    isLocked?: true
    collegeName?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TeamAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Team to aggregate.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Teams
    **/
    _count?: true | TeamCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMaxAggregateInputType
  }

  export type GetTeamAggregateType<T extends TeamAggregateArgs> = {
        [P in keyof T & keyof AggregateTeam]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeam[P]>
      : GetScalarType<T[P], AggregateTeam[P]>
  }




  export type TeamGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamWhereInput
    orderBy?: TeamOrderByWithAggregationInput | TeamOrderByWithAggregationInput[]
    by: TeamScalarFieldEnum[] | TeamScalarFieldEnum
    having?: TeamScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamCountAggregateInputType | true
    _min?: TeamMinAggregateInputType
    _max?: TeamMaxAggregateInputType
  }

  export type TeamGroupByOutputType = {
    id: string
    eventId: string
    teamName: string
    teamLeaderId: string
    isComplete: boolean
    isLocked: boolean
    collegeName: string | null
    createdAt: Date
    updatedAt: Date
    _count: TeamCountAggregateOutputType | null
    _min: TeamMinAggregateOutputType | null
    _max: TeamMaxAggregateOutputType | null
  }

  type GetTeamGroupByPayload<T extends TeamGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamGroupByOutputType[P]>
            : GetScalarType<T[P], TeamGroupByOutputType[P]>
        }
      >
    >


  export type TeamSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    teamName?: boolean
    teamLeaderId?: boolean
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    leader?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    joinRequests?: boolean | Team$joinRequestsArgs<ExtArgs>
    registrations?: boolean | Team$registrationsArgs<ExtArgs>
    submissions?: boolean | Team$submissionsArgs<ExtArgs>
    certificates?: boolean | Team$certificatesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["team"]>


  export type TeamSelectScalar = {
    id?: boolean
    eventId?: boolean
    teamName?: boolean
    teamLeaderId?: boolean
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TeamInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    leader?: boolean | UserDefaultArgs<ExtArgs>
    members?: boolean | Team$membersArgs<ExtArgs>
    joinRequests?: boolean | Team$joinRequestsArgs<ExtArgs>
    registrations?: boolean | Team$registrationsArgs<ExtArgs>
    submissions?: boolean | Team$submissionsArgs<ExtArgs>
    certificates?: boolean | Team$certificatesArgs<ExtArgs>
    _count?: boolean | TeamCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $TeamPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Team"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      leader: Prisma.$UserPayload<ExtArgs>
      members: Prisma.$TeamMemberPayload<ExtArgs>[]
      joinRequests: Prisma.$TeamJoinRequestPayload<ExtArgs>[]
      registrations: Prisma.$EventRegistrationPayload<ExtArgs>[]
      submissions: Prisma.$EventSubmissionPayload<ExtArgs>[]
      certificates: Prisma.$CertificatePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      teamName: string
      teamLeaderId: string
      isComplete: boolean
      isLocked: boolean
      collegeName: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["team"]>
    composites: {}
  }

  type TeamGetPayload<S extends boolean | null | undefined | TeamDefaultArgs> = $Result.GetResult<Prisma.$TeamPayload, S>

  type TeamCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamCountAggregateInputType | true
    }

  export interface TeamDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Team'], meta: { name: 'Team' } }
    /**
     * Find zero or one Team that matches the filter.
     * @param {TeamFindUniqueArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamFindUniqueArgs>(args: SelectSubset<T, TeamFindUniqueArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Team that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamFindUniqueOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Team that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamFindFirstArgs>(args?: SelectSubset<T, TeamFindFirstArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Team that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindFirstOrThrowArgs} args - Arguments to find a Team
     * @example
     * // Get one Team
     * const team = await prisma.team.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Teams that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Teams
     * const teams = await prisma.team.findMany()
     * 
     * // Get first 10 Teams
     * const teams = await prisma.team.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamWithIdOnly = await prisma.team.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamFindManyArgs>(args?: SelectSubset<T, TeamFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Team.
     * @param {TeamCreateArgs} args - Arguments to create a Team.
     * @example
     * // Create one Team
     * const Team = await prisma.team.create({
     *   data: {
     *     // ... data to create a Team
     *   }
     * })
     * 
     */
    create<T extends TeamCreateArgs>(args: SelectSubset<T, TeamCreateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Teams.
     * @param {TeamCreateManyArgs} args - Arguments to create many Teams.
     * @example
     * // Create many Teams
     * const team = await prisma.team.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamCreateManyArgs>(args?: SelectSubset<T, TeamCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Team.
     * @param {TeamDeleteArgs} args - Arguments to delete one Team.
     * @example
     * // Delete one Team
     * const Team = await prisma.team.delete({
     *   where: {
     *     // ... filter to delete one Team
     *   }
     * })
     * 
     */
    delete<T extends TeamDeleteArgs>(args: SelectSubset<T, TeamDeleteArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Team.
     * @param {TeamUpdateArgs} args - Arguments to update one Team.
     * @example
     * // Update one Team
     * const team = await prisma.team.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamUpdateArgs>(args: SelectSubset<T, TeamUpdateArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Teams.
     * @param {TeamDeleteManyArgs} args - Arguments to filter Teams to delete.
     * @example
     * // Delete a few Teams
     * const { count } = await prisma.team.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamDeleteManyArgs>(args?: SelectSubset<T, TeamDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Teams
     * const team = await prisma.team.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamUpdateManyArgs>(args: SelectSubset<T, TeamUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Team.
     * @param {TeamUpsertArgs} args - Arguments to update or create a Team.
     * @example
     * // Update or create a Team
     * const team = await prisma.team.upsert({
     *   create: {
     *     // ... data to create a Team
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Team we want to update
     *   }
     * })
     */
    upsert<T extends TeamUpsertArgs>(args: SelectSubset<T, TeamUpsertArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Teams.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamCountArgs} args - Arguments to filter Teams to count.
     * @example
     * // Count the number of Teams
     * const count = await prisma.team.count({
     *   where: {
     *     // ... the filter for the Teams we want to count
     *   }
     * })
    **/
    count<T extends TeamCountArgs>(
      args?: Subset<T, TeamCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamAggregateArgs>(args: Subset<T, TeamAggregateArgs>): Prisma.PrismaPromise<GetTeamAggregateType<T>>

    /**
     * Group by Team.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamGroupByArgs['orderBy'] }
        : { orderBy?: TeamGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Team model
   */
  readonly fields: TeamFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Team.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    leader<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    members<T extends Team$membersArgs<ExtArgs> = {}>(args?: Subset<T, Team$membersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany"> | Null>
    joinRequests<T extends Team$joinRequestsArgs<ExtArgs> = {}>(args?: Subset<T, Team$joinRequestsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamJoinRequestPayload<ExtArgs>, T, "findMany"> | Null>
    registrations<T extends Team$registrationsArgs<ExtArgs> = {}>(args?: Subset<T, Team$registrationsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findMany"> | Null>
    submissions<T extends Team$submissionsArgs<ExtArgs> = {}>(args?: Subset<T, Team$submissionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventSubmissionPayload<ExtArgs>, T, "findMany"> | Null>
    certificates<T extends Team$certificatesArgs<ExtArgs> = {}>(args?: Subset<T, Team$certificatesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Team model
   */ 
  interface TeamFieldRefs {
    readonly id: FieldRef<"Team", 'String'>
    readonly eventId: FieldRef<"Team", 'String'>
    readonly teamName: FieldRef<"Team", 'String'>
    readonly teamLeaderId: FieldRef<"Team", 'String'>
    readonly isComplete: FieldRef<"Team", 'Boolean'>
    readonly isLocked: FieldRef<"Team", 'Boolean'>
    readonly collegeName: FieldRef<"Team", 'String'>
    readonly createdAt: FieldRef<"Team", 'DateTime'>
    readonly updatedAt: FieldRef<"Team", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Team findUnique
   */
  export type TeamFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findUniqueOrThrow
   */
  export type TeamFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team findFirst
   */
  export type TeamFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findFirstOrThrow
   */
  export type TeamFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Team to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Teams.
     */
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team findMany
   */
  export type TeamFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter, which Teams to fetch.
     */
    where?: TeamWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Teams to fetch.
     */
    orderBy?: TeamOrderByWithRelationInput | TeamOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Teams.
     */
    cursor?: TeamWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Teams from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Teams.
     */
    skip?: number
    distinct?: TeamScalarFieldEnum | TeamScalarFieldEnum[]
  }

  /**
   * Team create
   */
  export type TeamCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to create a Team.
     */
    data: XOR<TeamCreateInput, TeamUncheckedCreateInput>
  }

  /**
   * Team createMany
   */
  export type TeamCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Teams.
     */
    data: TeamCreateManyInput | TeamCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Team update
   */
  export type TeamUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The data needed to update a Team.
     */
    data: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
    /**
     * Choose, which Team to update.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team updateMany
   */
  export type TeamUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Teams.
     */
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyInput>
    /**
     * Filter which Teams to update
     */
    where?: TeamWhereInput
  }

  /**
   * Team upsert
   */
  export type TeamUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * The filter to search for the Team to update in case it exists.
     */
    where: TeamWhereUniqueInput
    /**
     * In case the Team found by the `where` argument doesn't exist, create a new Team with this data.
     */
    create: XOR<TeamCreateInput, TeamUncheckedCreateInput>
    /**
     * In case the Team was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamUpdateInput, TeamUncheckedUpdateInput>
  }

  /**
   * Team delete
   */
  export type TeamDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    /**
     * Filter which Team to delete.
     */
    where: TeamWhereUniqueInput
  }

  /**
   * Team deleteMany
   */
  export type TeamDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Teams to delete
     */
    where?: TeamWhereInput
  }

  /**
   * Team.members
   */
  export type Team$membersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    cursor?: TeamMemberWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * Team.joinRequests
   */
  export type Team$joinRequestsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null
    where?: TeamJoinRequestWhereInput
    orderBy?: TeamJoinRequestOrderByWithRelationInput | TeamJoinRequestOrderByWithRelationInput[]
    cursor?: TeamJoinRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TeamJoinRequestScalarFieldEnum | TeamJoinRequestScalarFieldEnum[]
  }

  /**
   * Team.registrations
   */
  export type Team$registrationsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    where?: EventRegistrationWhereInput
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    cursor?: EventRegistrationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * Team.submissions
   */
  export type Team$submissionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
    where?: EventSubmissionWhereInput
    orderBy?: EventSubmissionOrderByWithRelationInput | EventSubmissionOrderByWithRelationInput[]
    cursor?: EventSubmissionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventSubmissionScalarFieldEnum | EventSubmissionScalarFieldEnum[]
  }

  /**
   * Team.certificates
   */
  export type Team$certificatesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    cursor?: CertificateWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Team without action
   */
  export type TeamDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
  }


  /**
   * Model TeamMember
   */

  export type AggregateTeamMember = {
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  export type TeamMemberMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    isLeader: boolean | null
    status: string | null
    joinedAt: Date | null
    leftAt: Date | null
  }

  export type TeamMemberMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    isLeader: boolean | null
    status: string | null
    joinedAt: Date | null
    leftAt: Date | null
  }

  export type TeamMemberCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    isLeader: number
    status: number
    joinedAt: number
    leftAt: number
    _all: number
  }


  export type TeamMemberMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    isLeader?: true
    status?: true
    joinedAt?: true
    leftAt?: true
  }

  export type TeamMemberMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    isLeader?: true
    status?: true
    joinedAt?: true
    leftAt?: true
  }

  export type TeamMemberCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    isLeader?: true
    status?: true
    joinedAt?: true
    leftAt?: true
    _all?: true
  }

  export type TeamMemberAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMember to aggregate.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamMembers
    **/
    _count?: true | TeamMemberCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamMemberMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamMemberMaxAggregateInputType
  }

  export type GetTeamMemberAggregateType<T extends TeamMemberAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamMember]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamMember[P]>
      : GetScalarType<T[P], AggregateTeamMember[P]>
  }




  export type TeamMemberGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamMemberWhereInput
    orderBy?: TeamMemberOrderByWithAggregationInput | TeamMemberOrderByWithAggregationInput[]
    by: TeamMemberScalarFieldEnum[] | TeamMemberScalarFieldEnum
    having?: TeamMemberScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamMemberCountAggregateInputType | true
    _min?: TeamMemberMinAggregateInputType
    _max?: TeamMemberMaxAggregateInputType
  }

  export type TeamMemberGroupByOutputType = {
    id: string
    teamId: string
    userId: string
    isLeader: boolean
    status: string
    joinedAt: Date
    leftAt: Date | null
    _count: TeamMemberCountAggregateOutputType | null
    _min: TeamMemberMinAggregateOutputType | null
    _max: TeamMemberMaxAggregateOutputType | null
  }

  type GetTeamMemberGroupByPayload<T extends TeamMemberGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamMemberGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamMemberGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
            : GetScalarType<T[P], TeamMemberGroupByOutputType[P]>
        }
      >
    >


  export type TeamMemberSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    isLeader?: boolean
    status?: boolean
    joinedAt?: boolean
    leftAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamMember"]>


  export type TeamMemberSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
    isLeader?: boolean
    status?: boolean
    joinedAt?: boolean
    leftAt?: boolean
  }

  export type TeamMemberInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamMemberPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamMember"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      userId: string
      isLeader: boolean
      status: string
      joinedAt: Date
      leftAt: Date | null
    }, ExtArgs["result"]["teamMember"]>
    composites: {}
  }

  type TeamMemberGetPayload<S extends boolean | null | undefined | TeamMemberDefaultArgs> = $Result.GetResult<Prisma.$TeamMemberPayload, S>

  type TeamMemberCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamMemberFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamMemberCountAggregateInputType | true
    }

  export interface TeamMemberDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamMember'], meta: { name: 'TeamMember' } }
    /**
     * Find zero or one TeamMember that matches the filter.
     * @param {TeamMemberFindUniqueArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamMemberFindUniqueArgs>(args: SelectSubset<T, TeamMemberFindUniqueArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeamMember that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamMemberFindUniqueOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamMemberFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamMemberFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamMemberFindFirstArgs>(args?: SelectSubset<T, TeamMemberFindFirstArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeamMember that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindFirstOrThrowArgs} args - Arguments to find a TeamMember
     * @example
     * // Get one TeamMember
     * const teamMember = await prisma.teamMember.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamMemberFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamMemberFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeamMembers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamMembers
     * const teamMembers = await prisma.teamMember.findMany()
     * 
     * // Get first 10 TeamMembers
     * const teamMembers = await prisma.teamMember.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamMemberWithIdOnly = await prisma.teamMember.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamMemberFindManyArgs>(args?: SelectSubset<T, TeamMemberFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeamMember.
     * @param {TeamMemberCreateArgs} args - Arguments to create a TeamMember.
     * @example
     * // Create one TeamMember
     * const TeamMember = await prisma.teamMember.create({
     *   data: {
     *     // ... data to create a TeamMember
     *   }
     * })
     * 
     */
    create<T extends TeamMemberCreateArgs>(args: SelectSubset<T, TeamMemberCreateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeamMembers.
     * @param {TeamMemberCreateManyArgs} args - Arguments to create many TeamMembers.
     * @example
     * // Create many TeamMembers
     * const teamMember = await prisma.teamMember.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamMemberCreateManyArgs>(args?: SelectSubset<T, TeamMemberCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamMember.
     * @param {TeamMemberDeleteArgs} args - Arguments to delete one TeamMember.
     * @example
     * // Delete one TeamMember
     * const TeamMember = await prisma.teamMember.delete({
     *   where: {
     *     // ... filter to delete one TeamMember
     *   }
     * })
     * 
     */
    delete<T extends TeamMemberDeleteArgs>(args: SelectSubset<T, TeamMemberDeleteArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeamMember.
     * @param {TeamMemberUpdateArgs} args - Arguments to update one TeamMember.
     * @example
     * // Update one TeamMember
     * const teamMember = await prisma.teamMember.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamMemberUpdateArgs>(args: SelectSubset<T, TeamMemberUpdateArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeamMembers.
     * @param {TeamMemberDeleteManyArgs} args - Arguments to filter TeamMembers to delete.
     * @example
     * // Delete a few TeamMembers
     * const { count } = await prisma.teamMember.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamMemberDeleteManyArgs>(args?: SelectSubset<T, TeamMemberDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamMembers
     * const teamMember = await prisma.teamMember.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamMemberUpdateManyArgs>(args: SelectSubset<T, TeamMemberUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamMember.
     * @param {TeamMemberUpsertArgs} args - Arguments to update or create a TeamMember.
     * @example
     * // Update or create a TeamMember
     * const teamMember = await prisma.teamMember.upsert({
     *   create: {
     *     // ... data to create a TeamMember
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamMember we want to update
     *   }
     * })
     */
    upsert<T extends TeamMemberUpsertArgs>(args: SelectSubset<T, TeamMemberUpsertArgs<ExtArgs>>): Prisma__TeamMemberClient<$Result.GetResult<Prisma.$TeamMemberPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeamMembers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberCountArgs} args - Arguments to filter TeamMembers to count.
     * @example
     * // Count the number of TeamMembers
     * const count = await prisma.teamMember.count({
     *   where: {
     *     // ... the filter for the TeamMembers we want to count
     *   }
     * })
    **/
    count<T extends TeamMemberCountArgs>(
      args?: Subset<T, TeamMemberCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamMemberCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamMemberAggregateArgs>(args: Subset<T, TeamMemberAggregateArgs>): Prisma.PrismaPromise<GetTeamMemberAggregateType<T>>

    /**
     * Group by TeamMember.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamMemberGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamMemberGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamMemberGroupByArgs['orderBy'] }
        : { orderBy?: TeamMemberGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamMemberGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamMemberGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamMember model
   */
  readonly fields: TeamMemberFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamMember.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamMemberClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamMember model
   */ 
  interface TeamMemberFieldRefs {
    readonly id: FieldRef<"TeamMember", 'String'>
    readonly teamId: FieldRef<"TeamMember", 'String'>
    readonly userId: FieldRef<"TeamMember", 'String'>
    readonly isLeader: FieldRef<"TeamMember", 'Boolean'>
    readonly status: FieldRef<"TeamMember", 'String'>
    readonly joinedAt: FieldRef<"TeamMember", 'DateTime'>
    readonly leftAt: FieldRef<"TeamMember", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamMember findUnique
   */
  export type TeamMemberFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findUniqueOrThrow
   */
  export type TeamMemberFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember findFirst
   */
  export type TeamMemberFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findFirstOrThrow
   */
  export type TeamMemberFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMember to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamMembers.
     */
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember findMany
   */
  export type TeamMemberFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter, which TeamMembers to fetch.
     */
    where?: TeamMemberWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamMembers to fetch.
     */
    orderBy?: TeamMemberOrderByWithRelationInput | TeamMemberOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamMembers.
     */
    cursor?: TeamMemberWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamMembers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamMembers.
     */
    skip?: number
    distinct?: TeamMemberScalarFieldEnum | TeamMemberScalarFieldEnum[]
  }

  /**
   * TeamMember create
   */
  export type TeamMemberCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamMember.
     */
    data: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
  }

  /**
   * TeamMember createMany
   */
  export type TeamMemberCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamMembers.
     */
    data: TeamMemberCreateManyInput | TeamMemberCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamMember update
   */
  export type TeamMemberUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamMember.
     */
    data: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
    /**
     * Choose, which TeamMember to update.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember updateMany
   */
  export type TeamMemberUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamMembers.
     */
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyInput>
    /**
     * Filter which TeamMembers to update
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember upsert
   */
  export type TeamMemberUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamMember to update in case it exists.
     */
    where: TeamMemberWhereUniqueInput
    /**
     * In case the TeamMember found by the `where` argument doesn't exist, create a new TeamMember with this data.
     */
    create: XOR<TeamMemberCreateInput, TeamMemberUncheckedCreateInput>
    /**
     * In case the TeamMember was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamMemberUpdateInput, TeamMemberUncheckedUpdateInput>
  }

  /**
   * TeamMember delete
   */
  export type TeamMemberDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
    /**
     * Filter which TeamMember to delete.
     */
    where: TeamMemberWhereUniqueInput
  }

  /**
   * TeamMember deleteMany
   */
  export type TeamMemberDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamMembers to delete
     */
    where?: TeamMemberWhereInput
  }

  /**
   * TeamMember without action
   */
  export type TeamMemberDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamMember
     */
    select?: TeamMemberSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamMemberInclude<ExtArgs> | null
  }


  /**
   * Model TeamJoinRequest
   */

  export type AggregateTeamJoinRequest = {
    _count: TeamJoinRequestCountAggregateOutputType | null
    _min: TeamJoinRequestMinAggregateOutputType | null
    _max: TeamJoinRequestMaxAggregateOutputType | null
  }

  export type TeamJoinRequestMinAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    requestType: string | null
    status: string | null
    message: string | null
    responseMessage: string | null
    createdAt: Date | null
    respondedAt: Date | null
  }

  export type TeamJoinRequestMaxAggregateOutputType = {
    id: string | null
    teamId: string | null
    userId: string | null
    requestType: string | null
    status: string | null
    message: string | null
    responseMessage: string | null
    createdAt: Date | null
    respondedAt: Date | null
  }

  export type TeamJoinRequestCountAggregateOutputType = {
    id: number
    teamId: number
    userId: number
    requestType: number
    status: number
    message: number
    responseMessage: number
    createdAt: number
    respondedAt: number
    _all: number
  }


  export type TeamJoinRequestMinAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    requestType?: true
    status?: true
    message?: true
    responseMessage?: true
    createdAt?: true
    respondedAt?: true
  }

  export type TeamJoinRequestMaxAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    requestType?: true
    status?: true
    message?: true
    responseMessage?: true
    createdAt?: true
    respondedAt?: true
  }

  export type TeamJoinRequestCountAggregateInputType = {
    id?: true
    teamId?: true
    userId?: true
    requestType?: true
    status?: true
    message?: true
    responseMessage?: true
    createdAt?: true
    respondedAt?: true
    _all?: true
  }

  export type TeamJoinRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamJoinRequest to aggregate.
     */
    where?: TeamJoinRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamJoinRequests to fetch.
     */
    orderBy?: TeamJoinRequestOrderByWithRelationInput | TeamJoinRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TeamJoinRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamJoinRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamJoinRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TeamJoinRequests
    **/
    _count?: true | TeamJoinRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TeamJoinRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TeamJoinRequestMaxAggregateInputType
  }

  export type GetTeamJoinRequestAggregateType<T extends TeamJoinRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateTeamJoinRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTeamJoinRequest[P]>
      : GetScalarType<T[P], AggregateTeamJoinRequest[P]>
  }




  export type TeamJoinRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TeamJoinRequestWhereInput
    orderBy?: TeamJoinRequestOrderByWithAggregationInput | TeamJoinRequestOrderByWithAggregationInput[]
    by: TeamJoinRequestScalarFieldEnum[] | TeamJoinRequestScalarFieldEnum
    having?: TeamJoinRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TeamJoinRequestCountAggregateInputType | true
    _min?: TeamJoinRequestMinAggregateInputType
    _max?: TeamJoinRequestMaxAggregateInputType
  }

  export type TeamJoinRequestGroupByOutputType = {
    id: string
    teamId: string
    userId: string
    requestType: string
    status: string
    message: string | null
    responseMessage: string | null
    createdAt: Date
    respondedAt: Date | null
    _count: TeamJoinRequestCountAggregateOutputType | null
    _min: TeamJoinRequestMinAggregateOutputType | null
    _max: TeamJoinRequestMaxAggregateOutputType | null
  }

  type GetTeamJoinRequestGroupByPayload<T extends TeamJoinRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TeamJoinRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TeamJoinRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TeamJoinRequestGroupByOutputType[P]>
            : GetScalarType<T[P], TeamJoinRequestGroupByOutputType[P]>
        }
      >
    >


  export type TeamJoinRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    teamId?: boolean
    userId?: boolean
    requestType?: boolean
    status?: boolean
    message?: boolean
    responseMessage?: boolean
    createdAt?: boolean
    respondedAt?: boolean
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["teamJoinRequest"]>


  export type TeamJoinRequestSelectScalar = {
    id?: boolean
    teamId?: boolean
    userId?: boolean
    requestType?: boolean
    status?: boolean
    message?: boolean
    responseMessage?: boolean
    createdAt?: boolean
    respondedAt?: boolean
  }

  export type TeamJoinRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    team?: boolean | TeamDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $TeamJoinRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TeamJoinRequest"
    objects: {
      team: Prisma.$TeamPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      teamId: string
      userId: string
      requestType: string
      status: string
      message: string | null
      responseMessage: string | null
      createdAt: Date
      respondedAt: Date | null
    }, ExtArgs["result"]["teamJoinRequest"]>
    composites: {}
  }

  type TeamJoinRequestGetPayload<S extends boolean | null | undefined | TeamJoinRequestDefaultArgs> = $Result.GetResult<Prisma.$TeamJoinRequestPayload, S>

  type TeamJoinRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TeamJoinRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TeamJoinRequestCountAggregateInputType | true
    }

  export interface TeamJoinRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TeamJoinRequest'], meta: { name: 'TeamJoinRequest' } }
    /**
     * Find zero or one TeamJoinRequest that matches the filter.
     * @param {TeamJoinRequestFindUniqueArgs} args - Arguments to find a TeamJoinRequest
     * @example
     * // Get one TeamJoinRequest
     * const teamJoinRequest = await prisma.teamJoinRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TeamJoinRequestFindUniqueArgs>(args: SelectSubset<T, TeamJoinRequestFindUniqueArgs<ExtArgs>>): Prisma__TeamJoinRequestClient<$Result.GetResult<Prisma.$TeamJoinRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TeamJoinRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TeamJoinRequestFindUniqueOrThrowArgs} args - Arguments to find a TeamJoinRequest
     * @example
     * // Get one TeamJoinRequest
     * const teamJoinRequest = await prisma.teamJoinRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TeamJoinRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, TeamJoinRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TeamJoinRequestClient<$Result.GetResult<Prisma.$TeamJoinRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TeamJoinRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestFindFirstArgs} args - Arguments to find a TeamJoinRequest
     * @example
     * // Get one TeamJoinRequest
     * const teamJoinRequest = await prisma.teamJoinRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TeamJoinRequestFindFirstArgs>(args?: SelectSubset<T, TeamJoinRequestFindFirstArgs<ExtArgs>>): Prisma__TeamJoinRequestClient<$Result.GetResult<Prisma.$TeamJoinRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TeamJoinRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestFindFirstOrThrowArgs} args - Arguments to find a TeamJoinRequest
     * @example
     * // Get one TeamJoinRequest
     * const teamJoinRequest = await prisma.teamJoinRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TeamJoinRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, TeamJoinRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__TeamJoinRequestClient<$Result.GetResult<Prisma.$TeamJoinRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TeamJoinRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TeamJoinRequests
     * const teamJoinRequests = await prisma.teamJoinRequest.findMany()
     * 
     * // Get first 10 TeamJoinRequests
     * const teamJoinRequests = await prisma.teamJoinRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const teamJoinRequestWithIdOnly = await prisma.teamJoinRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TeamJoinRequestFindManyArgs>(args?: SelectSubset<T, TeamJoinRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TeamJoinRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TeamJoinRequest.
     * @param {TeamJoinRequestCreateArgs} args - Arguments to create a TeamJoinRequest.
     * @example
     * // Create one TeamJoinRequest
     * const TeamJoinRequest = await prisma.teamJoinRequest.create({
     *   data: {
     *     // ... data to create a TeamJoinRequest
     *   }
     * })
     * 
     */
    create<T extends TeamJoinRequestCreateArgs>(args: SelectSubset<T, TeamJoinRequestCreateArgs<ExtArgs>>): Prisma__TeamJoinRequestClient<$Result.GetResult<Prisma.$TeamJoinRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TeamJoinRequests.
     * @param {TeamJoinRequestCreateManyArgs} args - Arguments to create many TeamJoinRequests.
     * @example
     * // Create many TeamJoinRequests
     * const teamJoinRequest = await prisma.teamJoinRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TeamJoinRequestCreateManyArgs>(args?: SelectSubset<T, TeamJoinRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a TeamJoinRequest.
     * @param {TeamJoinRequestDeleteArgs} args - Arguments to delete one TeamJoinRequest.
     * @example
     * // Delete one TeamJoinRequest
     * const TeamJoinRequest = await prisma.teamJoinRequest.delete({
     *   where: {
     *     // ... filter to delete one TeamJoinRequest
     *   }
     * })
     * 
     */
    delete<T extends TeamJoinRequestDeleteArgs>(args: SelectSubset<T, TeamJoinRequestDeleteArgs<ExtArgs>>): Prisma__TeamJoinRequestClient<$Result.GetResult<Prisma.$TeamJoinRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TeamJoinRequest.
     * @param {TeamJoinRequestUpdateArgs} args - Arguments to update one TeamJoinRequest.
     * @example
     * // Update one TeamJoinRequest
     * const teamJoinRequest = await prisma.teamJoinRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TeamJoinRequestUpdateArgs>(args: SelectSubset<T, TeamJoinRequestUpdateArgs<ExtArgs>>): Prisma__TeamJoinRequestClient<$Result.GetResult<Prisma.$TeamJoinRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TeamJoinRequests.
     * @param {TeamJoinRequestDeleteManyArgs} args - Arguments to filter TeamJoinRequests to delete.
     * @example
     * // Delete a few TeamJoinRequests
     * const { count } = await prisma.teamJoinRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TeamJoinRequestDeleteManyArgs>(args?: SelectSubset<T, TeamJoinRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TeamJoinRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TeamJoinRequests
     * const teamJoinRequest = await prisma.teamJoinRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TeamJoinRequestUpdateManyArgs>(args: SelectSubset<T, TeamJoinRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TeamJoinRequest.
     * @param {TeamJoinRequestUpsertArgs} args - Arguments to update or create a TeamJoinRequest.
     * @example
     * // Update or create a TeamJoinRequest
     * const teamJoinRequest = await prisma.teamJoinRequest.upsert({
     *   create: {
     *     // ... data to create a TeamJoinRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TeamJoinRequest we want to update
     *   }
     * })
     */
    upsert<T extends TeamJoinRequestUpsertArgs>(args: SelectSubset<T, TeamJoinRequestUpsertArgs<ExtArgs>>): Prisma__TeamJoinRequestClient<$Result.GetResult<Prisma.$TeamJoinRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TeamJoinRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestCountArgs} args - Arguments to filter TeamJoinRequests to count.
     * @example
     * // Count the number of TeamJoinRequests
     * const count = await prisma.teamJoinRequest.count({
     *   where: {
     *     // ... the filter for the TeamJoinRequests we want to count
     *   }
     * })
    **/
    count<T extends TeamJoinRequestCountArgs>(
      args?: Subset<T, TeamJoinRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TeamJoinRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TeamJoinRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TeamJoinRequestAggregateArgs>(args: Subset<T, TeamJoinRequestAggregateArgs>): Prisma.PrismaPromise<GetTeamJoinRequestAggregateType<T>>

    /**
     * Group by TeamJoinRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TeamJoinRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TeamJoinRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TeamJoinRequestGroupByArgs['orderBy'] }
        : { orderBy?: TeamJoinRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TeamJoinRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTeamJoinRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TeamJoinRequest model
   */
  readonly fields: TeamJoinRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TeamJoinRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TeamJoinRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    team<T extends TeamDefaultArgs<ExtArgs> = {}>(args?: Subset<T, TeamDefaultArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TeamJoinRequest model
   */ 
  interface TeamJoinRequestFieldRefs {
    readonly id: FieldRef<"TeamJoinRequest", 'String'>
    readonly teamId: FieldRef<"TeamJoinRequest", 'String'>
    readonly userId: FieldRef<"TeamJoinRequest", 'String'>
    readonly requestType: FieldRef<"TeamJoinRequest", 'String'>
    readonly status: FieldRef<"TeamJoinRequest", 'String'>
    readonly message: FieldRef<"TeamJoinRequest", 'String'>
    readonly responseMessage: FieldRef<"TeamJoinRequest", 'String'>
    readonly createdAt: FieldRef<"TeamJoinRequest", 'DateTime'>
    readonly respondedAt: FieldRef<"TeamJoinRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TeamJoinRequest findUnique
   */
  export type TeamJoinRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which TeamJoinRequest to fetch.
     */
    where: TeamJoinRequestWhereUniqueInput
  }

  /**
   * TeamJoinRequest findUniqueOrThrow
   */
  export type TeamJoinRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which TeamJoinRequest to fetch.
     */
    where: TeamJoinRequestWhereUniqueInput
  }

  /**
   * TeamJoinRequest findFirst
   */
  export type TeamJoinRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which TeamJoinRequest to fetch.
     */
    where?: TeamJoinRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamJoinRequests to fetch.
     */
    orderBy?: TeamJoinRequestOrderByWithRelationInput | TeamJoinRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamJoinRequests.
     */
    cursor?: TeamJoinRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamJoinRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamJoinRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamJoinRequests.
     */
    distinct?: TeamJoinRequestScalarFieldEnum | TeamJoinRequestScalarFieldEnum[]
  }

  /**
   * TeamJoinRequest findFirstOrThrow
   */
  export type TeamJoinRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which TeamJoinRequest to fetch.
     */
    where?: TeamJoinRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamJoinRequests to fetch.
     */
    orderBy?: TeamJoinRequestOrderByWithRelationInput | TeamJoinRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TeamJoinRequests.
     */
    cursor?: TeamJoinRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamJoinRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamJoinRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TeamJoinRequests.
     */
    distinct?: TeamJoinRequestScalarFieldEnum | TeamJoinRequestScalarFieldEnum[]
  }

  /**
   * TeamJoinRequest findMany
   */
  export type TeamJoinRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null
    /**
     * Filter, which TeamJoinRequests to fetch.
     */
    where?: TeamJoinRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TeamJoinRequests to fetch.
     */
    orderBy?: TeamJoinRequestOrderByWithRelationInput | TeamJoinRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TeamJoinRequests.
     */
    cursor?: TeamJoinRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TeamJoinRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TeamJoinRequests.
     */
    skip?: number
    distinct?: TeamJoinRequestScalarFieldEnum | TeamJoinRequestScalarFieldEnum[]
  }

  /**
   * TeamJoinRequest create
   */
  export type TeamJoinRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a TeamJoinRequest.
     */
    data: XOR<TeamJoinRequestCreateInput, TeamJoinRequestUncheckedCreateInput>
  }

  /**
   * TeamJoinRequest createMany
   */
  export type TeamJoinRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TeamJoinRequests.
     */
    data: TeamJoinRequestCreateManyInput | TeamJoinRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TeamJoinRequest update
   */
  export type TeamJoinRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a TeamJoinRequest.
     */
    data: XOR<TeamJoinRequestUpdateInput, TeamJoinRequestUncheckedUpdateInput>
    /**
     * Choose, which TeamJoinRequest to update.
     */
    where: TeamJoinRequestWhereUniqueInput
  }

  /**
   * TeamJoinRequest updateMany
   */
  export type TeamJoinRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TeamJoinRequests.
     */
    data: XOR<TeamJoinRequestUpdateManyMutationInput, TeamJoinRequestUncheckedUpdateManyInput>
    /**
     * Filter which TeamJoinRequests to update
     */
    where?: TeamJoinRequestWhereInput
  }

  /**
   * TeamJoinRequest upsert
   */
  export type TeamJoinRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the TeamJoinRequest to update in case it exists.
     */
    where: TeamJoinRequestWhereUniqueInput
    /**
     * In case the TeamJoinRequest found by the `where` argument doesn't exist, create a new TeamJoinRequest with this data.
     */
    create: XOR<TeamJoinRequestCreateInput, TeamJoinRequestUncheckedCreateInput>
    /**
     * In case the TeamJoinRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TeamJoinRequestUpdateInput, TeamJoinRequestUncheckedUpdateInput>
  }

  /**
   * TeamJoinRequest delete
   */
  export type TeamJoinRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null
    /**
     * Filter which TeamJoinRequest to delete.
     */
    where: TeamJoinRequestWhereUniqueInput
  }

  /**
   * TeamJoinRequest deleteMany
   */
  export type TeamJoinRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TeamJoinRequests to delete
     */
    where?: TeamJoinRequestWhereInput
  }

  /**
   * TeamJoinRequest without action
   */
  export type TeamJoinRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TeamJoinRequest
     */
    select?: TeamJoinRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamJoinRequestInclude<ExtArgs> | null
  }


  /**
   * Model EventRegistration
   */

  export type AggregateEventRegistration = {
    _count: EventRegistrationCountAggregateOutputType | null
    _avg: EventRegistrationAvgAggregateOutputType | null
    _sum: EventRegistrationSumAggregateOutputType | null
    _min: EventRegistrationMinAggregateOutputType | null
    _max: EventRegistrationMaxAggregateOutputType | null
  }

  export type EventRegistrationAvgAggregateOutputType = {
    amountPaid: Decimal | null
  }

  export type EventRegistrationSumAggregateOutputType = {
    amountPaid: Decimal | null
  }

  export type EventRegistrationMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    teamId: string | null
    participationType: string | null
    paymentStatus: string | null
    paymentId: string | null
    amountPaid: Decimal | null
    paidAt: Date | null
    status: string | null
    registeredAt: Date | null
    cancelledAt: Date | null
  }

  export type EventRegistrationMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    teamId: string | null
    participationType: string | null
    paymentStatus: string | null
    paymentId: string | null
    amountPaid: Decimal | null
    paidAt: Date | null
    status: string | null
    registeredAt: Date | null
    cancelledAt: Date | null
  }

  export type EventRegistrationCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    teamId: number
    participationType: number
    paymentStatus: number
    paymentId: number
    amountPaid: number
    paidAt: number
    status: number
    registeredAt: number
    cancelledAt: number
    _all: number
  }


  export type EventRegistrationAvgAggregateInputType = {
    amountPaid?: true
  }

  export type EventRegistrationSumAggregateInputType = {
    amountPaid?: true
  }

  export type EventRegistrationMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    teamId?: true
    participationType?: true
    paymentStatus?: true
    paymentId?: true
    amountPaid?: true
    paidAt?: true
    status?: true
    registeredAt?: true
    cancelledAt?: true
  }

  export type EventRegistrationMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    teamId?: true
    participationType?: true
    paymentStatus?: true
    paymentId?: true
    amountPaid?: true
    paidAt?: true
    status?: true
    registeredAt?: true
    cancelledAt?: true
  }

  export type EventRegistrationCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    teamId?: true
    participationType?: true
    paymentStatus?: true
    paymentId?: true
    amountPaid?: true
    paidAt?: true
    status?: true
    registeredAt?: true
    cancelledAt?: true
    _all?: true
  }

  export type EventRegistrationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRegistration to aggregate.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventRegistrations
    **/
    _count?: true | EventRegistrationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventRegistrationAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventRegistrationSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventRegistrationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventRegistrationMaxAggregateInputType
  }

  export type GetEventRegistrationAggregateType<T extends EventRegistrationAggregateArgs> = {
        [P in keyof T & keyof AggregateEventRegistration]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventRegistration[P]>
      : GetScalarType<T[P], AggregateEventRegistration[P]>
  }




  export type EventRegistrationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventRegistrationWhereInput
    orderBy?: EventRegistrationOrderByWithAggregationInput | EventRegistrationOrderByWithAggregationInput[]
    by: EventRegistrationScalarFieldEnum[] | EventRegistrationScalarFieldEnum
    having?: EventRegistrationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventRegistrationCountAggregateInputType | true
    _avg?: EventRegistrationAvgAggregateInputType
    _sum?: EventRegistrationSumAggregateInputType
    _min?: EventRegistrationMinAggregateInputType
    _max?: EventRegistrationMaxAggregateInputType
  }

  export type EventRegistrationGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    teamId: string | null
    participationType: string
    paymentStatus: string
    paymentId: string | null
    amountPaid: Decimal | null
    paidAt: Date | null
    status: string
    registeredAt: Date
    cancelledAt: Date | null
    _count: EventRegistrationCountAggregateOutputType | null
    _avg: EventRegistrationAvgAggregateOutputType | null
    _sum: EventRegistrationSumAggregateOutputType | null
    _min: EventRegistrationMinAggregateOutputType | null
    _max: EventRegistrationMaxAggregateOutputType | null
  }

  type GetEventRegistrationGroupByPayload<T extends EventRegistrationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventRegistrationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventRegistrationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventRegistrationGroupByOutputType[P]>
            : GetScalarType<T[P], EventRegistrationGroupByOutputType[P]>
        }
      >
    >


  export type EventRegistrationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    teamId?: boolean
    participationType?: boolean
    paymentStatus?: boolean
    paymentId?: boolean
    amountPaid?: boolean
    paidAt?: boolean
    status?: boolean
    registeredAt?: boolean
    cancelledAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | EventRegistration$teamArgs<ExtArgs>
  }, ExtArgs["result"]["eventRegistration"]>


  export type EventRegistrationSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    teamId?: boolean
    participationType?: boolean
    paymentStatus?: boolean
    paymentId?: boolean
    amountPaid?: boolean
    paidAt?: boolean
    status?: boolean
    registeredAt?: boolean
    cancelledAt?: boolean
  }

  export type EventRegistrationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | EventRegistration$teamArgs<ExtArgs>
  }

  export type $EventRegistrationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventRegistration"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      teamId: string | null
      participationType: string
      paymentStatus: string
      paymentId: string | null
      amountPaid: Prisma.Decimal | null
      paidAt: Date | null
      status: string
      registeredAt: Date
      cancelledAt: Date | null
    }, ExtArgs["result"]["eventRegistration"]>
    composites: {}
  }

  type EventRegistrationGetPayload<S extends boolean | null | undefined | EventRegistrationDefaultArgs> = $Result.GetResult<Prisma.$EventRegistrationPayload, S>

  type EventRegistrationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventRegistrationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventRegistrationCountAggregateInputType | true
    }

  export interface EventRegistrationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventRegistration'], meta: { name: 'EventRegistration' } }
    /**
     * Find zero or one EventRegistration that matches the filter.
     * @param {EventRegistrationFindUniqueArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventRegistrationFindUniqueArgs>(args: SelectSubset<T, EventRegistrationFindUniqueArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventRegistration that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventRegistrationFindUniqueOrThrowArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventRegistrationFindUniqueOrThrowArgs>(args: SelectSubset<T, EventRegistrationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventRegistration that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindFirstArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventRegistrationFindFirstArgs>(args?: SelectSubset<T, EventRegistrationFindFirstArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventRegistration that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindFirstOrThrowArgs} args - Arguments to find a EventRegistration
     * @example
     * // Get one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventRegistrationFindFirstOrThrowArgs>(args?: SelectSubset<T, EventRegistrationFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventRegistrations that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventRegistrations
     * const eventRegistrations = await prisma.eventRegistration.findMany()
     * 
     * // Get first 10 EventRegistrations
     * const eventRegistrations = await prisma.eventRegistration.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventRegistrationWithIdOnly = await prisma.eventRegistration.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventRegistrationFindManyArgs>(args?: SelectSubset<T, EventRegistrationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventRegistration.
     * @param {EventRegistrationCreateArgs} args - Arguments to create a EventRegistration.
     * @example
     * // Create one EventRegistration
     * const EventRegistration = await prisma.eventRegistration.create({
     *   data: {
     *     // ... data to create a EventRegistration
     *   }
     * })
     * 
     */
    create<T extends EventRegistrationCreateArgs>(args: SelectSubset<T, EventRegistrationCreateArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventRegistrations.
     * @param {EventRegistrationCreateManyArgs} args - Arguments to create many EventRegistrations.
     * @example
     * // Create many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventRegistrationCreateManyArgs>(args?: SelectSubset<T, EventRegistrationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventRegistration.
     * @param {EventRegistrationDeleteArgs} args - Arguments to delete one EventRegistration.
     * @example
     * // Delete one EventRegistration
     * const EventRegistration = await prisma.eventRegistration.delete({
     *   where: {
     *     // ... filter to delete one EventRegistration
     *   }
     * })
     * 
     */
    delete<T extends EventRegistrationDeleteArgs>(args: SelectSubset<T, EventRegistrationDeleteArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventRegistration.
     * @param {EventRegistrationUpdateArgs} args - Arguments to update one EventRegistration.
     * @example
     * // Update one EventRegistration
     * const eventRegistration = await prisma.eventRegistration.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventRegistrationUpdateArgs>(args: SelectSubset<T, EventRegistrationUpdateArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventRegistrations.
     * @param {EventRegistrationDeleteManyArgs} args - Arguments to filter EventRegistrations to delete.
     * @example
     * // Delete a few EventRegistrations
     * const { count } = await prisma.eventRegistration.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventRegistrationDeleteManyArgs>(args?: SelectSubset<T, EventRegistrationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventRegistrations
     * const eventRegistration = await prisma.eventRegistration.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventRegistrationUpdateManyArgs>(args: SelectSubset<T, EventRegistrationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventRegistration.
     * @param {EventRegistrationUpsertArgs} args - Arguments to update or create a EventRegistration.
     * @example
     * // Update or create a EventRegistration
     * const eventRegistration = await prisma.eventRegistration.upsert({
     *   create: {
     *     // ... data to create a EventRegistration
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventRegistration we want to update
     *   }
     * })
     */
    upsert<T extends EventRegistrationUpsertArgs>(args: SelectSubset<T, EventRegistrationUpsertArgs<ExtArgs>>): Prisma__EventRegistrationClient<$Result.GetResult<Prisma.$EventRegistrationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventRegistrations.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationCountArgs} args - Arguments to filter EventRegistrations to count.
     * @example
     * // Count the number of EventRegistrations
     * const count = await prisma.eventRegistration.count({
     *   where: {
     *     // ... the filter for the EventRegistrations we want to count
     *   }
     * })
    **/
    count<T extends EventRegistrationCountArgs>(
      args?: Subset<T, EventRegistrationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventRegistrationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventRegistrationAggregateArgs>(args: Subset<T, EventRegistrationAggregateArgs>): Prisma.PrismaPromise<GetEventRegistrationAggregateType<T>>

    /**
     * Group by EventRegistration.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventRegistrationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventRegistrationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventRegistrationGroupByArgs['orderBy'] }
        : { orderBy?: EventRegistrationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventRegistrationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventRegistrationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventRegistration model
   */
  readonly fields: EventRegistrationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventRegistration.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventRegistrationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends EventRegistration$teamArgs<ExtArgs> = {}>(args?: Subset<T, EventRegistration$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventRegistration model
   */ 
  interface EventRegistrationFieldRefs {
    readonly id: FieldRef<"EventRegistration", 'String'>
    readonly eventId: FieldRef<"EventRegistration", 'String'>
    readonly userId: FieldRef<"EventRegistration", 'String'>
    readonly teamId: FieldRef<"EventRegistration", 'String'>
    readonly participationType: FieldRef<"EventRegistration", 'String'>
    readonly paymentStatus: FieldRef<"EventRegistration", 'String'>
    readonly paymentId: FieldRef<"EventRegistration", 'String'>
    readonly amountPaid: FieldRef<"EventRegistration", 'Decimal'>
    readonly paidAt: FieldRef<"EventRegistration", 'DateTime'>
    readonly status: FieldRef<"EventRegistration", 'String'>
    readonly registeredAt: FieldRef<"EventRegistration", 'DateTime'>
    readonly cancelledAt: FieldRef<"EventRegistration", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventRegistration findUnique
   */
  export type EventRegistrationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration findUniqueOrThrow
   */
  export type EventRegistrationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration findFirst
   */
  export type EventRegistrationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRegistrations.
     */
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * EventRegistration findFirstOrThrow
   */
  export type EventRegistrationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistration to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventRegistrations.
     */
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * EventRegistration findMany
   */
  export type EventRegistrationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter, which EventRegistrations to fetch.
     */
    where?: EventRegistrationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventRegistrations to fetch.
     */
    orderBy?: EventRegistrationOrderByWithRelationInput | EventRegistrationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventRegistrations.
     */
    cursor?: EventRegistrationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventRegistrations from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventRegistrations.
     */
    skip?: number
    distinct?: EventRegistrationScalarFieldEnum | EventRegistrationScalarFieldEnum[]
  }

  /**
   * EventRegistration create
   */
  export type EventRegistrationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to create a EventRegistration.
     */
    data: XOR<EventRegistrationCreateInput, EventRegistrationUncheckedCreateInput>
  }

  /**
   * EventRegistration createMany
   */
  export type EventRegistrationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventRegistrations.
     */
    data: EventRegistrationCreateManyInput | EventRegistrationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventRegistration update
   */
  export type EventRegistrationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The data needed to update a EventRegistration.
     */
    data: XOR<EventRegistrationUpdateInput, EventRegistrationUncheckedUpdateInput>
    /**
     * Choose, which EventRegistration to update.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration updateMany
   */
  export type EventRegistrationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventRegistrations.
     */
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyInput>
    /**
     * Filter which EventRegistrations to update
     */
    where?: EventRegistrationWhereInput
  }

  /**
   * EventRegistration upsert
   */
  export type EventRegistrationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * The filter to search for the EventRegistration to update in case it exists.
     */
    where: EventRegistrationWhereUniqueInput
    /**
     * In case the EventRegistration found by the `where` argument doesn't exist, create a new EventRegistration with this data.
     */
    create: XOR<EventRegistrationCreateInput, EventRegistrationUncheckedCreateInput>
    /**
     * In case the EventRegistration was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventRegistrationUpdateInput, EventRegistrationUncheckedUpdateInput>
  }

  /**
   * EventRegistration delete
   */
  export type EventRegistrationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
    /**
     * Filter which EventRegistration to delete.
     */
    where: EventRegistrationWhereUniqueInput
  }

  /**
   * EventRegistration deleteMany
   */
  export type EventRegistrationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventRegistrations to delete
     */
    where?: EventRegistrationWhereInput
  }

  /**
   * EventRegistration.team
   */
  export type EventRegistration$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * EventRegistration without action
   */
  export type EventRegistrationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventRegistration
     */
    select?: EventRegistrationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventRegistrationInclude<ExtArgs> | null
  }


  /**
   * Model EventSubmission
   */

  export type AggregateEventSubmission = {
    _count: EventSubmissionCountAggregateOutputType | null
    _avg: EventSubmissionAvgAggregateOutputType | null
    _sum: EventSubmissionSumAggregateOutputType | null
    _min: EventSubmissionMinAggregateOutputType | null
    _max: EventSubmissionMaxAggregateOutputType | null
  }

  export type EventSubmissionAvgAggregateOutputType = {
    score: Decimal | null
    rank: number | null
  }

  export type EventSubmissionSumAggregateOutputType = {
    score: Decimal | null
    rank: number | null
  }

  export type EventSubmissionMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    teamId: string | null
    projectDeckUrl: string | null
    presentationPdfUrl: string | null
    mvpLink: string | null
    demoVideoUrl: string | null
    githubRepoUrl: string | null
    technologiesUsed: string | null
    aiToolsIntegrated: string | null
    solutionDescription: string | null
    score: Decimal | null
    rank: number | null
    feedback: string | null
    status: string | null
    submittedAt: Date | null
    updatedAt: Date | null
    evaluatedAt: Date | null
  }

  export type EventSubmissionMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    userId: string | null
    teamId: string | null
    projectDeckUrl: string | null
    presentationPdfUrl: string | null
    mvpLink: string | null
    demoVideoUrl: string | null
    githubRepoUrl: string | null
    technologiesUsed: string | null
    aiToolsIntegrated: string | null
    solutionDescription: string | null
    score: Decimal | null
    rank: number | null
    feedback: string | null
    status: string | null
    submittedAt: Date | null
    updatedAt: Date | null
    evaluatedAt: Date | null
  }

  export type EventSubmissionCountAggregateOutputType = {
    id: number
    eventId: number
    userId: number
    teamId: number
    projectDeckUrl: number
    presentationPdfUrl: number
    mvpLink: number
    demoVideoUrl: number
    githubRepoUrl: number
    technologiesUsed: number
    aiToolsIntegrated: number
    solutionDescription: number
    score: number
    rank: number
    feedback: number
    status: number
    submittedAt: number
    updatedAt: number
    evaluatedAt: number
    _all: number
  }


  export type EventSubmissionAvgAggregateInputType = {
    score?: true
    rank?: true
  }

  export type EventSubmissionSumAggregateInputType = {
    score?: true
    rank?: true
  }

  export type EventSubmissionMinAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    teamId?: true
    projectDeckUrl?: true
    presentationPdfUrl?: true
    mvpLink?: true
    demoVideoUrl?: true
    githubRepoUrl?: true
    technologiesUsed?: true
    aiToolsIntegrated?: true
    solutionDescription?: true
    score?: true
    rank?: true
    feedback?: true
    status?: true
    submittedAt?: true
    updatedAt?: true
    evaluatedAt?: true
  }

  export type EventSubmissionMaxAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    teamId?: true
    projectDeckUrl?: true
    presentationPdfUrl?: true
    mvpLink?: true
    demoVideoUrl?: true
    githubRepoUrl?: true
    technologiesUsed?: true
    aiToolsIntegrated?: true
    solutionDescription?: true
    score?: true
    rank?: true
    feedback?: true
    status?: true
    submittedAt?: true
    updatedAt?: true
    evaluatedAt?: true
  }

  export type EventSubmissionCountAggregateInputType = {
    id?: true
    eventId?: true
    userId?: true
    teamId?: true
    projectDeckUrl?: true
    presentationPdfUrl?: true
    mvpLink?: true
    demoVideoUrl?: true
    githubRepoUrl?: true
    technologiesUsed?: true
    aiToolsIntegrated?: true
    solutionDescription?: true
    score?: true
    rank?: true
    feedback?: true
    status?: true
    submittedAt?: true
    updatedAt?: true
    evaluatedAt?: true
    _all?: true
  }

  export type EventSubmissionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventSubmission to aggregate.
     */
    where?: EventSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSubmissions to fetch.
     */
    orderBy?: EventSubmissionOrderByWithRelationInput | EventSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventSubmissions
    **/
    _count?: true | EventSubmissionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EventSubmissionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EventSubmissionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventSubmissionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventSubmissionMaxAggregateInputType
  }

  export type GetEventSubmissionAggregateType<T extends EventSubmissionAggregateArgs> = {
        [P in keyof T & keyof AggregateEventSubmission]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventSubmission[P]>
      : GetScalarType<T[P], AggregateEventSubmission[P]>
  }




  export type EventSubmissionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventSubmissionWhereInput
    orderBy?: EventSubmissionOrderByWithAggregationInput | EventSubmissionOrderByWithAggregationInput[]
    by: EventSubmissionScalarFieldEnum[] | EventSubmissionScalarFieldEnum
    having?: EventSubmissionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventSubmissionCountAggregateInputType | true
    _avg?: EventSubmissionAvgAggregateInputType
    _sum?: EventSubmissionSumAggregateInputType
    _min?: EventSubmissionMinAggregateInputType
    _max?: EventSubmissionMaxAggregateInputType
  }

  export type EventSubmissionGroupByOutputType = {
    id: string
    eventId: string
    userId: string
    teamId: string | null
    projectDeckUrl: string | null
    presentationPdfUrl: string | null
    mvpLink: string | null
    demoVideoUrl: string | null
    githubRepoUrl: string | null
    technologiesUsed: string | null
    aiToolsIntegrated: string | null
    solutionDescription: string | null
    score: Decimal | null
    rank: number | null
    feedback: string | null
    status: string
    submittedAt: Date
    updatedAt: Date
    evaluatedAt: Date | null
    _count: EventSubmissionCountAggregateOutputType | null
    _avg: EventSubmissionAvgAggregateOutputType | null
    _sum: EventSubmissionSumAggregateOutputType | null
    _min: EventSubmissionMinAggregateOutputType | null
    _max: EventSubmissionMaxAggregateOutputType | null
  }

  type GetEventSubmissionGroupByPayload<T extends EventSubmissionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventSubmissionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventSubmissionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventSubmissionGroupByOutputType[P]>
            : GetScalarType<T[P], EventSubmissionGroupByOutputType[P]>
        }
      >
    >


  export type EventSubmissionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    userId?: boolean
    teamId?: boolean
    projectDeckUrl?: boolean
    presentationPdfUrl?: boolean
    mvpLink?: boolean
    demoVideoUrl?: boolean
    githubRepoUrl?: boolean
    technologiesUsed?: boolean
    aiToolsIntegrated?: boolean
    solutionDescription?: boolean
    score?: boolean
    rank?: boolean
    feedback?: boolean
    status?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    evaluatedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | EventSubmission$teamArgs<ExtArgs>
  }, ExtArgs["result"]["eventSubmission"]>


  export type EventSubmissionSelectScalar = {
    id?: boolean
    eventId?: boolean
    userId?: boolean
    teamId?: boolean
    projectDeckUrl?: boolean
    presentationPdfUrl?: boolean
    mvpLink?: boolean
    demoVideoUrl?: boolean
    githubRepoUrl?: boolean
    technologiesUsed?: boolean
    aiToolsIntegrated?: boolean
    solutionDescription?: boolean
    score?: boolean
    rank?: boolean
    feedback?: boolean
    status?: boolean
    submittedAt?: boolean
    updatedAt?: boolean
    evaluatedAt?: boolean
  }

  export type EventSubmissionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | EventSubmission$teamArgs<ExtArgs>
  }

  export type $EventSubmissionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventSubmission"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      userId: string
      teamId: string | null
      projectDeckUrl: string | null
      presentationPdfUrl: string | null
      mvpLink: string | null
      demoVideoUrl: string | null
      githubRepoUrl: string | null
      technologiesUsed: string | null
      aiToolsIntegrated: string | null
      solutionDescription: string | null
      score: Prisma.Decimal | null
      rank: number | null
      feedback: string | null
      status: string
      submittedAt: Date
      updatedAt: Date
      evaluatedAt: Date | null
    }, ExtArgs["result"]["eventSubmission"]>
    composites: {}
  }

  type EventSubmissionGetPayload<S extends boolean | null | undefined | EventSubmissionDefaultArgs> = $Result.GetResult<Prisma.$EventSubmissionPayload, S>

  type EventSubmissionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventSubmissionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventSubmissionCountAggregateInputType | true
    }

  export interface EventSubmissionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventSubmission'], meta: { name: 'EventSubmission' } }
    /**
     * Find zero or one EventSubmission that matches the filter.
     * @param {EventSubmissionFindUniqueArgs} args - Arguments to find a EventSubmission
     * @example
     * // Get one EventSubmission
     * const eventSubmission = await prisma.eventSubmission.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventSubmissionFindUniqueArgs>(args: SelectSubset<T, EventSubmissionFindUniqueArgs<ExtArgs>>): Prisma__EventSubmissionClient<$Result.GetResult<Prisma.$EventSubmissionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventSubmission that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventSubmissionFindUniqueOrThrowArgs} args - Arguments to find a EventSubmission
     * @example
     * // Get one EventSubmission
     * const eventSubmission = await prisma.eventSubmission.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventSubmissionFindUniqueOrThrowArgs>(args: SelectSubset<T, EventSubmissionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventSubmissionClient<$Result.GetResult<Prisma.$EventSubmissionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventSubmission that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSubmissionFindFirstArgs} args - Arguments to find a EventSubmission
     * @example
     * // Get one EventSubmission
     * const eventSubmission = await prisma.eventSubmission.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventSubmissionFindFirstArgs>(args?: SelectSubset<T, EventSubmissionFindFirstArgs<ExtArgs>>): Prisma__EventSubmissionClient<$Result.GetResult<Prisma.$EventSubmissionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventSubmission that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSubmissionFindFirstOrThrowArgs} args - Arguments to find a EventSubmission
     * @example
     * // Get one EventSubmission
     * const eventSubmission = await prisma.eventSubmission.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventSubmissionFindFirstOrThrowArgs>(args?: SelectSubset<T, EventSubmissionFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventSubmissionClient<$Result.GetResult<Prisma.$EventSubmissionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventSubmissions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSubmissionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventSubmissions
     * const eventSubmissions = await prisma.eventSubmission.findMany()
     * 
     * // Get first 10 EventSubmissions
     * const eventSubmissions = await prisma.eventSubmission.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const eventSubmissionWithIdOnly = await prisma.eventSubmission.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EventSubmissionFindManyArgs>(args?: SelectSubset<T, EventSubmissionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventSubmissionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventSubmission.
     * @param {EventSubmissionCreateArgs} args - Arguments to create a EventSubmission.
     * @example
     * // Create one EventSubmission
     * const EventSubmission = await prisma.eventSubmission.create({
     *   data: {
     *     // ... data to create a EventSubmission
     *   }
     * })
     * 
     */
    create<T extends EventSubmissionCreateArgs>(args: SelectSubset<T, EventSubmissionCreateArgs<ExtArgs>>): Prisma__EventSubmissionClient<$Result.GetResult<Prisma.$EventSubmissionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventSubmissions.
     * @param {EventSubmissionCreateManyArgs} args - Arguments to create many EventSubmissions.
     * @example
     * // Create many EventSubmissions
     * const eventSubmission = await prisma.eventSubmission.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventSubmissionCreateManyArgs>(args?: SelectSubset<T, EventSubmissionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventSubmission.
     * @param {EventSubmissionDeleteArgs} args - Arguments to delete one EventSubmission.
     * @example
     * // Delete one EventSubmission
     * const EventSubmission = await prisma.eventSubmission.delete({
     *   where: {
     *     // ... filter to delete one EventSubmission
     *   }
     * })
     * 
     */
    delete<T extends EventSubmissionDeleteArgs>(args: SelectSubset<T, EventSubmissionDeleteArgs<ExtArgs>>): Prisma__EventSubmissionClient<$Result.GetResult<Prisma.$EventSubmissionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventSubmission.
     * @param {EventSubmissionUpdateArgs} args - Arguments to update one EventSubmission.
     * @example
     * // Update one EventSubmission
     * const eventSubmission = await prisma.eventSubmission.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventSubmissionUpdateArgs>(args: SelectSubset<T, EventSubmissionUpdateArgs<ExtArgs>>): Prisma__EventSubmissionClient<$Result.GetResult<Prisma.$EventSubmissionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventSubmissions.
     * @param {EventSubmissionDeleteManyArgs} args - Arguments to filter EventSubmissions to delete.
     * @example
     * // Delete a few EventSubmissions
     * const { count } = await prisma.eventSubmission.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventSubmissionDeleteManyArgs>(args?: SelectSubset<T, EventSubmissionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSubmissionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventSubmissions
     * const eventSubmission = await prisma.eventSubmission.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventSubmissionUpdateManyArgs>(args: SelectSubset<T, EventSubmissionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventSubmission.
     * @param {EventSubmissionUpsertArgs} args - Arguments to update or create a EventSubmission.
     * @example
     * // Update or create a EventSubmission
     * const eventSubmission = await prisma.eventSubmission.upsert({
     *   create: {
     *     // ... data to create a EventSubmission
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventSubmission we want to update
     *   }
     * })
     */
    upsert<T extends EventSubmissionUpsertArgs>(args: SelectSubset<T, EventSubmissionUpsertArgs<ExtArgs>>): Prisma__EventSubmissionClient<$Result.GetResult<Prisma.$EventSubmissionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventSubmissions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSubmissionCountArgs} args - Arguments to filter EventSubmissions to count.
     * @example
     * // Count the number of EventSubmissions
     * const count = await prisma.eventSubmission.count({
     *   where: {
     *     // ... the filter for the EventSubmissions we want to count
     *   }
     * })
    **/
    count<T extends EventSubmissionCountArgs>(
      args?: Subset<T, EventSubmissionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventSubmissionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSubmissionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventSubmissionAggregateArgs>(args: Subset<T, EventSubmissionAggregateArgs>): Prisma.PrismaPromise<GetEventSubmissionAggregateType<T>>

    /**
     * Group by EventSubmission.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventSubmissionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventSubmissionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventSubmissionGroupByArgs['orderBy'] }
        : { orderBy?: EventSubmissionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventSubmissionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventSubmissionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventSubmission model
   */
  readonly fields: EventSubmissionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventSubmission.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventSubmissionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends EventSubmission$teamArgs<ExtArgs> = {}>(args?: Subset<T, EventSubmission$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventSubmission model
   */ 
  interface EventSubmissionFieldRefs {
    readonly id: FieldRef<"EventSubmission", 'String'>
    readonly eventId: FieldRef<"EventSubmission", 'String'>
    readonly userId: FieldRef<"EventSubmission", 'String'>
    readonly teamId: FieldRef<"EventSubmission", 'String'>
    readonly projectDeckUrl: FieldRef<"EventSubmission", 'String'>
    readonly presentationPdfUrl: FieldRef<"EventSubmission", 'String'>
    readonly mvpLink: FieldRef<"EventSubmission", 'String'>
    readonly demoVideoUrl: FieldRef<"EventSubmission", 'String'>
    readonly githubRepoUrl: FieldRef<"EventSubmission", 'String'>
    readonly technologiesUsed: FieldRef<"EventSubmission", 'String'>
    readonly aiToolsIntegrated: FieldRef<"EventSubmission", 'String'>
    readonly solutionDescription: FieldRef<"EventSubmission", 'String'>
    readonly score: FieldRef<"EventSubmission", 'Decimal'>
    readonly rank: FieldRef<"EventSubmission", 'Int'>
    readonly feedback: FieldRef<"EventSubmission", 'String'>
    readonly status: FieldRef<"EventSubmission", 'String'>
    readonly submittedAt: FieldRef<"EventSubmission", 'DateTime'>
    readonly updatedAt: FieldRef<"EventSubmission", 'DateTime'>
    readonly evaluatedAt: FieldRef<"EventSubmission", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EventSubmission findUnique
   */
  export type EventSubmissionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which EventSubmission to fetch.
     */
    where: EventSubmissionWhereUniqueInput
  }

  /**
   * EventSubmission findUniqueOrThrow
   */
  export type EventSubmissionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which EventSubmission to fetch.
     */
    where: EventSubmissionWhereUniqueInput
  }

  /**
   * EventSubmission findFirst
   */
  export type EventSubmissionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which EventSubmission to fetch.
     */
    where?: EventSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSubmissions to fetch.
     */
    orderBy?: EventSubmissionOrderByWithRelationInput | EventSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventSubmissions.
     */
    cursor?: EventSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventSubmissions.
     */
    distinct?: EventSubmissionScalarFieldEnum | EventSubmissionScalarFieldEnum[]
  }

  /**
   * EventSubmission findFirstOrThrow
   */
  export type EventSubmissionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which EventSubmission to fetch.
     */
    where?: EventSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSubmissions to fetch.
     */
    orderBy?: EventSubmissionOrderByWithRelationInput | EventSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventSubmissions.
     */
    cursor?: EventSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSubmissions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventSubmissions.
     */
    distinct?: EventSubmissionScalarFieldEnum | EventSubmissionScalarFieldEnum[]
  }

  /**
   * EventSubmission findMany
   */
  export type EventSubmissionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
    /**
     * Filter, which EventSubmissions to fetch.
     */
    where?: EventSubmissionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventSubmissions to fetch.
     */
    orderBy?: EventSubmissionOrderByWithRelationInput | EventSubmissionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventSubmissions.
     */
    cursor?: EventSubmissionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventSubmissions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventSubmissions.
     */
    skip?: number
    distinct?: EventSubmissionScalarFieldEnum | EventSubmissionScalarFieldEnum[]
  }

  /**
   * EventSubmission create
   */
  export type EventSubmissionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to create a EventSubmission.
     */
    data: XOR<EventSubmissionCreateInput, EventSubmissionUncheckedCreateInput>
  }

  /**
   * EventSubmission createMany
   */
  export type EventSubmissionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventSubmissions.
     */
    data: EventSubmissionCreateManyInput | EventSubmissionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventSubmission update
   */
  export type EventSubmissionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
    /**
     * The data needed to update a EventSubmission.
     */
    data: XOR<EventSubmissionUpdateInput, EventSubmissionUncheckedUpdateInput>
    /**
     * Choose, which EventSubmission to update.
     */
    where: EventSubmissionWhereUniqueInput
  }

  /**
   * EventSubmission updateMany
   */
  export type EventSubmissionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventSubmissions.
     */
    data: XOR<EventSubmissionUpdateManyMutationInput, EventSubmissionUncheckedUpdateManyInput>
    /**
     * Filter which EventSubmissions to update
     */
    where?: EventSubmissionWhereInput
  }

  /**
   * EventSubmission upsert
   */
  export type EventSubmissionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
    /**
     * The filter to search for the EventSubmission to update in case it exists.
     */
    where: EventSubmissionWhereUniqueInput
    /**
     * In case the EventSubmission found by the `where` argument doesn't exist, create a new EventSubmission with this data.
     */
    create: XOR<EventSubmissionCreateInput, EventSubmissionUncheckedCreateInput>
    /**
     * In case the EventSubmission was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventSubmissionUpdateInput, EventSubmissionUncheckedUpdateInput>
  }

  /**
   * EventSubmission delete
   */
  export type EventSubmissionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
    /**
     * Filter which EventSubmission to delete.
     */
    where: EventSubmissionWhereUniqueInput
  }

  /**
   * EventSubmission deleteMany
   */
  export type EventSubmissionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventSubmissions to delete
     */
    where?: EventSubmissionWhereInput
  }

  /**
   * EventSubmission.team
   */
  export type EventSubmission$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * EventSubmission without action
   */
  export type EventSubmissionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventSubmission
     */
    select?: EventSubmissionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventSubmissionInclude<ExtArgs> | null
  }


  /**
   * Model Challenge
   */

  export type AggregateChallenge = {
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  export type ChallengeAvgAggregateOutputType = {
    durationDays: number | null
    pointsPerDay: number | null
    maxParticipants: number | null
    totalParticipants: number | null
    activeParticipants: number | null
    completionRate: Decimal | null
  }

  export type ChallengeSumAggregateOutputType = {
    durationDays: number | null
    pointsPerDay: number | null
    maxParticipants: number | null
    totalParticipants: number | null
    activeParticipants: number | null
    completionRate: Decimal | null
  }

  export type ChallengeMinAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    challengeType: string | null
    difficulty: string | null
    durationDays: number | null
    startDate: Date | null
    endDate: Date | null
    category: string | null
    pointsPerDay: number | null
    hasLeaderboard: boolean | null
    isPublic: boolean | null
    maxParticipants: number | null
    bannerImage: string | null
    icon: string | null
    status: string | null
    totalParticipants: number | null
    activeParticipants: number | null
    completionRate: Decimal | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengeMaxAggregateOutputType = {
    id: string | null
    title: string | null
    slug: string | null
    description: string | null
    challengeType: string | null
    difficulty: string | null
    durationDays: number | null
    startDate: Date | null
    endDate: Date | null
    category: string | null
    pointsPerDay: number | null
    hasLeaderboard: boolean | null
    isPublic: boolean | null
    maxParticipants: number | null
    bannerImage: string | null
    icon: string | null
    status: string | null
    totalParticipants: number | null
    activeParticipants: number | null
    completionRate: Decimal | null
    createdBy: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ChallengeCountAggregateOutputType = {
    id: number
    title: number
    slug: number
    description: number
    challengeType: number
    difficulty: number
    durationDays: number
    startDate: number
    endDate: number
    category: number
    tags: number
    pointsPerDay: number
    bonusPoints: number
    badges: number
    hasLeaderboard: number
    isPublic: number
    maxParticipants: number
    bannerImage: number
    icon: number
    status: number
    totalParticipants: number
    activeParticipants: number
    completionRate: number
    createdBy: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ChallengeAvgAggregateInputType = {
    durationDays?: true
    pointsPerDay?: true
    maxParticipants?: true
    totalParticipants?: true
    activeParticipants?: true
    completionRate?: true
  }

  export type ChallengeSumAggregateInputType = {
    durationDays?: true
    pointsPerDay?: true
    maxParticipants?: true
    totalParticipants?: true
    activeParticipants?: true
    completionRate?: true
  }

  export type ChallengeMinAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    challengeType?: true
    difficulty?: true
    durationDays?: true
    startDate?: true
    endDate?: true
    category?: true
    pointsPerDay?: true
    hasLeaderboard?: true
    isPublic?: true
    maxParticipants?: true
    bannerImage?: true
    icon?: true
    status?: true
    totalParticipants?: true
    activeParticipants?: true
    completionRate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengeMaxAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    challengeType?: true
    difficulty?: true
    durationDays?: true
    startDate?: true
    endDate?: true
    category?: true
    pointsPerDay?: true
    hasLeaderboard?: true
    isPublic?: true
    maxParticipants?: true
    bannerImage?: true
    icon?: true
    status?: true
    totalParticipants?: true
    activeParticipants?: true
    completionRate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ChallengeCountAggregateInputType = {
    id?: true
    title?: true
    slug?: true
    description?: true
    challengeType?: true
    difficulty?: true
    durationDays?: true
    startDate?: true
    endDate?: true
    category?: true
    tags?: true
    pointsPerDay?: true
    bonusPoints?: true
    badges?: true
    hasLeaderboard?: true
    isPublic?: true
    maxParticipants?: true
    bannerImage?: true
    icon?: true
    status?: true
    totalParticipants?: true
    activeParticipants?: true
    completionRate?: true
    createdBy?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenge to aggregate.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Challenges
    **/
    _count?: true | ChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeMaxAggregateInputType
  }

  export type GetChallengeAggregateType<T extends ChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallenge[P]>
      : GetScalarType<T[P], AggregateChallenge[P]>
  }




  export type ChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeWhereInput
    orderBy?: ChallengeOrderByWithAggregationInput | ChallengeOrderByWithAggregationInput[]
    by: ChallengeScalarFieldEnum[] | ChallengeScalarFieldEnum
    having?: ChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeCountAggregateInputType | true
    _avg?: ChallengeAvgAggregateInputType
    _sum?: ChallengeSumAggregateInputType
    _min?: ChallengeMinAggregateInputType
    _max?: ChallengeMaxAggregateInputType
  }

  export type ChallengeGroupByOutputType = {
    id: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date
    endDate: Date
    category: string | null
    tags: JsonValue | null
    pointsPerDay: number
    bonusPoints: JsonValue | null
    badges: JsonValue | null
    hasLeaderboard: boolean
    isPublic: boolean
    maxParticipants: number | null
    bannerImage: string | null
    icon: string | null
    status: string
    totalParticipants: number
    activeParticipants: number
    completionRate: Decimal | null
    createdBy: string | null
    createdAt: Date
    updatedAt: Date
    _count: ChallengeCountAggregateOutputType | null
    _avg: ChallengeAvgAggregateOutputType | null
    _sum: ChallengeSumAggregateOutputType | null
    _min: ChallengeMinAggregateOutputType | null
    _max: ChallengeMaxAggregateOutputType | null
  }

  type GetChallengeGroupByPayload<T extends ChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    challengeType?: boolean
    difficulty?: boolean
    durationDays?: boolean
    startDate?: boolean
    endDate?: boolean
    category?: boolean
    tags?: boolean
    pointsPerDay?: boolean
    bonusPoints?: boolean
    badges?: boolean
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: boolean
    bannerImage?: boolean
    icon?: boolean
    status?: boolean
    totalParticipants?: boolean
    activeParticipants?: boolean
    completionRate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    creator?: boolean | Challenge$creatorArgs<ExtArgs>
    tasks?: boolean | Challenge$tasksArgs<ExtArgs>
    userProgress?: boolean | Challenge$userProgressArgs<ExtArgs>
    eventChallenges?: boolean | Challenge$eventChallengesArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challenge"]>


  export type ChallengeSelectScalar = {
    id?: boolean
    title?: boolean
    slug?: boolean
    description?: boolean
    challengeType?: boolean
    difficulty?: boolean
    durationDays?: boolean
    startDate?: boolean
    endDate?: boolean
    category?: boolean
    tags?: boolean
    pointsPerDay?: boolean
    bonusPoints?: boolean
    badges?: boolean
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: boolean
    bannerImage?: boolean
    icon?: boolean
    status?: boolean
    totalParticipants?: boolean
    activeParticipants?: boolean
    completionRate?: boolean
    createdBy?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    creator?: boolean | Challenge$creatorArgs<ExtArgs>
    tasks?: boolean | Challenge$tasksArgs<ExtArgs>
    userProgress?: boolean | Challenge$userProgressArgs<ExtArgs>
    eventChallenges?: boolean | Challenge$eventChallengesArgs<ExtArgs>
    _count?: boolean | ChallengeCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Challenge"
    objects: {
      creator: Prisma.$UserPayload<ExtArgs> | null
      tasks: Prisma.$ChallengeTaskPayload<ExtArgs>[]
      userProgress: Prisma.$UserChallengeProgressPayload<ExtArgs>[]
      eventChallenges: Prisma.$EventChallengePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      slug: string
      description: string
      challengeType: string
      difficulty: string
      durationDays: number
      startDate: Date
      endDate: Date
      category: string | null
      tags: Prisma.JsonValue | null
      pointsPerDay: number
      bonusPoints: Prisma.JsonValue | null
      badges: Prisma.JsonValue | null
      hasLeaderboard: boolean
      isPublic: boolean
      maxParticipants: number | null
      bannerImage: string | null
      icon: string | null
      status: string
      totalParticipants: number
      activeParticipants: number
      completionRate: Prisma.Decimal | null
      createdBy: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["challenge"]>
    composites: {}
  }

  type ChallengeGetPayload<S extends boolean | null | undefined | ChallengeDefaultArgs> = $Result.GetResult<Prisma.$ChallengePayload, S>

  type ChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChallengeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChallengeCountAggregateInputType | true
    }

  export interface ChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Challenge'], meta: { name: 'Challenge' } }
    /**
     * Find zero or one Challenge that matches the filter.
     * @param {ChallengeFindUniqueArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeFindUniqueArgs>(args: SelectSubset<T, ChallengeFindUniqueArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Challenge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChallengeFindUniqueOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Challenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeFindFirstArgs>(args?: SelectSubset<T, ChallengeFindFirstArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Challenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindFirstOrThrowArgs} args - Arguments to find a Challenge
     * @example
     * // Get one Challenge
     * const challenge = await prisma.challenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Challenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Challenges
     * const challenges = await prisma.challenge.findMany()
     * 
     * // Get first 10 Challenges
     * const challenges = await prisma.challenge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeWithIdOnly = await prisma.challenge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeFindManyArgs>(args?: SelectSubset<T, ChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Challenge.
     * @param {ChallengeCreateArgs} args - Arguments to create a Challenge.
     * @example
     * // Create one Challenge
     * const Challenge = await prisma.challenge.create({
     *   data: {
     *     // ... data to create a Challenge
     *   }
     * })
     * 
     */
    create<T extends ChallengeCreateArgs>(args: SelectSubset<T, ChallengeCreateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Challenges.
     * @param {ChallengeCreateManyArgs} args - Arguments to create many Challenges.
     * @example
     * // Create many Challenges
     * const challenge = await prisma.challenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeCreateManyArgs>(args?: SelectSubset<T, ChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Challenge.
     * @param {ChallengeDeleteArgs} args - Arguments to delete one Challenge.
     * @example
     * // Delete one Challenge
     * const Challenge = await prisma.challenge.delete({
     *   where: {
     *     // ... filter to delete one Challenge
     *   }
     * })
     * 
     */
    delete<T extends ChallengeDeleteArgs>(args: SelectSubset<T, ChallengeDeleteArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Challenge.
     * @param {ChallengeUpdateArgs} args - Arguments to update one Challenge.
     * @example
     * // Update one Challenge
     * const challenge = await prisma.challenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeUpdateArgs>(args: SelectSubset<T, ChallengeUpdateArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Challenges.
     * @param {ChallengeDeleteManyArgs} args - Arguments to filter Challenges to delete.
     * @example
     * // Delete a few Challenges
     * const { count } = await prisma.challenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeDeleteManyArgs>(args?: SelectSubset<T, ChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Challenges
     * const challenge = await prisma.challenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeUpdateManyArgs>(args: SelectSubset<T, ChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Challenge.
     * @param {ChallengeUpsertArgs} args - Arguments to update or create a Challenge.
     * @example
     * // Update or create a Challenge
     * const challenge = await prisma.challenge.upsert({
     *   create: {
     *     // ... data to create a Challenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Challenge we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeUpsertArgs>(args: SelectSubset<T, ChallengeUpsertArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Challenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeCountArgs} args - Arguments to filter Challenges to count.
     * @example
     * // Count the number of Challenges
     * const count = await prisma.challenge.count({
     *   where: {
     *     // ... the filter for the Challenges we want to count
     *   }
     * })
    **/
    count<T extends ChallengeCountArgs>(
      args?: Subset<T, ChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeAggregateArgs>(args: Subset<T, ChallengeAggregateArgs>): Prisma.PrismaPromise<GetChallengeAggregateType<T>>

    /**
     * Group by Challenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Challenge model
   */
  readonly fields: ChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Challenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    creator<T extends Challenge$creatorArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$creatorArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    tasks<T extends Challenge$tasksArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$tasksArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTaskPayload<ExtArgs>, T, "findMany"> | Null>
    userProgress<T extends Challenge$userProgressArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$userProgressArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengeProgressPayload<ExtArgs>, T, "findMany"> | Null>
    eventChallenges<T extends Challenge$eventChallengesArgs<ExtArgs> = {}>(args?: Subset<T, Challenge$eventChallengesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventChallengePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Challenge model
   */ 
  interface ChallengeFieldRefs {
    readonly id: FieldRef<"Challenge", 'String'>
    readonly title: FieldRef<"Challenge", 'String'>
    readonly slug: FieldRef<"Challenge", 'String'>
    readonly description: FieldRef<"Challenge", 'String'>
    readonly challengeType: FieldRef<"Challenge", 'String'>
    readonly difficulty: FieldRef<"Challenge", 'String'>
    readonly durationDays: FieldRef<"Challenge", 'Int'>
    readonly startDate: FieldRef<"Challenge", 'DateTime'>
    readonly endDate: FieldRef<"Challenge", 'DateTime'>
    readonly category: FieldRef<"Challenge", 'String'>
    readonly tags: FieldRef<"Challenge", 'Json'>
    readonly pointsPerDay: FieldRef<"Challenge", 'Int'>
    readonly bonusPoints: FieldRef<"Challenge", 'Json'>
    readonly badges: FieldRef<"Challenge", 'Json'>
    readonly hasLeaderboard: FieldRef<"Challenge", 'Boolean'>
    readonly isPublic: FieldRef<"Challenge", 'Boolean'>
    readonly maxParticipants: FieldRef<"Challenge", 'Int'>
    readonly bannerImage: FieldRef<"Challenge", 'String'>
    readonly icon: FieldRef<"Challenge", 'String'>
    readonly status: FieldRef<"Challenge", 'String'>
    readonly totalParticipants: FieldRef<"Challenge", 'Int'>
    readonly activeParticipants: FieldRef<"Challenge", 'Int'>
    readonly completionRate: FieldRef<"Challenge", 'Decimal'>
    readonly createdBy: FieldRef<"Challenge", 'String'>
    readonly createdAt: FieldRef<"Challenge", 'DateTime'>
    readonly updatedAt: FieldRef<"Challenge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Challenge findUnique
   */
  export type ChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findUniqueOrThrow
   */
  export type ChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge findFirst
   */
  export type ChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findFirstOrThrow
   */
  export type ChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenge to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Challenges.
     */
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge findMany
   */
  export type ChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter, which Challenges to fetch.
     */
    where?: ChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Challenges to fetch.
     */
    orderBy?: ChallengeOrderByWithRelationInput | ChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Challenges.
     */
    cursor?: ChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Challenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Challenges.
     */
    skip?: number
    distinct?: ChallengeScalarFieldEnum | ChallengeScalarFieldEnum[]
  }

  /**
   * Challenge create
   */
  export type ChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a Challenge.
     */
    data: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
  }

  /**
   * Challenge createMany
   */
  export type ChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Challenges.
     */
    data: ChallengeCreateManyInput | ChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Challenge update
   */
  export type ChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a Challenge.
     */
    data: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
    /**
     * Choose, which Challenge to update.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge updateMany
   */
  export type ChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Challenges.
     */
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyInput>
    /**
     * Filter which Challenges to update
     */
    where?: ChallengeWhereInput
  }

  /**
   * Challenge upsert
   */
  export type ChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the Challenge to update in case it exists.
     */
    where: ChallengeWhereUniqueInput
    /**
     * In case the Challenge found by the `where` argument doesn't exist, create a new Challenge with this data.
     */
    create: XOR<ChallengeCreateInput, ChallengeUncheckedCreateInput>
    /**
     * In case the Challenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeUpdateInput, ChallengeUncheckedUpdateInput>
  }

  /**
   * Challenge delete
   */
  export type ChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
    /**
     * Filter which Challenge to delete.
     */
    where: ChallengeWhereUniqueInput
  }

  /**
   * Challenge deleteMany
   */
  export type ChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Challenges to delete
     */
    where?: ChallengeWhereInput
  }

  /**
   * Challenge.creator
   */
  export type Challenge$creatorArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Challenge.tasks
   */
  export type Challenge$tasksArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTask
     */
    select?: ChallengeTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTaskInclude<ExtArgs> | null
    where?: ChallengeTaskWhereInput
    orderBy?: ChallengeTaskOrderByWithRelationInput | ChallengeTaskOrderByWithRelationInput[]
    cursor?: ChallengeTaskWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ChallengeTaskScalarFieldEnum | ChallengeTaskScalarFieldEnum[]
  }

  /**
   * Challenge.userProgress
   */
  export type Challenge$userProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgress
     */
    select?: UserChallengeProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeProgressInclude<ExtArgs> | null
    where?: UserChallengeProgressWhereInput
    orderBy?: UserChallengeProgressOrderByWithRelationInput | UserChallengeProgressOrderByWithRelationInput[]
    cursor?: UserChallengeProgressWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserChallengeProgressScalarFieldEnum | UserChallengeProgressScalarFieldEnum[]
  }

  /**
   * Challenge.eventChallenges
   */
  export type Challenge$eventChallengesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventChallenge
     */
    select?: EventChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventChallengeInclude<ExtArgs> | null
    where?: EventChallengeWhereInput
    orderBy?: EventChallengeOrderByWithRelationInput | EventChallengeOrderByWithRelationInput[]
    cursor?: EventChallengeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventChallengeScalarFieldEnum | EventChallengeScalarFieldEnum[]
  }

  /**
   * Challenge without action
   */
  export type ChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Challenge
     */
    select?: ChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeInclude<ExtArgs> | null
  }


  /**
   * Model ChallengeTask
   */

  export type AggregateChallengeTask = {
    _count: ChallengeTaskCountAggregateOutputType | null
    _avg: ChallengeTaskAvgAggregateOutputType | null
    _sum: ChallengeTaskSumAggregateOutputType | null
    _min: ChallengeTaskMinAggregateOutputType | null
    _max: ChallengeTaskMaxAggregateOutputType | null
  }

  export type ChallengeTaskAvgAggregateOutputType = {
    dayNumber: number | null
    points: number | null
  }

  export type ChallengeTaskSumAggregateOutputType = {
    dayNumber: number | null
    points: number | null
  }

  export type ChallengeTaskMinAggregateOutputType = {
    id: string | null
    challengeId: string | null
    dayNumber: number | null
    title: string | null
    description: string | null
    taskType: string | null
    difficulty: string | null
    points: number | null
    autoValidate: boolean | null
    validationUrl: string | null
    createdAt: Date | null
  }

  export type ChallengeTaskMaxAggregateOutputType = {
    id: string | null
    challengeId: string | null
    dayNumber: number | null
    title: string | null
    description: string | null
    taskType: string | null
    difficulty: string | null
    points: number | null
    autoValidate: boolean | null
    validationUrl: string | null
    createdAt: Date | null
  }

  export type ChallengeTaskCountAggregateOutputType = {
    id: number
    challengeId: number
    dayNumber: number
    title: number
    description: number
    taskType: number
    content: number
    resourceLinks: number
    hints: number
    difficulty: number
    points: number
    autoValidate: number
    validationUrl: number
    createdAt: number
    _all: number
  }


  export type ChallengeTaskAvgAggregateInputType = {
    dayNumber?: true
    points?: true
  }

  export type ChallengeTaskSumAggregateInputType = {
    dayNumber?: true
    points?: true
  }

  export type ChallengeTaskMinAggregateInputType = {
    id?: true
    challengeId?: true
    dayNumber?: true
    title?: true
    description?: true
    taskType?: true
    difficulty?: true
    points?: true
    autoValidate?: true
    validationUrl?: true
    createdAt?: true
  }

  export type ChallengeTaskMaxAggregateInputType = {
    id?: true
    challengeId?: true
    dayNumber?: true
    title?: true
    description?: true
    taskType?: true
    difficulty?: true
    points?: true
    autoValidate?: true
    validationUrl?: true
    createdAt?: true
  }

  export type ChallengeTaskCountAggregateInputType = {
    id?: true
    challengeId?: true
    dayNumber?: true
    title?: true
    description?: true
    taskType?: true
    content?: true
    resourceLinks?: true
    hints?: true
    difficulty?: true
    points?: true
    autoValidate?: true
    validationUrl?: true
    createdAt?: true
    _all?: true
  }

  export type ChallengeTaskAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeTask to aggregate.
     */
    where?: ChallengeTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTasks to fetch.
     */
    orderBy?: ChallengeTaskOrderByWithRelationInput | ChallengeTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ChallengeTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ChallengeTasks
    **/
    _count?: true | ChallengeTaskCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ChallengeTaskAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ChallengeTaskSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ChallengeTaskMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ChallengeTaskMaxAggregateInputType
  }

  export type GetChallengeTaskAggregateType<T extends ChallengeTaskAggregateArgs> = {
        [P in keyof T & keyof AggregateChallengeTask]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChallengeTask[P]>
      : GetScalarType<T[P], AggregateChallengeTask[P]>
  }




  export type ChallengeTaskGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ChallengeTaskWhereInput
    orderBy?: ChallengeTaskOrderByWithAggregationInput | ChallengeTaskOrderByWithAggregationInput[]
    by: ChallengeTaskScalarFieldEnum[] | ChallengeTaskScalarFieldEnum
    having?: ChallengeTaskScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ChallengeTaskCountAggregateInputType | true
    _avg?: ChallengeTaskAvgAggregateInputType
    _sum?: ChallengeTaskSumAggregateInputType
    _min?: ChallengeTaskMinAggregateInputType
    _max?: ChallengeTaskMaxAggregateInputType
  }

  export type ChallengeTaskGroupByOutputType = {
    id: string
    challengeId: string
    dayNumber: number
    title: string
    description: string | null
    taskType: string
    content: JsonValue | null
    resourceLinks: JsonValue | null
    hints: JsonValue | null
    difficulty: string | null
    points: number
    autoValidate: boolean
    validationUrl: string | null
    createdAt: Date
    _count: ChallengeTaskCountAggregateOutputType | null
    _avg: ChallengeTaskAvgAggregateOutputType | null
    _sum: ChallengeTaskSumAggregateOutputType | null
    _min: ChallengeTaskMinAggregateOutputType | null
    _max: ChallengeTaskMaxAggregateOutputType | null
  }

  type GetChallengeTaskGroupByPayload<T extends ChallengeTaskGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ChallengeTaskGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ChallengeTaskGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ChallengeTaskGroupByOutputType[P]>
            : GetScalarType<T[P], ChallengeTaskGroupByOutputType[P]>
        }
      >
    >


  export type ChallengeTaskSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    challengeId?: boolean
    dayNumber?: boolean
    title?: boolean
    description?: boolean
    taskType?: boolean
    content?: boolean
    resourceLinks?: boolean
    hints?: boolean
    difficulty?: boolean
    points?: boolean
    autoValidate?: boolean
    validationUrl?: boolean
    createdAt?: boolean
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    completions?: boolean | ChallengeTask$completionsArgs<ExtArgs>
    _count?: boolean | ChallengeTaskCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["challengeTask"]>


  export type ChallengeTaskSelectScalar = {
    id?: boolean
    challengeId?: boolean
    dayNumber?: boolean
    title?: boolean
    description?: boolean
    taskType?: boolean
    content?: boolean
    resourceLinks?: boolean
    hints?: boolean
    difficulty?: boolean
    points?: boolean
    autoValidate?: boolean
    validationUrl?: boolean
    createdAt?: boolean
  }

  export type ChallengeTaskInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    completions?: boolean | ChallengeTask$completionsArgs<ExtArgs>
    _count?: boolean | ChallengeTaskCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $ChallengeTaskPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ChallengeTask"
    objects: {
      challenge: Prisma.$ChallengePayload<ExtArgs>
      completions: Prisma.$UserTaskCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      challengeId: string
      dayNumber: number
      title: string
      description: string | null
      taskType: string
      content: Prisma.JsonValue | null
      resourceLinks: Prisma.JsonValue | null
      hints: Prisma.JsonValue | null
      difficulty: string | null
      points: number
      autoValidate: boolean
      validationUrl: string | null
      createdAt: Date
    }, ExtArgs["result"]["challengeTask"]>
    composites: {}
  }

  type ChallengeTaskGetPayload<S extends boolean | null | undefined | ChallengeTaskDefaultArgs> = $Result.GetResult<Prisma.$ChallengeTaskPayload, S>

  type ChallengeTaskCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ChallengeTaskFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ChallengeTaskCountAggregateInputType | true
    }

  export interface ChallengeTaskDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ChallengeTask'], meta: { name: 'ChallengeTask' } }
    /**
     * Find zero or one ChallengeTask that matches the filter.
     * @param {ChallengeTaskFindUniqueArgs} args - Arguments to find a ChallengeTask
     * @example
     * // Get one ChallengeTask
     * const challengeTask = await prisma.challengeTask.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ChallengeTaskFindUniqueArgs>(args: SelectSubset<T, ChallengeTaskFindUniqueArgs<ExtArgs>>): Prisma__ChallengeTaskClient<$Result.GetResult<Prisma.$ChallengeTaskPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ChallengeTask that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ChallengeTaskFindUniqueOrThrowArgs} args - Arguments to find a ChallengeTask
     * @example
     * // Get one ChallengeTask
     * const challengeTask = await prisma.challengeTask.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ChallengeTaskFindUniqueOrThrowArgs>(args: SelectSubset<T, ChallengeTaskFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ChallengeTaskClient<$Result.GetResult<Prisma.$ChallengeTaskPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ChallengeTask that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTaskFindFirstArgs} args - Arguments to find a ChallengeTask
     * @example
     * // Get one ChallengeTask
     * const challengeTask = await prisma.challengeTask.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ChallengeTaskFindFirstArgs>(args?: SelectSubset<T, ChallengeTaskFindFirstArgs<ExtArgs>>): Prisma__ChallengeTaskClient<$Result.GetResult<Prisma.$ChallengeTaskPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ChallengeTask that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTaskFindFirstOrThrowArgs} args - Arguments to find a ChallengeTask
     * @example
     * // Get one ChallengeTask
     * const challengeTask = await prisma.challengeTask.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ChallengeTaskFindFirstOrThrowArgs>(args?: SelectSubset<T, ChallengeTaskFindFirstOrThrowArgs<ExtArgs>>): Prisma__ChallengeTaskClient<$Result.GetResult<Prisma.$ChallengeTaskPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ChallengeTasks that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTaskFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ChallengeTasks
     * const challengeTasks = await prisma.challengeTask.findMany()
     * 
     * // Get first 10 ChallengeTasks
     * const challengeTasks = await prisma.challengeTask.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const challengeTaskWithIdOnly = await prisma.challengeTask.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ChallengeTaskFindManyArgs>(args?: SelectSubset<T, ChallengeTaskFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ChallengeTaskPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ChallengeTask.
     * @param {ChallengeTaskCreateArgs} args - Arguments to create a ChallengeTask.
     * @example
     * // Create one ChallengeTask
     * const ChallengeTask = await prisma.challengeTask.create({
     *   data: {
     *     // ... data to create a ChallengeTask
     *   }
     * })
     * 
     */
    create<T extends ChallengeTaskCreateArgs>(args: SelectSubset<T, ChallengeTaskCreateArgs<ExtArgs>>): Prisma__ChallengeTaskClient<$Result.GetResult<Prisma.$ChallengeTaskPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ChallengeTasks.
     * @param {ChallengeTaskCreateManyArgs} args - Arguments to create many ChallengeTasks.
     * @example
     * // Create many ChallengeTasks
     * const challengeTask = await prisma.challengeTask.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ChallengeTaskCreateManyArgs>(args?: SelectSubset<T, ChallengeTaskCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a ChallengeTask.
     * @param {ChallengeTaskDeleteArgs} args - Arguments to delete one ChallengeTask.
     * @example
     * // Delete one ChallengeTask
     * const ChallengeTask = await prisma.challengeTask.delete({
     *   where: {
     *     // ... filter to delete one ChallengeTask
     *   }
     * })
     * 
     */
    delete<T extends ChallengeTaskDeleteArgs>(args: SelectSubset<T, ChallengeTaskDeleteArgs<ExtArgs>>): Prisma__ChallengeTaskClient<$Result.GetResult<Prisma.$ChallengeTaskPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ChallengeTask.
     * @param {ChallengeTaskUpdateArgs} args - Arguments to update one ChallengeTask.
     * @example
     * // Update one ChallengeTask
     * const challengeTask = await prisma.challengeTask.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ChallengeTaskUpdateArgs>(args: SelectSubset<T, ChallengeTaskUpdateArgs<ExtArgs>>): Prisma__ChallengeTaskClient<$Result.GetResult<Prisma.$ChallengeTaskPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ChallengeTasks.
     * @param {ChallengeTaskDeleteManyArgs} args - Arguments to filter ChallengeTasks to delete.
     * @example
     * // Delete a few ChallengeTasks
     * const { count } = await prisma.challengeTask.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ChallengeTaskDeleteManyArgs>(args?: SelectSubset<T, ChallengeTaskDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ChallengeTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTaskUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ChallengeTasks
     * const challengeTask = await prisma.challengeTask.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ChallengeTaskUpdateManyArgs>(args: SelectSubset<T, ChallengeTaskUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ChallengeTask.
     * @param {ChallengeTaskUpsertArgs} args - Arguments to update or create a ChallengeTask.
     * @example
     * // Update or create a ChallengeTask
     * const challengeTask = await prisma.challengeTask.upsert({
     *   create: {
     *     // ... data to create a ChallengeTask
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ChallengeTask we want to update
     *   }
     * })
     */
    upsert<T extends ChallengeTaskUpsertArgs>(args: SelectSubset<T, ChallengeTaskUpsertArgs<ExtArgs>>): Prisma__ChallengeTaskClient<$Result.GetResult<Prisma.$ChallengeTaskPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ChallengeTasks.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTaskCountArgs} args - Arguments to filter ChallengeTasks to count.
     * @example
     * // Count the number of ChallengeTasks
     * const count = await prisma.challengeTask.count({
     *   where: {
     *     // ... the filter for the ChallengeTasks we want to count
     *   }
     * })
    **/
    count<T extends ChallengeTaskCountArgs>(
      args?: Subset<T, ChallengeTaskCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ChallengeTaskCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ChallengeTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTaskAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ChallengeTaskAggregateArgs>(args: Subset<T, ChallengeTaskAggregateArgs>): Prisma.PrismaPromise<GetChallengeTaskAggregateType<T>>

    /**
     * Group by ChallengeTask.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ChallengeTaskGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ChallengeTaskGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ChallengeTaskGroupByArgs['orderBy'] }
        : { orderBy?: ChallengeTaskGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ChallengeTaskGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChallengeTaskGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ChallengeTask model
   */
  readonly fields: ChallengeTaskFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ChallengeTask.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ChallengeTaskClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    completions<T extends ChallengeTask$completionsArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTask$completionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTaskCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ChallengeTask model
   */ 
  interface ChallengeTaskFieldRefs {
    readonly id: FieldRef<"ChallengeTask", 'String'>
    readonly challengeId: FieldRef<"ChallengeTask", 'String'>
    readonly dayNumber: FieldRef<"ChallengeTask", 'Int'>
    readonly title: FieldRef<"ChallengeTask", 'String'>
    readonly description: FieldRef<"ChallengeTask", 'String'>
    readonly taskType: FieldRef<"ChallengeTask", 'String'>
    readonly content: FieldRef<"ChallengeTask", 'Json'>
    readonly resourceLinks: FieldRef<"ChallengeTask", 'Json'>
    readonly hints: FieldRef<"ChallengeTask", 'Json'>
    readonly difficulty: FieldRef<"ChallengeTask", 'String'>
    readonly points: FieldRef<"ChallengeTask", 'Int'>
    readonly autoValidate: FieldRef<"ChallengeTask", 'Boolean'>
    readonly validationUrl: FieldRef<"ChallengeTask", 'String'>
    readonly createdAt: FieldRef<"ChallengeTask", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ChallengeTask findUnique
   */
  export type ChallengeTaskFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTask
     */
    select?: ChallengeTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTaskInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTask to fetch.
     */
    where: ChallengeTaskWhereUniqueInput
  }

  /**
   * ChallengeTask findUniqueOrThrow
   */
  export type ChallengeTaskFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTask
     */
    select?: ChallengeTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTaskInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTask to fetch.
     */
    where: ChallengeTaskWhereUniqueInput
  }

  /**
   * ChallengeTask findFirst
   */
  export type ChallengeTaskFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTask
     */
    select?: ChallengeTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTaskInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTask to fetch.
     */
    where?: ChallengeTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTasks to fetch.
     */
    orderBy?: ChallengeTaskOrderByWithRelationInput | ChallengeTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeTasks.
     */
    cursor?: ChallengeTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeTasks.
     */
    distinct?: ChallengeTaskScalarFieldEnum | ChallengeTaskScalarFieldEnum[]
  }

  /**
   * ChallengeTask findFirstOrThrow
   */
  export type ChallengeTaskFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTask
     */
    select?: ChallengeTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTaskInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTask to fetch.
     */
    where?: ChallengeTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTasks to fetch.
     */
    orderBy?: ChallengeTaskOrderByWithRelationInput | ChallengeTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ChallengeTasks.
     */
    cursor?: ChallengeTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTasks.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ChallengeTasks.
     */
    distinct?: ChallengeTaskScalarFieldEnum | ChallengeTaskScalarFieldEnum[]
  }

  /**
   * ChallengeTask findMany
   */
  export type ChallengeTaskFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTask
     */
    select?: ChallengeTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTaskInclude<ExtArgs> | null
    /**
     * Filter, which ChallengeTasks to fetch.
     */
    where?: ChallengeTaskWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ChallengeTasks to fetch.
     */
    orderBy?: ChallengeTaskOrderByWithRelationInput | ChallengeTaskOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ChallengeTasks.
     */
    cursor?: ChallengeTaskWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ChallengeTasks from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ChallengeTasks.
     */
    skip?: number
    distinct?: ChallengeTaskScalarFieldEnum | ChallengeTaskScalarFieldEnum[]
  }

  /**
   * ChallengeTask create
   */
  export type ChallengeTaskCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTask
     */
    select?: ChallengeTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTaskInclude<ExtArgs> | null
    /**
     * The data needed to create a ChallengeTask.
     */
    data: XOR<ChallengeTaskCreateInput, ChallengeTaskUncheckedCreateInput>
  }

  /**
   * ChallengeTask createMany
   */
  export type ChallengeTaskCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ChallengeTasks.
     */
    data: ChallengeTaskCreateManyInput | ChallengeTaskCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ChallengeTask update
   */
  export type ChallengeTaskUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTask
     */
    select?: ChallengeTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTaskInclude<ExtArgs> | null
    /**
     * The data needed to update a ChallengeTask.
     */
    data: XOR<ChallengeTaskUpdateInput, ChallengeTaskUncheckedUpdateInput>
    /**
     * Choose, which ChallengeTask to update.
     */
    where: ChallengeTaskWhereUniqueInput
  }

  /**
   * ChallengeTask updateMany
   */
  export type ChallengeTaskUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ChallengeTasks.
     */
    data: XOR<ChallengeTaskUpdateManyMutationInput, ChallengeTaskUncheckedUpdateManyInput>
    /**
     * Filter which ChallengeTasks to update
     */
    where?: ChallengeTaskWhereInput
  }

  /**
   * ChallengeTask upsert
   */
  export type ChallengeTaskUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTask
     */
    select?: ChallengeTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTaskInclude<ExtArgs> | null
    /**
     * The filter to search for the ChallengeTask to update in case it exists.
     */
    where: ChallengeTaskWhereUniqueInput
    /**
     * In case the ChallengeTask found by the `where` argument doesn't exist, create a new ChallengeTask with this data.
     */
    create: XOR<ChallengeTaskCreateInput, ChallengeTaskUncheckedCreateInput>
    /**
     * In case the ChallengeTask was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ChallengeTaskUpdateInput, ChallengeTaskUncheckedUpdateInput>
  }

  /**
   * ChallengeTask delete
   */
  export type ChallengeTaskDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTask
     */
    select?: ChallengeTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTaskInclude<ExtArgs> | null
    /**
     * Filter which ChallengeTask to delete.
     */
    where: ChallengeTaskWhereUniqueInput
  }

  /**
   * ChallengeTask deleteMany
   */
  export type ChallengeTaskDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ChallengeTasks to delete
     */
    where?: ChallengeTaskWhereInput
  }

  /**
   * ChallengeTask.completions
   */
  export type ChallengeTask$completionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
    where?: UserTaskCompletionWhereInput
    orderBy?: UserTaskCompletionOrderByWithRelationInput | UserTaskCompletionOrderByWithRelationInput[]
    cursor?: UserTaskCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTaskCompletionScalarFieldEnum | UserTaskCompletionScalarFieldEnum[]
  }

  /**
   * ChallengeTask without action
   */
  export type ChallengeTaskDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ChallengeTask
     */
    select?: ChallengeTaskSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ChallengeTaskInclude<ExtArgs> | null
  }


  /**
   * Model UserChallengeProgress
   */

  export type AggregateUserChallengeProgress = {
    _count: UserChallengeProgressCountAggregateOutputType | null
    _avg: UserChallengeProgressAvgAggregateOutputType | null
    _sum: UserChallengeProgressSumAggregateOutputType | null
    _min: UserChallengeProgressMinAggregateOutputType | null
    _max: UserChallengeProgressMaxAggregateOutputType | null
  }

  export type UserChallengeProgressAvgAggregateOutputType = {
    completedDays: number | null
    totalDays: number | null
    completionPercentage: Decimal | null
    currentStreak: number | null
    longestStreak: number | null
    totalPoints: number | null
    bonusPoints: number | null
    currentRank: number | null
  }

  export type UserChallengeProgressSumAggregateOutputType = {
    completedDays: number | null
    totalDays: number | null
    completionPercentage: Decimal | null
    currentStreak: number | null
    longestStreak: number | null
    totalPoints: number | null
    bonusPoints: number | null
    currentRank: number | null
  }

  export type UserChallengeProgressMinAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    status: string | null
    completedDays: number | null
    totalDays: number | null
    completionPercentage: Decimal | null
    currentStreak: number | null
    longestStreak: number | null
    lastCompletedDate: Date | null
    totalPoints: number | null
    bonusPoints: number | null
    currentRank: number | null
    startedAt: Date | null
    lastActivity: Date | null
    completedAt: Date | null
    certificateIssued: boolean | null
    certificateUrl: string | null
  }

  export type UserChallengeProgressMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    status: string | null
    completedDays: number | null
    totalDays: number | null
    completionPercentage: Decimal | null
    currentStreak: number | null
    longestStreak: number | null
    lastCompletedDate: Date | null
    totalPoints: number | null
    bonusPoints: number | null
    currentRank: number | null
    startedAt: Date | null
    lastActivity: Date | null
    completedAt: Date | null
    certificateIssued: boolean | null
    certificateUrl: string | null
  }

  export type UserChallengeProgressCountAggregateOutputType = {
    id: number
    userId: number
    challengeId: number
    status: number
    completedDays: number
    totalDays: number
    completionPercentage: number
    currentStreak: number
    longestStreak: number
    lastCompletedDate: number
    totalPoints: number
    bonusPoints: number
    currentRank: number
    startedAt: number
    lastActivity: number
    completedAt: number
    certificateIssued: number
    certificateUrl: number
    completedTaskIds: number
    skippedTaskIds: number
    _all: number
  }


  export type UserChallengeProgressAvgAggregateInputType = {
    completedDays?: true
    totalDays?: true
    completionPercentage?: true
    currentStreak?: true
    longestStreak?: true
    totalPoints?: true
    bonusPoints?: true
    currentRank?: true
  }

  export type UserChallengeProgressSumAggregateInputType = {
    completedDays?: true
    totalDays?: true
    completionPercentage?: true
    currentStreak?: true
    longestStreak?: true
    totalPoints?: true
    bonusPoints?: true
    currentRank?: true
  }

  export type UserChallengeProgressMinAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    status?: true
    completedDays?: true
    totalDays?: true
    completionPercentage?: true
    currentStreak?: true
    longestStreak?: true
    lastCompletedDate?: true
    totalPoints?: true
    bonusPoints?: true
    currentRank?: true
    startedAt?: true
    lastActivity?: true
    completedAt?: true
    certificateIssued?: true
    certificateUrl?: true
  }

  export type UserChallengeProgressMaxAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    status?: true
    completedDays?: true
    totalDays?: true
    completionPercentage?: true
    currentStreak?: true
    longestStreak?: true
    lastCompletedDate?: true
    totalPoints?: true
    bonusPoints?: true
    currentRank?: true
    startedAt?: true
    lastActivity?: true
    completedAt?: true
    certificateIssued?: true
    certificateUrl?: true
  }

  export type UserChallengeProgressCountAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    status?: true
    completedDays?: true
    totalDays?: true
    completionPercentage?: true
    currentStreak?: true
    longestStreak?: true
    lastCompletedDate?: true
    totalPoints?: true
    bonusPoints?: true
    currentRank?: true
    startedAt?: true
    lastActivity?: true
    completedAt?: true
    certificateIssued?: true
    certificateUrl?: true
    completedTaskIds?: true
    skippedTaskIds?: true
    _all?: true
  }

  export type UserChallengeProgressAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserChallengeProgress to aggregate.
     */
    where?: UserChallengeProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallengeProgresses to fetch.
     */
    orderBy?: UserChallengeProgressOrderByWithRelationInput | UserChallengeProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserChallengeProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallengeProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallengeProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserChallengeProgresses
    **/
    _count?: true | UserChallengeProgressCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserChallengeProgressAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserChallengeProgressSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserChallengeProgressMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserChallengeProgressMaxAggregateInputType
  }

  export type GetUserChallengeProgressAggregateType<T extends UserChallengeProgressAggregateArgs> = {
        [P in keyof T & keyof AggregateUserChallengeProgress]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserChallengeProgress[P]>
      : GetScalarType<T[P], AggregateUserChallengeProgress[P]>
  }




  export type UserChallengeProgressGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserChallengeProgressWhereInput
    orderBy?: UserChallengeProgressOrderByWithAggregationInput | UserChallengeProgressOrderByWithAggregationInput[]
    by: UserChallengeProgressScalarFieldEnum[] | UserChallengeProgressScalarFieldEnum
    having?: UserChallengeProgressScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserChallengeProgressCountAggregateInputType | true
    _avg?: UserChallengeProgressAvgAggregateInputType
    _sum?: UserChallengeProgressSumAggregateInputType
    _min?: UserChallengeProgressMinAggregateInputType
    _max?: UserChallengeProgressMaxAggregateInputType
  }

  export type UserChallengeProgressGroupByOutputType = {
    id: string
    userId: string
    challengeId: string
    status: string
    completedDays: number
    totalDays: number
    completionPercentage: Decimal
    currentStreak: number
    longestStreak: number
    lastCompletedDate: Date | null
    totalPoints: number
    bonusPoints: number
    currentRank: number | null
    startedAt: Date
    lastActivity: Date
    completedAt: Date | null
    certificateIssued: boolean
    certificateUrl: string | null
    completedTaskIds: JsonValue | null
    skippedTaskIds: JsonValue | null
    _count: UserChallengeProgressCountAggregateOutputType | null
    _avg: UserChallengeProgressAvgAggregateOutputType | null
    _sum: UserChallengeProgressSumAggregateOutputType | null
    _min: UserChallengeProgressMinAggregateOutputType | null
    _max: UserChallengeProgressMaxAggregateOutputType | null
  }

  type GetUserChallengeProgressGroupByPayload<T extends UserChallengeProgressGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserChallengeProgressGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserChallengeProgressGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserChallengeProgressGroupByOutputType[P]>
            : GetScalarType<T[P], UserChallengeProgressGroupByOutputType[P]>
        }
      >
    >


  export type UserChallengeProgressSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    status?: boolean
    completedDays?: boolean
    totalDays?: boolean
    completionPercentage?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastCompletedDate?: boolean
    totalPoints?: boolean
    bonusPoints?: boolean
    currentRank?: boolean
    startedAt?: boolean
    lastActivity?: boolean
    completedAt?: boolean
    certificateIssued?: boolean
    certificateUrl?: boolean
    completedTaskIds?: boolean
    skippedTaskIds?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    taskCompletions?: boolean | UserChallengeProgress$taskCompletionsArgs<ExtArgs>
    _count?: boolean | UserChallengeProgressCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userChallengeProgress"]>


  export type UserChallengeProgressSelectScalar = {
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    status?: boolean
    completedDays?: boolean
    totalDays?: boolean
    completionPercentage?: boolean
    currentStreak?: boolean
    longestStreak?: boolean
    lastCompletedDate?: boolean
    totalPoints?: boolean
    bonusPoints?: boolean
    currentRank?: boolean
    startedAt?: boolean
    lastActivity?: boolean
    completedAt?: boolean
    certificateIssued?: boolean
    certificateUrl?: boolean
    completedTaskIds?: boolean
    skippedTaskIds?: boolean
  }

  export type UserChallengeProgressInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
    taskCompletions?: boolean | UserChallengeProgress$taskCompletionsArgs<ExtArgs>
    _count?: boolean | UserChallengeProgressCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $UserChallengeProgressPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserChallengeProgress"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      challenge: Prisma.$ChallengePayload<ExtArgs>
      taskCompletions: Prisma.$UserTaskCompletionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      challengeId: string
      status: string
      completedDays: number
      totalDays: number
      completionPercentage: Prisma.Decimal
      currentStreak: number
      longestStreak: number
      lastCompletedDate: Date | null
      totalPoints: number
      bonusPoints: number
      currentRank: number | null
      startedAt: Date
      lastActivity: Date
      completedAt: Date | null
      certificateIssued: boolean
      certificateUrl: string | null
      completedTaskIds: Prisma.JsonValue | null
      skippedTaskIds: Prisma.JsonValue | null
    }, ExtArgs["result"]["userChallengeProgress"]>
    composites: {}
  }

  type UserChallengeProgressGetPayload<S extends boolean | null | undefined | UserChallengeProgressDefaultArgs> = $Result.GetResult<Prisma.$UserChallengeProgressPayload, S>

  type UserChallengeProgressCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserChallengeProgressFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserChallengeProgressCountAggregateInputType | true
    }

  export interface UserChallengeProgressDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserChallengeProgress'], meta: { name: 'UserChallengeProgress' } }
    /**
     * Find zero or one UserChallengeProgress that matches the filter.
     * @param {UserChallengeProgressFindUniqueArgs} args - Arguments to find a UserChallengeProgress
     * @example
     * // Get one UserChallengeProgress
     * const userChallengeProgress = await prisma.userChallengeProgress.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserChallengeProgressFindUniqueArgs>(args: SelectSubset<T, UserChallengeProgressFindUniqueArgs<ExtArgs>>): Prisma__UserChallengeProgressClient<$Result.GetResult<Prisma.$UserChallengeProgressPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserChallengeProgress that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserChallengeProgressFindUniqueOrThrowArgs} args - Arguments to find a UserChallengeProgress
     * @example
     * // Get one UserChallengeProgress
     * const userChallengeProgress = await prisma.userChallengeProgress.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserChallengeProgressFindUniqueOrThrowArgs>(args: SelectSubset<T, UserChallengeProgressFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserChallengeProgressClient<$Result.GetResult<Prisma.$UserChallengeProgressPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserChallengeProgress that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeProgressFindFirstArgs} args - Arguments to find a UserChallengeProgress
     * @example
     * // Get one UserChallengeProgress
     * const userChallengeProgress = await prisma.userChallengeProgress.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserChallengeProgressFindFirstArgs>(args?: SelectSubset<T, UserChallengeProgressFindFirstArgs<ExtArgs>>): Prisma__UserChallengeProgressClient<$Result.GetResult<Prisma.$UserChallengeProgressPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserChallengeProgress that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeProgressFindFirstOrThrowArgs} args - Arguments to find a UserChallengeProgress
     * @example
     * // Get one UserChallengeProgress
     * const userChallengeProgress = await prisma.userChallengeProgress.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserChallengeProgressFindFirstOrThrowArgs>(args?: SelectSubset<T, UserChallengeProgressFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserChallengeProgressClient<$Result.GetResult<Prisma.$UserChallengeProgressPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserChallengeProgresses that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeProgressFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserChallengeProgresses
     * const userChallengeProgresses = await prisma.userChallengeProgress.findMany()
     * 
     * // Get first 10 UserChallengeProgresses
     * const userChallengeProgresses = await prisma.userChallengeProgress.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userChallengeProgressWithIdOnly = await prisma.userChallengeProgress.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserChallengeProgressFindManyArgs>(args?: SelectSubset<T, UserChallengeProgressFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserChallengeProgressPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserChallengeProgress.
     * @param {UserChallengeProgressCreateArgs} args - Arguments to create a UserChallengeProgress.
     * @example
     * // Create one UserChallengeProgress
     * const UserChallengeProgress = await prisma.userChallengeProgress.create({
     *   data: {
     *     // ... data to create a UserChallengeProgress
     *   }
     * })
     * 
     */
    create<T extends UserChallengeProgressCreateArgs>(args: SelectSubset<T, UserChallengeProgressCreateArgs<ExtArgs>>): Prisma__UserChallengeProgressClient<$Result.GetResult<Prisma.$UserChallengeProgressPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserChallengeProgresses.
     * @param {UserChallengeProgressCreateManyArgs} args - Arguments to create many UserChallengeProgresses.
     * @example
     * // Create many UserChallengeProgresses
     * const userChallengeProgress = await prisma.userChallengeProgress.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserChallengeProgressCreateManyArgs>(args?: SelectSubset<T, UserChallengeProgressCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserChallengeProgress.
     * @param {UserChallengeProgressDeleteArgs} args - Arguments to delete one UserChallengeProgress.
     * @example
     * // Delete one UserChallengeProgress
     * const UserChallengeProgress = await prisma.userChallengeProgress.delete({
     *   where: {
     *     // ... filter to delete one UserChallengeProgress
     *   }
     * })
     * 
     */
    delete<T extends UserChallengeProgressDeleteArgs>(args: SelectSubset<T, UserChallengeProgressDeleteArgs<ExtArgs>>): Prisma__UserChallengeProgressClient<$Result.GetResult<Prisma.$UserChallengeProgressPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserChallengeProgress.
     * @param {UserChallengeProgressUpdateArgs} args - Arguments to update one UserChallengeProgress.
     * @example
     * // Update one UserChallengeProgress
     * const userChallengeProgress = await prisma.userChallengeProgress.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserChallengeProgressUpdateArgs>(args: SelectSubset<T, UserChallengeProgressUpdateArgs<ExtArgs>>): Prisma__UserChallengeProgressClient<$Result.GetResult<Prisma.$UserChallengeProgressPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserChallengeProgresses.
     * @param {UserChallengeProgressDeleteManyArgs} args - Arguments to filter UserChallengeProgresses to delete.
     * @example
     * // Delete a few UserChallengeProgresses
     * const { count } = await prisma.userChallengeProgress.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserChallengeProgressDeleteManyArgs>(args?: SelectSubset<T, UserChallengeProgressDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserChallengeProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeProgressUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserChallengeProgresses
     * const userChallengeProgress = await prisma.userChallengeProgress.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserChallengeProgressUpdateManyArgs>(args: SelectSubset<T, UserChallengeProgressUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserChallengeProgress.
     * @param {UserChallengeProgressUpsertArgs} args - Arguments to update or create a UserChallengeProgress.
     * @example
     * // Update or create a UserChallengeProgress
     * const userChallengeProgress = await prisma.userChallengeProgress.upsert({
     *   create: {
     *     // ... data to create a UserChallengeProgress
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserChallengeProgress we want to update
     *   }
     * })
     */
    upsert<T extends UserChallengeProgressUpsertArgs>(args: SelectSubset<T, UserChallengeProgressUpsertArgs<ExtArgs>>): Prisma__UserChallengeProgressClient<$Result.GetResult<Prisma.$UserChallengeProgressPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserChallengeProgresses.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeProgressCountArgs} args - Arguments to filter UserChallengeProgresses to count.
     * @example
     * // Count the number of UserChallengeProgresses
     * const count = await prisma.userChallengeProgress.count({
     *   where: {
     *     // ... the filter for the UserChallengeProgresses we want to count
     *   }
     * })
    **/
    count<T extends UserChallengeProgressCountArgs>(
      args?: Subset<T, UserChallengeProgressCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserChallengeProgressCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserChallengeProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeProgressAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserChallengeProgressAggregateArgs>(args: Subset<T, UserChallengeProgressAggregateArgs>): Prisma.PrismaPromise<GetUserChallengeProgressAggregateType<T>>

    /**
     * Group by UserChallengeProgress.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserChallengeProgressGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserChallengeProgressGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserChallengeProgressGroupByArgs['orderBy'] }
        : { orderBy?: UserChallengeProgressGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserChallengeProgressGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserChallengeProgressGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserChallengeProgress model
   */
  readonly fields: UserChallengeProgressFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserChallengeProgress.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserChallengeProgressClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    taskCompletions<T extends UserChallengeProgress$taskCompletionsArgs<ExtArgs> = {}>(args?: Subset<T, UserChallengeProgress$taskCompletionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTaskCompletionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserChallengeProgress model
   */ 
  interface UserChallengeProgressFieldRefs {
    readonly id: FieldRef<"UserChallengeProgress", 'String'>
    readonly userId: FieldRef<"UserChallengeProgress", 'String'>
    readonly challengeId: FieldRef<"UserChallengeProgress", 'String'>
    readonly status: FieldRef<"UserChallengeProgress", 'String'>
    readonly completedDays: FieldRef<"UserChallengeProgress", 'Int'>
    readonly totalDays: FieldRef<"UserChallengeProgress", 'Int'>
    readonly completionPercentage: FieldRef<"UserChallengeProgress", 'Decimal'>
    readonly currentStreak: FieldRef<"UserChallengeProgress", 'Int'>
    readonly longestStreak: FieldRef<"UserChallengeProgress", 'Int'>
    readonly lastCompletedDate: FieldRef<"UserChallengeProgress", 'DateTime'>
    readonly totalPoints: FieldRef<"UserChallengeProgress", 'Int'>
    readonly bonusPoints: FieldRef<"UserChallengeProgress", 'Int'>
    readonly currentRank: FieldRef<"UserChallengeProgress", 'Int'>
    readonly startedAt: FieldRef<"UserChallengeProgress", 'DateTime'>
    readonly lastActivity: FieldRef<"UserChallengeProgress", 'DateTime'>
    readonly completedAt: FieldRef<"UserChallengeProgress", 'DateTime'>
    readonly certificateIssued: FieldRef<"UserChallengeProgress", 'Boolean'>
    readonly certificateUrl: FieldRef<"UserChallengeProgress", 'String'>
    readonly completedTaskIds: FieldRef<"UserChallengeProgress", 'Json'>
    readonly skippedTaskIds: FieldRef<"UserChallengeProgress", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * UserChallengeProgress findUnique
   */
  export type UserChallengeProgressFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgress
     */
    select?: UserChallengeProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserChallengeProgress to fetch.
     */
    where: UserChallengeProgressWhereUniqueInput
  }

  /**
   * UserChallengeProgress findUniqueOrThrow
   */
  export type UserChallengeProgressFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgress
     */
    select?: UserChallengeProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserChallengeProgress to fetch.
     */
    where: UserChallengeProgressWhereUniqueInput
  }

  /**
   * UserChallengeProgress findFirst
   */
  export type UserChallengeProgressFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgress
     */
    select?: UserChallengeProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserChallengeProgress to fetch.
     */
    where?: UserChallengeProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallengeProgresses to fetch.
     */
    orderBy?: UserChallengeProgressOrderByWithRelationInput | UserChallengeProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserChallengeProgresses.
     */
    cursor?: UserChallengeProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallengeProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallengeProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserChallengeProgresses.
     */
    distinct?: UserChallengeProgressScalarFieldEnum | UserChallengeProgressScalarFieldEnum[]
  }

  /**
   * UserChallengeProgress findFirstOrThrow
   */
  export type UserChallengeProgressFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgress
     */
    select?: UserChallengeProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserChallengeProgress to fetch.
     */
    where?: UserChallengeProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallengeProgresses to fetch.
     */
    orderBy?: UserChallengeProgressOrderByWithRelationInput | UserChallengeProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserChallengeProgresses.
     */
    cursor?: UserChallengeProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallengeProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallengeProgresses.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserChallengeProgresses.
     */
    distinct?: UserChallengeProgressScalarFieldEnum | UserChallengeProgressScalarFieldEnum[]
  }

  /**
   * UserChallengeProgress findMany
   */
  export type UserChallengeProgressFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgress
     */
    select?: UserChallengeProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeProgressInclude<ExtArgs> | null
    /**
     * Filter, which UserChallengeProgresses to fetch.
     */
    where?: UserChallengeProgressWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserChallengeProgresses to fetch.
     */
    orderBy?: UserChallengeProgressOrderByWithRelationInput | UserChallengeProgressOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserChallengeProgresses.
     */
    cursor?: UserChallengeProgressWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserChallengeProgresses from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserChallengeProgresses.
     */
    skip?: number
    distinct?: UserChallengeProgressScalarFieldEnum | UserChallengeProgressScalarFieldEnum[]
  }

  /**
   * UserChallengeProgress create
   */
  export type UserChallengeProgressCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgress
     */
    select?: UserChallengeProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeProgressInclude<ExtArgs> | null
    /**
     * The data needed to create a UserChallengeProgress.
     */
    data: XOR<UserChallengeProgressCreateInput, UserChallengeProgressUncheckedCreateInput>
  }

  /**
   * UserChallengeProgress createMany
   */
  export type UserChallengeProgressCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserChallengeProgresses.
     */
    data: UserChallengeProgressCreateManyInput | UserChallengeProgressCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserChallengeProgress update
   */
  export type UserChallengeProgressUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgress
     */
    select?: UserChallengeProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeProgressInclude<ExtArgs> | null
    /**
     * The data needed to update a UserChallengeProgress.
     */
    data: XOR<UserChallengeProgressUpdateInput, UserChallengeProgressUncheckedUpdateInput>
    /**
     * Choose, which UserChallengeProgress to update.
     */
    where: UserChallengeProgressWhereUniqueInput
  }

  /**
   * UserChallengeProgress updateMany
   */
  export type UserChallengeProgressUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserChallengeProgresses.
     */
    data: XOR<UserChallengeProgressUpdateManyMutationInput, UserChallengeProgressUncheckedUpdateManyInput>
    /**
     * Filter which UserChallengeProgresses to update
     */
    where?: UserChallengeProgressWhereInput
  }

  /**
   * UserChallengeProgress upsert
   */
  export type UserChallengeProgressUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgress
     */
    select?: UserChallengeProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeProgressInclude<ExtArgs> | null
    /**
     * The filter to search for the UserChallengeProgress to update in case it exists.
     */
    where: UserChallengeProgressWhereUniqueInput
    /**
     * In case the UserChallengeProgress found by the `where` argument doesn't exist, create a new UserChallengeProgress with this data.
     */
    create: XOR<UserChallengeProgressCreateInput, UserChallengeProgressUncheckedCreateInput>
    /**
     * In case the UserChallengeProgress was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserChallengeProgressUpdateInput, UserChallengeProgressUncheckedUpdateInput>
  }

  /**
   * UserChallengeProgress delete
   */
  export type UserChallengeProgressDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgress
     */
    select?: UserChallengeProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeProgressInclude<ExtArgs> | null
    /**
     * Filter which UserChallengeProgress to delete.
     */
    where: UserChallengeProgressWhereUniqueInput
  }

  /**
   * UserChallengeProgress deleteMany
   */
  export type UserChallengeProgressDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserChallengeProgresses to delete
     */
    where?: UserChallengeProgressWhereInput
  }

  /**
   * UserChallengeProgress.taskCompletions
   */
  export type UserChallengeProgress$taskCompletionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
    where?: UserTaskCompletionWhereInput
    orderBy?: UserTaskCompletionOrderByWithRelationInput | UserTaskCompletionOrderByWithRelationInput[]
    cursor?: UserTaskCompletionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: UserTaskCompletionScalarFieldEnum | UserTaskCompletionScalarFieldEnum[]
  }

  /**
   * UserChallengeProgress without action
   */
  export type UserChallengeProgressDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserChallengeProgress
     */
    select?: UserChallengeProgressSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserChallengeProgressInclude<ExtArgs> | null
  }


  /**
   * Model UserTaskCompletion
   */

  export type AggregateUserTaskCompletion = {
    _count: UserTaskCompletionCountAggregateOutputType | null
    _avg: UserTaskCompletionAvgAggregateOutputType | null
    _sum: UserTaskCompletionSumAggregateOutputType | null
    _min: UserTaskCompletionMinAggregateOutputType | null
    _max: UserTaskCompletionMaxAggregateOutputType | null
  }

  export type UserTaskCompletionAvgAggregateOutputType = {
    timeTaken: number | null
    score: Decimal | null
    pointsEarned: number | null
  }

  export type UserTaskCompletionSumAggregateOutputType = {
    timeTaken: number | null
    score: Decimal | null
    pointsEarned: number | null
  }

  export type UserTaskCompletionMinAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    taskId: string | null
    progressId: string | null
    completedAt: Date | null
    timeTaken: number | null
    submissionUrl: string | null
    submissionText: string | null
    isVerified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
    score: Decimal | null
    pointsEarned: number | null
    userNotes: string | null
    feedback: string | null
  }

  export type UserTaskCompletionMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    challengeId: string | null
    taskId: string | null
    progressId: string | null
    completedAt: Date | null
    timeTaken: number | null
    submissionUrl: string | null
    submissionText: string | null
    isVerified: boolean | null
    verifiedBy: string | null
    verifiedAt: Date | null
    score: Decimal | null
    pointsEarned: number | null
    userNotes: string | null
    feedback: string | null
  }

  export type UserTaskCompletionCountAggregateOutputType = {
    id: number
    userId: number
    challengeId: number
    taskId: number
    progressId: number
    completedAt: number
    timeTaken: number
    submissionUrl: number
    submissionText: number
    submissionFiles: number
    isVerified: number
    verifiedBy: number
    verifiedAt: number
    score: number
    pointsEarned: number
    userNotes: number
    feedback: number
    _all: number
  }


  export type UserTaskCompletionAvgAggregateInputType = {
    timeTaken?: true
    score?: true
    pointsEarned?: true
  }

  export type UserTaskCompletionSumAggregateInputType = {
    timeTaken?: true
    score?: true
    pointsEarned?: true
  }

  export type UserTaskCompletionMinAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    taskId?: true
    progressId?: true
    completedAt?: true
    timeTaken?: true
    submissionUrl?: true
    submissionText?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    score?: true
    pointsEarned?: true
    userNotes?: true
    feedback?: true
  }

  export type UserTaskCompletionMaxAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    taskId?: true
    progressId?: true
    completedAt?: true
    timeTaken?: true
    submissionUrl?: true
    submissionText?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    score?: true
    pointsEarned?: true
    userNotes?: true
    feedback?: true
  }

  export type UserTaskCompletionCountAggregateInputType = {
    id?: true
    userId?: true
    challengeId?: true
    taskId?: true
    progressId?: true
    completedAt?: true
    timeTaken?: true
    submissionUrl?: true
    submissionText?: true
    submissionFiles?: true
    isVerified?: true
    verifiedBy?: true
    verifiedAt?: true
    score?: true
    pointsEarned?: true
    userNotes?: true
    feedback?: true
    _all?: true
  }

  export type UserTaskCompletionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTaskCompletion to aggregate.
     */
    where?: UserTaskCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTaskCompletions to fetch.
     */
    orderBy?: UserTaskCompletionOrderByWithRelationInput | UserTaskCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserTaskCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTaskCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTaskCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserTaskCompletions
    **/
    _count?: true | UserTaskCompletionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserTaskCompletionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserTaskCompletionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserTaskCompletionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserTaskCompletionMaxAggregateInputType
  }

  export type GetUserTaskCompletionAggregateType<T extends UserTaskCompletionAggregateArgs> = {
        [P in keyof T & keyof AggregateUserTaskCompletion]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserTaskCompletion[P]>
      : GetScalarType<T[P], AggregateUserTaskCompletion[P]>
  }




  export type UserTaskCompletionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserTaskCompletionWhereInput
    orderBy?: UserTaskCompletionOrderByWithAggregationInput | UserTaskCompletionOrderByWithAggregationInput[]
    by: UserTaskCompletionScalarFieldEnum[] | UserTaskCompletionScalarFieldEnum
    having?: UserTaskCompletionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserTaskCompletionCountAggregateInputType | true
    _avg?: UserTaskCompletionAvgAggregateInputType
    _sum?: UserTaskCompletionSumAggregateInputType
    _min?: UserTaskCompletionMinAggregateInputType
    _max?: UserTaskCompletionMaxAggregateInputType
  }

  export type UserTaskCompletionGroupByOutputType = {
    id: string
    userId: string
    challengeId: string
    taskId: string
    progressId: string
    completedAt: Date
    timeTaken: number | null
    submissionUrl: string | null
    submissionText: string | null
    submissionFiles: JsonValue | null
    isVerified: boolean
    verifiedBy: string | null
    verifiedAt: Date | null
    score: Decimal | null
    pointsEarned: number | null
    userNotes: string | null
    feedback: string | null
    _count: UserTaskCompletionCountAggregateOutputType | null
    _avg: UserTaskCompletionAvgAggregateOutputType | null
    _sum: UserTaskCompletionSumAggregateOutputType | null
    _min: UserTaskCompletionMinAggregateOutputType | null
    _max: UserTaskCompletionMaxAggregateOutputType | null
  }

  type GetUserTaskCompletionGroupByPayload<T extends UserTaskCompletionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserTaskCompletionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserTaskCompletionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserTaskCompletionGroupByOutputType[P]>
            : GetScalarType<T[P], UserTaskCompletionGroupByOutputType[P]>
        }
      >
    >


  export type UserTaskCompletionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    taskId?: boolean
    progressId?: boolean
    completedAt?: boolean
    timeTaken?: boolean
    submissionUrl?: boolean
    submissionText?: boolean
    submissionFiles?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    score?: boolean
    pointsEarned?: boolean
    userNotes?: boolean
    feedback?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | ChallengeTaskDefaultArgs<ExtArgs>
    progress?: boolean | UserChallengeProgressDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userTaskCompletion"]>


  export type UserTaskCompletionSelectScalar = {
    id?: boolean
    userId?: boolean
    challengeId?: boolean
    taskId?: boolean
    progressId?: boolean
    completedAt?: boolean
    timeTaken?: boolean
    submissionUrl?: boolean
    submissionText?: boolean
    submissionFiles?: boolean
    isVerified?: boolean
    verifiedBy?: boolean
    verifiedAt?: boolean
    score?: boolean
    pointsEarned?: boolean
    userNotes?: boolean
    feedback?: boolean
  }

  export type UserTaskCompletionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
    task?: boolean | ChallengeTaskDefaultArgs<ExtArgs>
    progress?: boolean | UserChallengeProgressDefaultArgs<ExtArgs>
  }

  export type $UserTaskCompletionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserTaskCompletion"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
      task: Prisma.$ChallengeTaskPayload<ExtArgs>
      progress: Prisma.$UserChallengeProgressPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      challengeId: string
      taskId: string
      progressId: string
      completedAt: Date
      timeTaken: number | null
      submissionUrl: string | null
      submissionText: string | null
      submissionFiles: Prisma.JsonValue | null
      isVerified: boolean
      verifiedBy: string | null
      verifiedAt: Date | null
      score: Prisma.Decimal | null
      pointsEarned: number | null
      userNotes: string | null
      feedback: string | null
    }, ExtArgs["result"]["userTaskCompletion"]>
    composites: {}
  }

  type UserTaskCompletionGetPayload<S extends boolean | null | undefined | UserTaskCompletionDefaultArgs> = $Result.GetResult<Prisma.$UserTaskCompletionPayload, S>

  type UserTaskCompletionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserTaskCompletionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserTaskCompletionCountAggregateInputType | true
    }

  export interface UserTaskCompletionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserTaskCompletion'], meta: { name: 'UserTaskCompletion' } }
    /**
     * Find zero or one UserTaskCompletion that matches the filter.
     * @param {UserTaskCompletionFindUniqueArgs} args - Arguments to find a UserTaskCompletion
     * @example
     * // Get one UserTaskCompletion
     * const userTaskCompletion = await prisma.userTaskCompletion.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserTaskCompletionFindUniqueArgs>(args: SelectSubset<T, UserTaskCompletionFindUniqueArgs<ExtArgs>>): Prisma__UserTaskCompletionClient<$Result.GetResult<Prisma.$UserTaskCompletionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserTaskCompletion that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserTaskCompletionFindUniqueOrThrowArgs} args - Arguments to find a UserTaskCompletion
     * @example
     * // Get one UserTaskCompletion
     * const userTaskCompletion = await prisma.userTaskCompletion.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserTaskCompletionFindUniqueOrThrowArgs>(args: SelectSubset<T, UserTaskCompletionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserTaskCompletionClient<$Result.GetResult<Prisma.$UserTaskCompletionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserTaskCompletion that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskCompletionFindFirstArgs} args - Arguments to find a UserTaskCompletion
     * @example
     * // Get one UserTaskCompletion
     * const userTaskCompletion = await prisma.userTaskCompletion.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserTaskCompletionFindFirstArgs>(args?: SelectSubset<T, UserTaskCompletionFindFirstArgs<ExtArgs>>): Prisma__UserTaskCompletionClient<$Result.GetResult<Prisma.$UserTaskCompletionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserTaskCompletion that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskCompletionFindFirstOrThrowArgs} args - Arguments to find a UserTaskCompletion
     * @example
     * // Get one UserTaskCompletion
     * const userTaskCompletion = await prisma.userTaskCompletion.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserTaskCompletionFindFirstOrThrowArgs>(args?: SelectSubset<T, UserTaskCompletionFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserTaskCompletionClient<$Result.GetResult<Prisma.$UserTaskCompletionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserTaskCompletions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskCompletionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserTaskCompletions
     * const userTaskCompletions = await prisma.userTaskCompletion.findMany()
     * 
     * // Get first 10 UserTaskCompletions
     * const userTaskCompletions = await prisma.userTaskCompletion.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userTaskCompletionWithIdOnly = await prisma.userTaskCompletion.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserTaskCompletionFindManyArgs>(args?: SelectSubset<T, UserTaskCompletionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserTaskCompletionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserTaskCompletion.
     * @param {UserTaskCompletionCreateArgs} args - Arguments to create a UserTaskCompletion.
     * @example
     * // Create one UserTaskCompletion
     * const UserTaskCompletion = await prisma.userTaskCompletion.create({
     *   data: {
     *     // ... data to create a UserTaskCompletion
     *   }
     * })
     * 
     */
    create<T extends UserTaskCompletionCreateArgs>(args: SelectSubset<T, UserTaskCompletionCreateArgs<ExtArgs>>): Prisma__UserTaskCompletionClient<$Result.GetResult<Prisma.$UserTaskCompletionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserTaskCompletions.
     * @param {UserTaskCompletionCreateManyArgs} args - Arguments to create many UserTaskCompletions.
     * @example
     * // Create many UserTaskCompletions
     * const userTaskCompletion = await prisma.userTaskCompletion.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserTaskCompletionCreateManyArgs>(args?: SelectSubset<T, UserTaskCompletionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserTaskCompletion.
     * @param {UserTaskCompletionDeleteArgs} args - Arguments to delete one UserTaskCompletion.
     * @example
     * // Delete one UserTaskCompletion
     * const UserTaskCompletion = await prisma.userTaskCompletion.delete({
     *   where: {
     *     // ... filter to delete one UserTaskCompletion
     *   }
     * })
     * 
     */
    delete<T extends UserTaskCompletionDeleteArgs>(args: SelectSubset<T, UserTaskCompletionDeleteArgs<ExtArgs>>): Prisma__UserTaskCompletionClient<$Result.GetResult<Prisma.$UserTaskCompletionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserTaskCompletion.
     * @param {UserTaskCompletionUpdateArgs} args - Arguments to update one UserTaskCompletion.
     * @example
     * // Update one UserTaskCompletion
     * const userTaskCompletion = await prisma.userTaskCompletion.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserTaskCompletionUpdateArgs>(args: SelectSubset<T, UserTaskCompletionUpdateArgs<ExtArgs>>): Prisma__UserTaskCompletionClient<$Result.GetResult<Prisma.$UserTaskCompletionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserTaskCompletions.
     * @param {UserTaskCompletionDeleteManyArgs} args - Arguments to filter UserTaskCompletions to delete.
     * @example
     * // Delete a few UserTaskCompletions
     * const { count } = await prisma.userTaskCompletion.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserTaskCompletionDeleteManyArgs>(args?: SelectSubset<T, UserTaskCompletionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserTaskCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskCompletionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserTaskCompletions
     * const userTaskCompletion = await prisma.userTaskCompletion.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserTaskCompletionUpdateManyArgs>(args: SelectSubset<T, UserTaskCompletionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserTaskCompletion.
     * @param {UserTaskCompletionUpsertArgs} args - Arguments to update or create a UserTaskCompletion.
     * @example
     * // Update or create a UserTaskCompletion
     * const userTaskCompletion = await prisma.userTaskCompletion.upsert({
     *   create: {
     *     // ... data to create a UserTaskCompletion
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserTaskCompletion we want to update
     *   }
     * })
     */
    upsert<T extends UserTaskCompletionUpsertArgs>(args: SelectSubset<T, UserTaskCompletionUpsertArgs<ExtArgs>>): Prisma__UserTaskCompletionClient<$Result.GetResult<Prisma.$UserTaskCompletionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserTaskCompletions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskCompletionCountArgs} args - Arguments to filter UserTaskCompletions to count.
     * @example
     * // Count the number of UserTaskCompletions
     * const count = await prisma.userTaskCompletion.count({
     *   where: {
     *     // ... the filter for the UserTaskCompletions we want to count
     *   }
     * })
    **/
    count<T extends UserTaskCompletionCountArgs>(
      args?: Subset<T, UserTaskCompletionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserTaskCompletionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserTaskCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskCompletionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserTaskCompletionAggregateArgs>(args: Subset<T, UserTaskCompletionAggregateArgs>): Prisma.PrismaPromise<GetUserTaskCompletionAggregateType<T>>

    /**
     * Group by UserTaskCompletion.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserTaskCompletionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserTaskCompletionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserTaskCompletionGroupByArgs['orderBy'] }
        : { orderBy?: UserTaskCompletionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserTaskCompletionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserTaskCompletionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserTaskCompletion model
   */
  readonly fields: UserTaskCompletionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserTaskCompletion.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserTaskCompletionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    task<T extends ChallengeTaskDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeTaskDefaultArgs<ExtArgs>>): Prisma__ChallengeTaskClient<$Result.GetResult<Prisma.$ChallengeTaskPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    progress<T extends UserChallengeProgressDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserChallengeProgressDefaultArgs<ExtArgs>>): Prisma__UserChallengeProgressClient<$Result.GetResult<Prisma.$UserChallengeProgressPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserTaskCompletion model
   */ 
  interface UserTaskCompletionFieldRefs {
    readonly id: FieldRef<"UserTaskCompletion", 'String'>
    readonly userId: FieldRef<"UserTaskCompletion", 'String'>
    readonly challengeId: FieldRef<"UserTaskCompletion", 'String'>
    readonly taskId: FieldRef<"UserTaskCompletion", 'String'>
    readonly progressId: FieldRef<"UserTaskCompletion", 'String'>
    readonly completedAt: FieldRef<"UserTaskCompletion", 'DateTime'>
    readonly timeTaken: FieldRef<"UserTaskCompletion", 'Int'>
    readonly submissionUrl: FieldRef<"UserTaskCompletion", 'String'>
    readonly submissionText: FieldRef<"UserTaskCompletion", 'String'>
    readonly submissionFiles: FieldRef<"UserTaskCompletion", 'Json'>
    readonly isVerified: FieldRef<"UserTaskCompletion", 'Boolean'>
    readonly verifiedBy: FieldRef<"UserTaskCompletion", 'String'>
    readonly verifiedAt: FieldRef<"UserTaskCompletion", 'DateTime'>
    readonly score: FieldRef<"UserTaskCompletion", 'Decimal'>
    readonly pointsEarned: FieldRef<"UserTaskCompletion", 'Int'>
    readonly userNotes: FieldRef<"UserTaskCompletion", 'String'>
    readonly feedback: FieldRef<"UserTaskCompletion", 'String'>
  }
    

  // Custom InputTypes
  /**
   * UserTaskCompletion findUnique
   */
  export type UserTaskCompletionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
    /**
     * Filter, which UserTaskCompletion to fetch.
     */
    where: UserTaskCompletionWhereUniqueInput
  }

  /**
   * UserTaskCompletion findUniqueOrThrow
   */
  export type UserTaskCompletionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
    /**
     * Filter, which UserTaskCompletion to fetch.
     */
    where: UserTaskCompletionWhereUniqueInput
  }

  /**
   * UserTaskCompletion findFirst
   */
  export type UserTaskCompletionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
    /**
     * Filter, which UserTaskCompletion to fetch.
     */
    where?: UserTaskCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTaskCompletions to fetch.
     */
    orderBy?: UserTaskCompletionOrderByWithRelationInput | UserTaskCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTaskCompletions.
     */
    cursor?: UserTaskCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTaskCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTaskCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTaskCompletions.
     */
    distinct?: UserTaskCompletionScalarFieldEnum | UserTaskCompletionScalarFieldEnum[]
  }

  /**
   * UserTaskCompletion findFirstOrThrow
   */
  export type UserTaskCompletionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
    /**
     * Filter, which UserTaskCompletion to fetch.
     */
    where?: UserTaskCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTaskCompletions to fetch.
     */
    orderBy?: UserTaskCompletionOrderByWithRelationInput | UserTaskCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserTaskCompletions.
     */
    cursor?: UserTaskCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTaskCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTaskCompletions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserTaskCompletions.
     */
    distinct?: UserTaskCompletionScalarFieldEnum | UserTaskCompletionScalarFieldEnum[]
  }

  /**
   * UserTaskCompletion findMany
   */
  export type UserTaskCompletionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
    /**
     * Filter, which UserTaskCompletions to fetch.
     */
    where?: UserTaskCompletionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserTaskCompletions to fetch.
     */
    orderBy?: UserTaskCompletionOrderByWithRelationInput | UserTaskCompletionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserTaskCompletions.
     */
    cursor?: UserTaskCompletionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserTaskCompletions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserTaskCompletions.
     */
    skip?: number
    distinct?: UserTaskCompletionScalarFieldEnum | UserTaskCompletionScalarFieldEnum[]
  }

  /**
   * UserTaskCompletion create
   */
  export type UserTaskCompletionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
    /**
     * The data needed to create a UserTaskCompletion.
     */
    data: XOR<UserTaskCompletionCreateInput, UserTaskCompletionUncheckedCreateInput>
  }

  /**
   * UserTaskCompletion createMany
   */
  export type UserTaskCompletionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserTaskCompletions.
     */
    data: UserTaskCompletionCreateManyInput | UserTaskCompletionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserTaskCompletion update
   */
  export type UserTaskCompletionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
    /**
     * The data needed to update a UserTaskCompletion.
     */
    data: XOR<UserTaskCompletionUpdateInput, UserTaskCompletionUncheckedUpdateInput>
    /**
     * Choose, which UserTaskCompletion to update.
     */
    where: UserTaskCompletionWhereUniqueInput
  }

  /**
   * UserTaskCompletion updateMany
   */
  export type UserTaskCompletionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserTaskCompletions.
     */
    data: XOR<UserTaskCompletionUpdateManyMutationInput, UserTaskCompletionUncheckedUpdateManyInput>
    /**
     * Filter which UserTaskCompletions to update
     */
    where?: UserTaskCompletionWhereInput
  }

  /**
   * UserTaskCompletion upsert
   */
  export type UserTaskCompletionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
    /**
     * The filter to search for the UserTaskCompletion to update in case it exists.
     */
    where: UserTaskCompletionWhereUniqueInput
    /**
     * In case the UserTaskCompletion found by the `where` argument doesn't exist, create a new UserTaskCompletion with this data.
     */
    create: XOR<UserTaskCompletionCreateInput, UserTaskCompletionUncheckedCreateInput>
    /**
     * In case the UserTaskCompletion was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserTaskCompletionUpdateInput, UserTaskCompletionUncheckedUpdateInput>
  }

  /**
   * UserTaskCompletion delete
   */
  export type UserTaskCompletionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
    /**
     * Filter which UserTaskCompletion to delete.
     */
    where: UserTaskCompletionWhereUniqueInput
  }

  /**
   * UserTaskCompletion deleteMany
   */
  export type UserTaskCompletionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserTaskCompletions to delete
     */
    where?: UserTaskCompletionWhereInput
  }

  /**
   * UserTaskCompletion without action
   */
  export type UserTaskCompletionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserTaskCompletion
     */
    select?: UserTaskCompletionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserTaskCompletionInclude<ExtArgs> | null
  }


  /**
   * Model UserBadge
   */

  export type AggregateUserBadge = {
    _count: UserBadgeCountAggregateOutputType | null
    _avg: UserBadgeAvgAggregateOutputType | null
    _sum: UserBadgeSumAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  export type UserBadgeAvgAggregateOutputType = {
    pointsAwarded: number | null
  }

  export type UserBadgeSumAggregateOutputType = {
    pointsAwarded: number | null
  }

  export type UserBadgeMinAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeType: string | null
    badgeName: string | null
    badgeDescription: string | null
    badgeIcon: string | null
    badgeColor: string | null
    relatedChallengeId: string | null
    relatedEventId: string | null
    pointsAwarded: number | null
    earnedAt: Date | null
  }

  export type UserBadgeMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    badgeType: string | null
    badgeName: string | null
    badgeDescription: string | null
    badgeIcon: string | null
    badgeColor: string | null
    relatedChallengeId: string | null
    relatedEventId: string | null
    pointsAwarded: number | null
    earnedAt: Date | null
  }

  export type UserBadgeCountAggregateOutputType = {
    id: number
    userId: number
    badgeType: number
    badgeName: number
    badgeDescription: number
    badgeIcon: number
    badgeColor: number
    relatedChallengeId: number
    relatedEventId: number
    pointsAwarded: number
    earnedAt: number
    _all: number
  }


  export type UserBadgeAvgAggregateInputType = {
    pointsAwarded?: true
  }

  export type UserBadgeSumAggregateInputType = {
    pointsAwarded?: true
  }

  export type UserBadgeMinAggregateInputType = {
    id?: true
    userId?: true
    badgeType?: true
    badgeName?: true
    badgeDescription?: true
    badgeIcon?: true
    badgeColor?: true
    relatedChallengeId?: true
    relatedEventId?: true
    pointsAwarded?: true
    earnedAt?: true
  }

  export type UserBadgeMaxAggregateInputType = {
    id?: true
    userId?: true
    badgeType?: true
    badgeName?: true
    badgeDescription?: true
    badgeIcon?: true
    badgeColor?: true
    relatedChallengeId?: true
    relatedEventId?: true
    pointsAwarded?: true
    earnedAt?: true
  }

  export type UserBadgeCountAggregateInputType = {
    id?: true
    userId?: true
    badgeType?: true
    badgeName?: true
    badgeDescription?: true
    badgeIcon?: true
    badgeColor?: true
    relatedChallengeId?: true
    relatedEventId?: true
    pointsAwarded?: true
    earnedAt?: true
    _all?: true
  }

  export type UserBadgeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadge to aggregate.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserBadges
    **/
    _count?: true | UserBadgeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserBadgeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserBadgeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserBadgeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserBadgeMaxAggregateInputType
  }

  export type GetUserBadgeAggregateType<T extends UserBadgeAggregateArgs> = {
        [P in keyof T & keyof AggregateUserBadge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserBadge[P]>
      : GetScalarType<T[P], AggregateUserBadge[P]>
  }




  export type UserBadgeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserBadgeWhereInput
    orderBy?: UserBadgeOrderByWithAggregationInput | UserBadgeOrderByWithAggregationInput[]
    by: UserBadgeScalarFieldEnum[] | UserBadgeScalarFieldEnum
    having?: UserBadgeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserBadgeCountAggregateInputType | true
    _avg?: UserBadgeAvgAggregateInputType
    _sum?: UserBadgeSumAggregateInputType
    _min?: UserBadgeMinAggregateInputType
    _max?: UserBadgeMaxAggregateInputType
  }

  export type UserBadgeGroupByOutputType = {
    id: string
    userId: string
    badgeType: string
    badgeName: string
    badgeDescription: string | null
    badgeIcon: string | null
    badgeColor: string | null
    relatedChallengeId: string | null
    relatedEventId: string | null
    pointsAwarded: number
    earnedAt: Date
    _count: UserBadgeCountAggregateOutputType | null
    _avg: UserBadgeAvgAggregateOutputType | null
    _sum: UserBadgeSumAggregateOutputType | null
    _min: UserBadgeMinAggregateOutputType | null
    _max: UserBadgeMaxAggregateOutputType | null
  }

  type GetUserBadgeGroupByPayload<T extends UserBadgeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserBadgeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserBadgeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
            : GetScalarType<T[P], UserBadgeGroupByOutputType[P]>
        }
      >
    >


  export type UserBadgeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    badgeType?: boolean
    badgeName?: boolean
    badgeDescription?: boolean
    badgeIcon?: boolean
    badgeColor?: boolean
    relatedChallengeId?: boolean
    relatedEventId?: boolean
    pointsAwarded?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userBadge"]>


  export type UserBadgeSelectScalar = {
    id?: boolean
    userId?: boolean
    badgeType?: boolean
    badgeName?: boolean
    badgeDescription?: boolean
    badgeIcon?: boolean
    badgeColor?: boolean
    relatedChallengeId?: boolean
    relatedEventId?: boolean
    pointsAwarded?: boolean
    earnedAt?: boolean
  }

  export type UserBadgeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserBadgePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserBadge"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      badgeType: string
      badgeName: string
      badgeDescription: string | null
      badgeIcon: string | null
      badgeColor: string | null
      relatedChallengeId: string | null
      relatedEventId: string | null
      pointsAwarded: number
      earnedAt: Date
    }, ExtArgs["result"]["userBadge"]>
    composites: {}
  }

  type UserBadgeGetPayload<S extends boolean | null | undefined | UserBadgeDefaultArgs> = $Result.GetResult<Prisma.$UserBadgePayload, S>

  type UserBadgeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserBadgeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserBadgeCountAggregateInputType | true
    }

  export interface UserBadgeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserBadge'], meta: { name: 'UserBadge' } }
    /**
     * Find zero or one UserBadge that matches the filter.
     * @param {UserBadgeFindUniqueArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserBadgeFindUniqueArgs>(args: SelectSubset<T, UserBadgeFindUniqueArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserBadge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserBadgeFindUniqueOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserBadgeFindUniqueOrThrowArgs>(args: SelectSubset<T, UserBadgeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserBadgeFindFirstArgs>(args?: SelectSubset<T, UserBadgeFindFirstArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserBadge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindFirstOrThrowArgs} args - Arguments to find a UserBadge
     * @example
     * // Get one UserBadge
     * const userBadge = await prisma.userBadge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserBadgeFindFirstOrThrowArgs>(args?: SelectSubset<T, UserBadgeFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserBadges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserBadges
     * const userBadges = await prisma.userBadge.findMany()
     * 
     * // Get first 10 UserBadges
     * const userBadges = await prisma.userBadge.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userBadgeWithIdOnly = await prisma.userBadge.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserBadgeFindManyArgs>(args?: SelectSubset<T, UserBadgeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserBadge.
     * @param {UserBadgeCreateArgs} args - Arguments to create a UserBadge.
     * @example
     * // Create one UserBadge
     * const UserBadge = await prisma.userBadge.create({
     *   data: {
     *     // ... data to create a UserBadge
     *   }
     * })
     * 
     */
    create<T extends UserBadgeCreateArgs>(args: SelectSubset<T, UserBadgeCreateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserBadges.
     * @param {UserBadgeCreateManyArgs} args - Arguments to create many UserBadges.
     * @example
     * // Create many UserBadges
     * const userBadge = await prisma.userBadge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserBadgeCreateManyArgs>(args?: SelectSubset<T, UserBadgeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserBadge.
     * @param {UserBadgeDeleteArgs} args - Arguments to delete one UserBadge.
     * @example
     * // Delete one UserBadge
     * const UserBadge = await prisma.userBadge.delete({
     *   where: {
     *     // ... filter to delete one UserBadge
     *   }
     * })
     * 
     */
    delete<T extends UserBadgeDeleteArgs>(args: SelectSubset<T, UserBadgeDeleteArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserBadge.
     * @param {UserBadgeUpdateArgs} args - Arguments to update one UserBadge.
     * @example
     * // Update one UserBadge
     * const userBadge = await prisma.userBadge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserBadgeUpdateArgs>(args: SelectSubset<T, UserBadgeUpdateArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserBadges.
     * @param {UserBadgeDeleteManyArgs} args - Arguments to filter UserBadges to delete.
     * @example
     * // Delete a few UserBadges
     * const { count } = await prisma.userBadge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserBadgeDeleteManyArgs>(args?: SelectSubset<T, UserBadgeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserBadges
     * const userBadge = await prisma.userBadge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserBadgeUpdateManyArgs>(args: SelectSubset<T, UserBadgeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserBadge.
     * @param {UserBadgeUpsertArgs} args - Arguments to update or create a UserBadge.
     * @example
     * // Update or create a UserBadge
     * const userBadge = await prisma.userBadge.upsert({
     *   create: {
     *     // ... data to create a UserBadge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserBadge we want to update
     *   }
     * })
     */
    upsert<T extends UserBadgeUpsertArgs>(args: SelectSubset<T, UserBadgeUpsertArgs<ExtArgs>>): Prisma__UserBadgeClient<$Result.GetResult<Prisma.$UserBadgePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserBadges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeCountArgs} args - Arguments to filter UserBadges to count.
     * @example
     * // Count the number of UserBadges
     * const count = await prisma.userBadge.count({
     *   where: {
     *     // ... the filter for the UserBadges we want to count
     *   }
     * })
    **/
    count<T extends UserBadgeCountArgs>(
      args?: Subset<T, UserBadgeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserBadgeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserBadgeAggregateArgs>(args: Subset<T, UserBadgeAggregateArgs>): Prisma.PrismaPromise<GetUserBadgeAggregateType<T>>

    /**
     * Group by UserBadge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserBadgeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserBadgeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserBadgeGroupByArgs['orderBy'] }
        : { orderBy?: UserBadgeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserBadgeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserBadgeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserBadge model
   */
  readonly fields: UserBadgeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserBadge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserBadgeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserBadge model
   */ 
  interface UserBadgeFieldRefs {
    readonly id: FieldRef<"UserBadge", 'String'>
    readonly userId: FieldRef<"UserBadge", 'String'>
    readonly badgeType: FieldRef<"UserBadge", 'String'>
    readonly badgeName: FieldRef<"UserBadge", 'String'>
    readonly badgeDescription: FieldRef<"UserBadge", 'String'>
    readonly badgeIcon: FieldRef<"UserBadge", 'String'>
    readonly badgeColor: FieldRef<"UserBadge", 'String'>
    readonly relatedChallengeId: FieldRef<"UserBadge", 'String'>
    readonly relatedEventId: FieldRef<"UserBadge", 'String'>
    readonly pointsAwarded: FieldRef<"UserBadge", 'Int'>
    readonly earnedAt: FieldRef<"UserBadge", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserBadge findUnique
   */
  export type UserBadgeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findUniqueOrThrow
   */
  export type UserBadgeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge findFirst
   */
  export type UserBadgeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findFirstOrThrow
   */
  export type UserBadgeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadge to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserBadges.
     */
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge findMany
   */
  export type UserBadgeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter, which UserBadges to fetch.
     */
    where?: UserBadgeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserBadges to fetch.
     */
    orderBy?: UserBadgeOrderByWithRelationInput | UserBadgeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserBadges.
     */
    cursor?: UserBadgeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserBadges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserBadges.
     */
    skip?: number
    distinct?: UserBadgeScalarFieldEnum | UserBadgeScalarFieldEnum[]
  }

  /**
   * UserBadge create
   */
  export type UserBadgeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to create a UserBadge.
     */
    data: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
  }

  /**
   * UserBadge createMany
   */
  export type UserBadgeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserBadges.
     */
    data: UserBadgeCreateManyInput | UserBadgeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserBadge update
   */
  export type UserBadgeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The data needed to update a UserBadge.
     */
    data: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
    /**
     * Choose, which UserBadge to update.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge updateMany
   */
  export type UserBadgeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserBadges.
     */
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyInput>
    /**
     * Filter which UserBadges to update
     */
    where?: UserBadgeWhereInput
  }

  /**
   * UserBadge upsert
   */
  export type UserBadgeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * The filter to search for the UserBadge to update in case it exists.
     */
    where: UserBadgeWhereUniqueInput
    /**
     * In case the UserBadge found by the `where` argument doesn't exist, create a new UserBadge with this data.
     */
    create: XOR<UserBadgeCreateInput, UserBadgeUncheckedCreateInput>
    /**
     * In case the UserBadge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserBadgeUpdateInput, UserBadgeUncheckedUpdateInput>
  }

  /**
   * UserBadge delete
   */
  export type UserBadgeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
    /**
     * Filter which UserBadge to delete.
     */
    where: UserBadgeWhereUniqueInput
  }

  /**
   * UserBadge deleteMany
   */
  export type UserBadgeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserBadges to delete
     */
    where?: UserBadgeWhereInput
  }

  /**
   * UserBadge without action
   */
  export type UserBadgeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserBadge
     */
    select?: UserBadgeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserBadgeInclude<ExtArgs> | null
  }


  /**
   * Model UserAchievement
   */

  export type AggregateUserAchievement = {
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  export type UserAchievementAvgAggregateOutputType = {
    value: number | null
    target: number | null
  }

  export type UserAchievementSumAggregateOutputType = {
    value: number | null
    target: number | null
  }

  export type UserAchievementMinAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementType: string | null
    achievementName: string | null
    description: string | null
    value: number | null
    target: number | null
    rarity: string | null
    earnedAt: Date | null
  }

  export type UserAchievementMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    achievementType: string | null
    achievementName: string | null
    description: string | null
    value: number | null
    target: number | null
    rarity: string | null
    earnedAt: Date | null
  }

  export type UserAchievementCountAggregateOutputType = {
    id: number
    userId: number
    achievementType: number
    achievementName: number
    description: number
    value: number
    target: number
    rarity: number
    earnedAt: number
    _all: number
  }


  export type UserAchievementAvgAggregateInputType = {
    value?: true
    target?: true
  }

  export type UserAchievementSumAggregateInputType = {
    value?: true
    target?: true
  }

  export type UserAchievementMinAggregateInputType = {
    id?: true
    userId?: true
    achievementType?: true
    achievementName?: true
    description?: true
    value?: true
    target?: true
    rarity?: true
    earnedAt?: true
  }

  export type UserAchievementMaxAggregateInputType = {
    id?: true
    userId?: true
    achievementType?: true
    achievementName?: true
    description?: true
    value?: true
    target?: true
    rarity?: true
    earnedAt?: true
  }

  export type UserAchievementCountAggregateInputType = {
    id?: true
    userId?: true
    achievementType?: true
    achievementName?: true
    description?: true
    value?: true
    target?: true
    rarity?: true
    earnedAt?: true
    _all?: true
  }

  export type UserAchievementAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievement to aggregate.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned UserAchievements
    **/
    _count?: true | UserAchievementCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: UserAchievementAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: UserAchievementSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserAchievementMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserAchievementMaxAggregateInputType
  }

  export type GetUserAchievementAggregateType<T extends UserAchievementAggregateArgs> = {
        [P in keyof T & keyof AggregateUserAchievement]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUserAchievement[P]>
      : GetScalarType<T[P], AggregateUserAchievement[P]>
  }




  export type UserAchievementGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserAchievementWhereInput
    orderBy?: UserAchievementOrderByWithAggregationInput | UserAchievementOrderByWithAggregationInput[]
    by: UserAchievementScalarFieldEnum[] | UserAchievementScalarFieldEnum
    having?: UserAchievementScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserAchievementCountAggregateInputType | true
    _avg?: UserAchievementAvgAggregateInputType
    _sum?: UserAchievementSumAggregateInputType
    _min?: UserAchievementMinAggregateInputType
    _max?: UserAchievementMaxAggregateInputType
  }

  export type UserAchievementGroupByOutputType = {
    id: string
    userId: string
    achievementType: string
    achievementName: string
    description: string | null
    value: number | null
    target: number | null
    rarity: string | null
    earnedAt: Date
    _count: UserAchievementCountAggregateOutputType | null
    _avg: UserAchievementAvgAggregateOutputType | null
    _sum: UserAchievementSumAggregateOutputType | null
    _min: UserAchievementMinAggregateOutputType | null
    _max: UserAchievementMaxAggregateOutputType | null
  }

  type GetUserAchievementGroupByPayload<T extends UserAchievementGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserAchievementGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserAchievementGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
            : GetScalarType<T[P], UserAchievementGroupByOutputType[P]>
        }
      >
    >


  export type UserAchievementSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    achievementType?: boolean
    achievementName?: boolean
    description?: boolean
    value?: boolean
    target?: boolean
    rarity?: boolean
    earnedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["userAchievement"]>


  export type UserAchievementSelectScalar = {
    id?: boolean
    userId?: boolean
    achievementType?: boolean
    achievementName?: boolean
    description?: boolean
    value?: boolean
    target?: boolean
    rarity?: boolean
    earnedAt?: boolean
  }

  export type UserAchievementInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $UserAchievementPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "UserAchievement"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      achievementType: string
      achievementName: string
      description: string | null
      value: number | null
      target: number | null
      rarity: string | null
      earnedAt: Date
    }, ExtArgs["result"]["userAchievement"]>
    composites: {}
  }

  type UserAchievementGetPayload<S extends boolean | null | undefined | UserAchievementDefaultArgs> = $Result.GetResult<Prisma.$UserAchievementPayload, S>

  type UserAchievementCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserAchievementFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserAchievementCountAggregateInputType | true
    }

  export interface UserAchievementDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['UserAchievement'], meta: { name: 'UserAchievement' } }
    /**
     * Find zero or one UserAchievement that matches the filter.
     * @param {UserAchievementFindUniqueArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserAchievementFindUniqueArgs>(args: SelectSubset<T, UserAchievementFindUniqueArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one UserAchievement that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserAchievementFindUniqueOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserAchievementFindUniqueOrThrowArgs>(args: SelectSubset<T, UserAchievementFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserAchievementFindFirstArgs>(args?: SelectSubset<T, UserAchievementFindFirstArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first UserAchievement that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindFirstOrThrowArgs} args - Arguments to find a UserAchievement
     * @example
     * // Get one UserAchievement
     * const userAchievement = await prisma.userAchievement.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserAchievementFindFirstOrThrowArgs>(args?: SelectSubset<T, UserAchievementFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more UserAchievements that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany()
     * 
     * // Get first 10 UserAchievements
     * const userAchievements = await prisma.userAchievement.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userAchievementWithIdOnly = await prisma.userAchievement.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserAchievementFindManyArgs>(args?: SelectSubset<T, UserAchievementFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a UserAchievement.
     * @param {UserAchievementCreateArgs} args - Arguments to create a UserAchievement.
     * @example
     * // Create one UserAchievement
     * const UserAchievement = await prisma.userAchievement.create({
     *   data: {
     *     // ... data to create a UserAchievement
     *   }
     * })
     * 
     */
    create<T extends UserAchievementCreateArgs>(args: SelectSubset<T, UserAchievementCreateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many UserAchievements.
     * @param {UserAchievementCreateManyArgs} args - Arguments to create many UserAchievements.
     * @example
     * // Create many UserAchievements
     * const userAchievement = await prisma.userAchievement.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserAchievementCreateManyArgs>(args?: SelectSubset<T, UserAchievementCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a UserAchievement.
     * @param {UserAchievementDeleteArgs} args - Arguments to delete one UserAchievement.
     * @example
     * // Delete one UserAchievement
     * const UserAchievement = await prisma.userAchievement.delete({
     *   where: {
     *     // ... filter to delete one UserAchievement
     *   }
     * })
     * 
     */
    delete<T extends UserAchievementDeleteArgs>(args: SelectSubset<T, UserAchievementDeleteArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one UserAchievement.
     * @param {UserAchievementUpdateArgs} args - Arguments to update one UserAchievement.
     * @example
     * // Update one UserAchievement
     * const userAchievement = await prisma.userAchievement.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserAchievementUpdateArgs>(args: SelectSubset<T, UserAchievementUpdateArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more UserAchievements.
     * @param {UserAchievementDeleteManyArgs} args - Arguments to filter UserAchievements to delete.
     * @example
     * // Delete a few UserAchievements
     * const { count } = await prisma.userAchievement.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserAchievementDeleteManyArgs>(args?: SelectSubset<T, UserAchievementDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many UserAchievements
     * const userAchievement = await prisma.userAchievement.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserAchievementUpdateManyArgs>(args: SelectSubset<T, UserAchievementUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one UserAchievement.
     * @param {UserAchievementUpsertArgs} args - Arguments to update or create a UserAchievement.
     * @example
     * // Update or create a UserAchievement
     * const userAchievement = await prisma.userAchievement.upsert({
     *   create: {
     *     // ... data to create a UserAchievement
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the UserAchievement we want to update
     *   }
     * })
     */
    upsert<T extends UserAchievementUpsertArgs>(args: SelectSubset<T, UserAchievementUpsertArgs<ExtArgs>>): Prisma__UserAchievementClient<$Result.GetResult<Prisma.$UserAchievementPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of UserAchievements.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementCountArgs} args - Arguments to filter UserAchievements to count.
     * @example
     * // Count the number of UserAchievements
     * const count = await prisma.userAchievement.count({
     *   where: {
     *     // ... the filter for the UserAchievements we want to count
     *   }
     * })
    **/
    count<T extends UserAchievementCountArgs>(
      args?: Subset<T, UserAchievementCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserAchievementCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAchievementAggregateArgs>(args: Subset<T, UserAchievementAggregateArgs>): Prisma.PrismaPromise<GetUserAchievementAggregateType<T>>

    /**
     * Group by UserAchievement.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAchievementGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserAchievementGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserAchievementGroupByArgs['orderBy'] }
        : { orderBy?: UserAchievementGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserAchievementGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserAchievementGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the UserAchievement model
   */
  readonly fields: UserAchievementFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for UserAchievement.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserAchievementClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the UserAchievement model
   */ 
  interface UserAchievementFieldRefs {
    readonly id: FieldRef<"UserAchievement", 'String'>
    readonly userId: FieldRef<"UserAchievement", 'String'>
    readonly achievementType: FieldRef<"UserAchievement", 'String'>
    readonly achievementName: FieldRef<"UserAchievement", 'String'>
    readonly description: FieldRef<"UserAchievement", 'String'>
    readonly value: FieldRef<"UserAchievement", 'Int'>
    readonly target: FieldRef<"UserAchievement", 'Int'>
    readonly rarity: FieldRef<"UserAchievement", 'String'>
    readonly earnedAt: FieldRef<"UserAchievement", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * UserAchievement findUnique
   */
  export type UserAchievementFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findUniqueOrThrow
   */
  export type UserAchievementFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement findFirst
   */
  export type UserAchievementFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findFirstOrThrow
   */
  export type UserAchievementFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievement to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of UserAchievements.
     */
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement findMany
   */
  export type UserAchievementFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter, which UserAchievements to fetch.
     */
    where?: UserAchievementWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of UserAchievements to fetch.
     */
    orderBy?: UserAchievementOrderByWithRelationInput | UserAchievementOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing UserAchievements.
     */
    cursor?: UserAchievementWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` UserAchievements from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` UserAchievements.
     */
    skip?: number
    distinct?: UserAchievementScalarFieldEnum | UserAchievementScalarFieldEnum[]
  }

  /**
   * UserAchievement create
   */
  export type UserAchievementCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to create a UserAchievement.
     */
    data: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
  }

  /**
   * UserAchievement createMany
   */
  export type UserAchievementCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many UserAchievements.
     */
    data: UserAchievementCreateManyInput | UserAchievementCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * UserAchievement update
   */
  export type UserAchievementUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The data needed to update a UserAchievement.
     */
    data: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
    /**
     * Choose, which UserAchievement to update.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement updateMany
   */
  export type UserAchievementUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update UserAchievements.
     */
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyInput>
    /**
     * Filter which UserAchievements to update
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement upsert
   */
  export type UserAchievementUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * The filter to search for the UserAchievement to update in case it exists.
     */
    where: UserAchievementWhereUniqueInput
    /**
     * In case the UserAchievement found by the `where` argument doesn't exist, create a new UserAchievement with this data.
     */
    create: XOR<UserAchievementCreateInput, UserAchievementUncheckedCreateInput>
    /**
     * In case the UserAchievement was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserAchievementUpdateInput, UserAchievementUncheckedUpdateInput>
  }

  /**
   * UserAchievement delete
   */
  export type UserAchievementDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
    /**
     * Filter which UserAchievement to delete.
     */
    where: UserAchievementWhereUniqueInput
  }

  /**
   * UserAchievement deleteMany
   */
  export type UserAchievementDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which UserAchievements to delete
     */
    where?: UserAchievementWhereInput
  }

  /**
   * UserAchievement without action
   */
  export type UserAchievementDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserAchievement
     */
    select?: UserAchievementSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserAchievementInclude<ExtArgs> | null
  }


  /**
   * Model Leaderboard
   */

  export type AggregateLeaderboard = {
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  export type LeaderboardAvgAggregateOutputType = {
    score: number | null
    rank: number | null
    previousRank: number | null
    totalCompletions: number | null
    currentStreak: number | null
  }

  export type LeaderboardSumAggregateOutputType = {
    score: number | null
    rank: number | null
    previousRank: number | null
    totalCompletions: number | null
    currentStreak: number | null
  }

  export type LeaderboardMinAggregateOutputType = {
    id: string | null
    userId: string | null
    leaderboardType: string | null
    relatedId: string | null
    timePeriod: string | null
    score: number | null
    rank: number | null
    previousRank: number | null
    totalCompletions: number | null
    currentStreak: number | null
    updatedAt: Date | null
  }

  export type LeaderboardMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    leaderboardType: string | null
    relatedId: string | null
    timePeriod: string | null
    score: number | null
    rank: number | null
    previousRank: number | null
    totalCompletions: number | null
    currentStreak: number | null
    updatedAt: Date | null
  }

  export type LeaderboardCountAggregateOutputType = {
    id: number
    userId: number
    leaderboardType: number
    relatedId: number
    timePeriod: number
    score: number
    rank: number
    previousRank: number
    totalCompletions: number
    currentStreak: number
    updatedAt: number
    _all: number
  }


  export type LeaderboardAvgAggregateInputType = {
    score?: true
    rank?: true
    previousRank?: true
    totalCompletions?: true
    currentStreak?: true
  }

  export type LeaderboardSumAggregateInputType = {
    score?: true
    rank?: true
    previousRank?: true
    totalCompletions?: true
    currentStreak?: true
  }

  export type LeaderboardMinAggregateInputType = {
    id?: true
    userId?: true
    leaderboardType?: true
    relatedId?: true
    timePeriod?: true
    score?: true
    rank?: true
    previousRank?: true
    totalCompletions?: true
    currentStreak?: true
    updatedAt?: true
  }

  export type LeaderboardMaxAggregateInputType = {
    id?: true
    userId?: true
    leaderboardType?: true
    relatedId?: true
    timePeriod?: true
    score?: true
    rank?: true
    previousRank?: true
    totalCompletions?: true
    currentStreak?: true
    updatedAt?: true
  }

  export type LeaderboardCountAggregateInputType = {
    id?: true
    userId?: true
    leaderboardType?: true
    relatedId?: true
    timePeriod?: true
    score?: true
    rank?: true
    previousRank?: true
    totalCompletions?: true
    currentStreak?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaderboardAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaderboard to aggregate.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Leaderboards
    **/
    _count?: true | LeaderboardCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaderboardAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaderboardSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaderboardMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaderboardMaxAggregateInputType
  }

  export type GetLeaderboardAggregateType<T extends LeaderboardAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaderboard]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaderboard[P]>
      : GetScalarType<T[P], AggregateLeaderboard[P]>
  }




  export type LeaderboardGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaderboardWhereInput
    orderBy?: LeaderboardOrderByWithAggregationInput | LeaderboardOrderByWithAggregationInput[]
    by: LeaderboardScalarFieldEnum[] | LeaderboardScalarFieldEnum
    having?: LeaderboardScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaderboardCountAggregateInputType | true
    _avg?: LeaderboardAvgAggregateInputType
    _sum?: LeaderboardSumAggregateInputType
    _min?: LeaderboardMinAggregateInputType
    _max?: LeaderboardMaxAggregateInputType
  }

  export type LeaderboardGroupByOutputType = {
    id: string
    userId: string
    leaderboardType: string
    relatedId: string | null
    timePeriod: string | null
    score: number
    rank: number | null
    previousRank: number | null
    totalCompletions: number
    currentStreak: number
    updatedAt: Date
    _count: LeaderboardCountAggregateOutputType | null
    _avg: LeaderboardAvgAggregateOutputType | null
    _sum: LeaderboardSumAggregateOutputType | null
    _min: LeaderboardMinAggregateOutputType | null
    _max: LeaderboardMaxAggregateOutputType | null
  }

  type GetLeaderboardGroupByPayload<T extends LeaderboardGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaderboardGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaderboardGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
            : GetScalarType<T[P], LeaderboardGroupByOutputType[P]>
        }
      >
    >


  export type LeaderboardSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    leaderboardType?: boolean
    relatedId?: boolean
    timePeriod?: boolean
    score?: boolean
    rank?: boolean
    previousRank?: boolean
    totalCompletions?: boolean
    currentStreak?: boolean
    updatedAt?: boolean
    user?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaderboard"]>


  export type LeaderboardSelectScalar = {
    id?: boolean
    userId?: boolean
    leaderboardType?: boolean
    relatedId?: boolean
    timePeriod?: boolean
    score?: boolean
    rank?: boolean
    previousRank?: boolean
    totalCompletions?: boolean
    currentStreak?: boolean
    updatedAt?: boolean
  }

  export type LeaderboardInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    user?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $LeaderboardPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Leaderboard"
    objects: {
      user: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string
      leaderboardType: string
      relatedId: string | null
      timePeriod: string | null
      score: number
      rank: number | null
      previousRank: number | null
      totalCompletions: number
      currentStreak: number
      updatedAt: Date
    }, ExtArgs["result"]["leaderboard"]>
    composites: {}
  }

  type LeaderboardGetPayload<S extends boolean | null | undefined | LeaderboardDefaultArgs> = $Result.GetResult<Prisma.$LeaderboardPayload, S>

  type LeaderboardCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaderboardFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaderboardCountAggregateInputType | true
    }

  export interface LeaderboardDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Leaderboard'], meta: { name: 'Leaderboard' } }
    /**
     * Find zero or one Leaderboard that matches the filter.
     * @param {LeaderboardFindUniqueArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaderboardFindUniqueArgs>(args: SelectSubset<T, LeaderboardFindUniqueArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Leaderboard that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaderboardFindUniqueOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaderboardFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaderboardFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Leaderboard that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindFirstArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaderboardFindFirstArgs>(args?: SelectSubset<T, LeaderboardFindFirstArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Leaderboard that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindFirstOrThrowArgs} args - Arguments to find a Leaderboard
     * @example
     * // Get one Leaderboard
     * const leaderboard = await prisma.leaderboard.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaderboardFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaderboardFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Leaderboards that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany()
     * 
     * // Get first 10 Leaderboards
     * const leaderboards = await prisma.leaderboard.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaderboardWithIdOnly = await prisma.leaderboard.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaderboardFindManyArgs>(args?: SelectSubset<T, LeaderboardFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Leaderboard.
     * @param {LeaderboardCreateArgs} args - Arguments to create a Leaderboard.
     * @example
     * // Create one Leaderboard
     * const Leaderboard = await prisma.leaderboard.create({
     *   data: {
     *     // ... data to create a Leaderboard
     *   }
     * })
     * 
     */
    create<T extends LeaderboardCreateArgs>(args: SelectSubset<T, LeaderboardCreateArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Leaderboards.
     * @param {LeaderboardCreateManyArgs} args - Arguments to create many Leaderboards.
     * @example
     * // Create many Leaderboards
     * const leaderboard = await prisma.leaderboard.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaderboardCreateManyArgs>(args?: SelectSubset<T, LeaderboardCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Leaderboard.
     * @param {LeaderboardDeleteArgs} args - Arguments to delete one Leaderboard.
     * @example
     * // Delete one Leaderboard
     * const Leaderboard = await prisma.leaderboard.delete({
     *   where: {
     *     // ... filter to delete one Leaderboard
     *   }
     * })
     * 
     */
    delete<T extends LeaderboardDeleteArgs>(args: SelectSubset<T, LeaderboardDeleteArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Leaderboard.
     * @param {LeaderboardUpdateArgs} args - Arguments to update one Leaderboard.
     * @example
     * // Update one Leaderboard
     * const leaderboard = await prisma.leaderboard.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaderboardUpdateArgs>(args: SelectSubset<T, LeaderboardUpdateArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Leaderboards.
     * @param {LeaderboardDeleteManyArgs} args - Arguments to filter Leaderboards to delete.
     * @example
     * // Delete a few Leaderboards
     * const { count } = await prisma.leaderboard.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaderboardDeleteManyArgs>(args?: SelectSubset<T, LeaderboardDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Leaderboards
     * const leaderboard = await prisma.leaderboard.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaderboardUpdateManyArgs>(args: SelectSubset<T, LeaderboardUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Leaderboard.
     * @param {LeaderboardUpsertArgs} args - Arguments to update or create a Leaderboard.
     * @example
     * // Update or create a Leaderboard
     * const leaderboard = await prisma.leaderboard.upsert({
     *   create: {
     *     // ... data to create a Leaderboard
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Leaderboard we want to update
     *   }
     * })
     */
    upsert<T extends LeaderboardUpsertArgs>(args: SelectSubset<T, LeaderboardUpsertArgs<ExtArgs>>): Prisma__LeaderboardClient<$Result.GetResult<Prisma.$LeaderboardPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Leaderboards.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardCountArgs} args - Arguments to filter Leaderboards to count.
     * @example
     * // Count the number of Leaderboards
     * const count = await prisma.leaderboard.count({
     *   where: {
     *     // ... the filter for the Leaderboards we want to count
     *   }
     * })
    **/
    count<T extends LeaderboardCountArgs>(
      args?: Subset<T, LeaderboardCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaderboardCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaderboardAggregateArgs>(args: Subset<T, LeaderboardAggregateArgs>): Prisma.PrismaPromise<GetLeaderboardAggregateType<T>>

    /**
     * Group by Leaderboard.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaderboardGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaderboardGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaderboardGroupByArgs['orderBy'] }
        : { orderBy?: LeaderboardGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaderboardGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaderboardGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Leaderboard model
   */
  readonly fields: LeaderboardFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Leaderboard.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaderboardClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Leaderboard model
   */ 
  interface LeaderboardFieldRefs {
    readonly id: FieldRef<"Leaderboard", 'String'>
    readonly userId: FieldRef<"Leaderboard", 'String'>
    readonly leaderboardType: FieldRef<"Leaderboard", 'String'>
    readonly relatedId: FieldRef<"Leaderboard", 'String'>
    readonly timePeriod: FieldRef<"Leaderboard", 'String'>
    readonly score: FieldRef<"Leaderboard", 'Int'>
    readonly rank: FieldRef<"Leaderboard", 'Int'>
    readonly previousRank: FieldRef<"Leaderboard", 'Int'>
    readonly totalCompletions: FieldRef<"Leaderboard", 'Int'>
    readonly currentStreak: FieldRef<"Leaderboard", 'Int'>
    readonly updatedAt: FieldRef<"Leaderboard", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Leaderboard findUnique
   */
  export type LeaderboardFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard findUniqueOrThrow
   */
  export type LeaderboardFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard findFirst
   */
  export type LeaderboardFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Leaderboard findFirstOrThrow
   */
  export type LeaderboardFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboard to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Leaderboards.
     */
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Leaderboard findMany
   */
  export type LeaderboardFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter, which Leaderboards to fetch.
     */
    where?: LeaderboardWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Leaderboards to fetch.
     */
    orderBy?: LeaderboardOrderByWithRelationInput | LeaderboardOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Leaderboards.
     */
    cursor?: LeaderboardWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Leaderboards from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Leaderboards.
     */
    skip?: number
    distinct?: LeaderboardScalarFieldEnum | LeaderboardScalarFieldEnum[]
  }

  /**
   * Leaderboard create
   */
  export type LeaderboardCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to create a Leaderboard.
     */
    data: XOR<LeaderboardCreateInput, LeaderboardUncheckedCreateInput>
  }

  /**
   * Leaderboard createMany
   */
  export type LeaderboardCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Leaderboards.
     */
    data: LeaderboardCreateManyInput | LeaderboardCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Leaderboard update
   */
  export type LeaderboardUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The data needed to update a Leaderboard.
     */
    data: XOR<LeaderboardUpdateInput, LeaderboardUncheckedUpdateInput>
    /**
     * Choose, which Leaderboard to update.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard updateMany
   */
  export type LeaderboardUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Leaderboards.
     */
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyInput>
    /**
     * Filter which Leaderboards to update
     */
    where?: LeaderboardWhereInput
  }

  /**
   * Leaderboard upsert
   */
  export type LeaderboardUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * The filter to search for the Leaderboard to update in case it exists.
     */
    where: LeaderboardWhereUniqueInput
    /**
     * In case the Leaderboard found by the `where` argument doesn't exist, create a new Leaderboard with this data.
     */
    create: XOR<LeaderboardCreateInput, LeaderboardUncheckedCreateInput>
    /**
     * In case the Leaderboard was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaderboardUpdateInput, LeaderboardUncheckedUpdateInput>
  }

  /**
   * Leaderboard delete
   */
  export type LeaderboardDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
    /**
     * Filter which Leaderboard to delete.
     */
    where: LeaderboardWhereUniqueInput
  }

  /**
   * Leaderboard deleteMany
   */
  export type LeaderboardDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Leaderboards to delete
     */
    where?: LeaderboardWhereInput
  }

  /**
   * Leaderboard without action
   */
  export type LeaderboardDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Leaderboard
     */
    select?: LeaderboardSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaderboardInclude<ExtArgs> | null
  }


  /**
   * Model EventChallenge
   */

  export type AggregateEventChallenge = {
    _count: EventChallengeCountAggregateOutputType | null
    _min: EventChallengeMinAggregateOutputType | null
    _max: EventChallengeMaxAggregateOutputType | null
  }

  export type EventChallengeMinAggregateOutputType = {
    eventId: string | null
    challengeId: string | null
  }

  export type EventChallengeMaxAggregateOutputType = {
    eventId: string | null
    challengeId: string | null
  }

  export type EventChallengeCountAggregateOutputType = {
    eventId: number
    challengeId: number
    _all: number
  }


  export type EventChallengeMinAggregateInputType = {
    eventId?: true
    challengeId?: true
  }

  export type EventChallengeMaxAggregateInputType = {
    eventId?: true
    challengeId?: true
  }

  export type EventChallengeCountAggregateInputType = {
    eventId?: true
    challengeId?: true
    _all?: true
  }

  export type EventChallengeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventChallenge to aggregate.
     */
    where?: EventChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventChallenges to fetch.
     */
    orderBy?: EventChallengeOrderByWithRelationInput | EventChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EventChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EventChallenges
    **/
    _count?: true | EventChallengeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EventChallengeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EventChallengeMaxAggregateInputType
  }

  export type GetEventChallengeAggregateType<T extends EventChallengeAggregateArgs> = {
        [P in keyof T & keyof AggregateEventChallenge]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEventChallenge[P]>
      : GetScalarType<T[P], AggregateEventChallenge[P]>
  }




  export type EventChallengeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EventChallengeWhereInput
    orderBy?: EventChallengeOrderByWithAggregationInput | EventChallengeOrderByWithAggregationInput[]
    by: EventChallengeScalarFieldEnum[] | EventChallengeScalarFieldEnum
    having?: EventChallengeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EventChallengeCountAggregateInputType | true
    _min?: EventChallengeMinAggregateInputType
    _max?: EventChallengeMaxAggregateInputType
  }

  export type EventChallengeGroupByOutputType = {
    eventId: string
    challengeId: string
    _count: EventChallengeCountAggregateOutputType | null
    _min: EventChallengeMinAggregateOutputType | null
    _max: EventChallengeMaxAggregateOutputType | null
  }

  type GetEventChallengeGroupByPayload<T extends EventChallengeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EventChallengeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EventChallengeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EventChallengeGroupByOutputType[P]>
            : GetScalarType<T[P], EventChallengeGroupByOutputType[P]>
        }
      >
    >


  export type EventChallengeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    eventId?: boolean
    challengeId?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["eventChallenge"]>


  export type EventChallengeSelectScalar = {
    eventId?: boolean
    challengeId?: boolean
  }

  export type EventChallengeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    challenge?: boolean | ChallengeDefaultArgs<ExtArgs>
  }

  export type $EventChallengePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EventChallenge"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      challenge: Prisma.$ChallengePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      eventId: string
      challengeId: string
    }, ExtArgs["result"]["eventChallenge"]>
    composites: {}
  }

  type EventChallengeGetPayload<S extends boolean | null | undefined | EventChallengeDefaultArgs> = $Result.GetResult<Prisma.$EventChallengePayload, S>

  type EventChallengeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EventChallengeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EventChallengeCountAggregateInputType | true
    }

  export interface EventChallengeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EventChallenge'], meta: { name: 'EventChallenge' } }
    /**
     * Find zero or one EventChallenge that matches the filter.
     * @param {EventChallengeFindUniqueArgs} args - Arguments to find a EventChallenge
     * @example
     * // Get one EventChallenge
     * const eventChallenge = await prisma.eventChallenge.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EventChallengeFindUniqueArgs>(args: SelectSubset<T, EventChallengeFindUniqueArgs<ExtArgs>>): Prisma__EventChallengeClient<$Result.GetResult<Prisma.$EventChallengePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EventChallenge that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EventChallengeFindUniqueOrThrowArgs} args - Arguments to find a EventChallenge
     * @example
     * // Get one EventChallenge
     * const eventChallenge = await prisma.eventChallenge.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EventChallengeFindUniqueOrThrowArgs>(args: SelectSubset<T, EventChallengeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EventChallengeClient<$Result.GetResult<Prisma.$EventChallengePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EventChallenge that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventChallengeFindFirstArgs} args - Arguments to find a EventChallenge
     * @example
     * // Get one EventChallenge
     * const eventChallenge = await prisma.eventChallenge.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EventChallengeFindFirstArgs>(args?: SelectSubset<T, EventChallengeFindFirstArgs<ExtArgs>>): Prisma__EventChallengeClient<$Result.GetResult<Prisma.$EventChallengePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EventChallenge that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventChallengeFindFirstOrThrowArgs} args - Arguments to find a EventChallenge
     * @example
     * // Get one EventChallenge
     * const eventChallenge = await prisma.eventChallenge.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EventChallengeFindFirstOrThrowArgs>(args?: SelectSubset<T, EventChallengeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EventChallengeClient<$Result.GetResult<Prisma.$EventChallengePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EventChallenges that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventChallengeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EventChallenges
     * const eventChallenges = await prisma.eventChallenge.findMany()
     * 
     * // Get first 10 EventChallenges
     * const eventChallenges = await prisma.eventChallenge.findMany({ take: 10 })
     * 
     * // Only select the `eventId`
     * const eventChallengeWithEventIdOnly = await prisma.eventChallenge.findMany({ select: { eventId: true } })
     * 
     */
    findMany<T extends EventChallengeFindManyArgs>(args?: SelectSubset<T, EventChallengeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventChallengePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EventChallenge.
     * @param {EventChallengeCreateArgs} args - Arguments to create a EventChallenge.
     * @example
     * // Create one EventChallenge
     * const EventChallenge = await prisma.eventChallenge.create({
     *   data: {
     *     // ... data to create a EventChallenge
     *   }
     * })
     * 
     */
    create<T extends EventChallengeCreateArgs>(args: SelectSubset<T, EventChallengeCreateArgs<ExtArgs>>): Prisma__EventChallengeClient<$Result.GetResult<Prisma.$EventChallengePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EventChallenges.
     * @param {EventChallengeCreateManyArgs} args - Arguments to create many EventChallenges.
     * @example
     * // Create many EventChallenges
     * const eventChallenge = await prisma.eventChallenge.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EventChallengeCreateManyArgs>(args?: SelectSubset<T, EventChallengeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EventChallenge.
     * @param {EventChallengeDeleteArgs} args - Arguments to delete one EventChallenge.
     * @example
     * // Delete one EventChallenge
     * const EventChallenge = await prisma.eventChallenge.delete({
     *   where: {
     *     // ... filter to delete one EventChallenge
     *   }
     * })
     * 
     */
    delete<T extends EventChallengeDeleteArgs>(args: SelectSubset<T, EventChallengeDeleteArgs<ExtArgs>>): Prisma__EventChallengeClient<$Result.GetResult<Prisma.$EventChallengePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EventChallenge.
     * @param {EventChallengeUpdateArgs} args - Arguments to update one EventChallenge.
     * @example
     * // Update one EventChallenge
     * const eventChallenge = await prisma.eventChallenge.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EventChallengeUpdateArgs>(args: SelectSubset<T, EventChallengeUpdateArgs<ExtArgs>>): Prisma__EventChallengeClient<$Result.GetResult<Prisma.$EventChallengePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EventChallenges.
     * @param {EventChallengeDeleteManyArgs} args - Arguments to filter EventChallenges to delete.
     * @example
     * // Delete a few EventChallenges
     * const { count } = await prisma.eventChallenge.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EventChallengeDeleteManyArgs>(args?: SelectSubset<T, EventChallengeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EventChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventChallengeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EventChallenges
     * const eventChallenge = await prisma.eventChallenge.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EventChallengeUpdateManyArgs>(args: SelectSubset<T, EventChallengeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EventChallenge.
     * @param {EventChallengeUpsertArgs} args - Arguments to update or create a EventChallenge.
     * @example
     * // Update or create a EventChallenge
     * const eventChallenge = await prisma.eventChallenge.upsert({
     *   create: {
     *     // ... data to create a EventChallenge
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EventChallenge we want to update
     *   }
     * })
     */
    upsert<T extends EventChallengeUpsertArgs>(args: SelectSubset<T, EventChallengeUpsertArgs<ExtArgs>>): Prisma__EventChallengeClient<$Result.GetResult<Prisma.$EventChallengePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EventChallenges.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventChallengeCountArgs} args - Arguments to filter EventChallenges to count.
     * @example
     * // Count the number of EventChallenges
     * const count = await prisma.eventChallenge.count({
     *   where: {
     *     // ... the filter for the EventChallenges we want to count
     *   }
     * })
    **/
    count<T extends EventChallengeCountArgs>(
      args?: Subset<T, EventChallengeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EventChallengeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EventChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventChallengeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EventChallengeAggregateArgs>(args: Subset<T, EventChallengeAggregateArgs>): Prisma.PrismaPromise<GetEventChallengeAggregateType<T>>

    /**
     * Group by EventChallenge.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EventChallengeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EventChallengeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EventChallengeGroupByArgs['orderBy'] }
        : { orderBy?: EventChallengeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EventChallengeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEventChallengeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EventChallenge model
   */
  readonly fields: EventChallengeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EventChallenge.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EventChallengeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    challenge<T extends ChallengeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ChallengeDefaultArgs<ExtArgs>>): Prisma__ChallengeClient<$Result.GetResult<Prisma.$ChallengePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EventChallenge model
   */ 
  interface EventChallengeFieldRefs {
    readonly eventId: FieldRef<"EventChallenge", 'String'>
    readonly challengeId: FieldRef<"EventChallenge", 'String'>
  }
    

  // Custom InputTypes
  /**
   * EventChallenge findUnique
   */
  export type EventChallengeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventChallenge
     */
    select?: EventChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventChallengeInclude<ExtArgs> | null
    /**
     * Filter, which EventChallenge to fetch.
     */
    where: EventChallengeWhereUniqueInput
  }

  /**
   * EventChallenge findUniqueOrThrow
   */
  export type EventChallengeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventChallenge
     */
    select?: EventChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventChallengeInclude<ExtArgs> | null
    /**
     * Filter, which EventChallenge to fetch.
     */
    where: EventChallengeWhereUniqueInput
  }

  /**
   * EventChallenge findFirst
   */
  export type EventChallengeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventChallenge
     */
    select?: EventChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventChallengeInclude<ExtArgs> | null
    /**
     * Filter, which EventChallenge to fetch.
     */
    where?: EventChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventChallenges to fetch.
     */
    orderBy?: EventChallengeOrderByWithRelationInput | EventChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventChallenges.
     */
    cursor?: EventChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventChallenges.
     */
    distinct?: EventChallengeScalarFieldEnum | EventChallengeScalarFieldEnum[]
  }

  /**
   * EventChallenge findFirstOrThrow
   */
  export type EventChallengeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventChallenge
     */
    select?: EventChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventChallengeInclude<ExtArgs> | null
    /**
     * Filter, which EventChallenge to fetch.
     */
    where?: EventChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventChallenges to fetch.
     */
    orderBy?: EventChallengeOrderByWithRelationInput | EventChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EventChallenges.
     */
    cursor?: EventChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventChallenges.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EventChallenges.
     */
    distinct?: EventChallengeScalarFieldEnum | EventChallengeScalarFieldEnum[]
  }

  /**
   * EventChallenge findMany
   */
  export type EventChallengeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventChallenge
     */
    select?: EventChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventChallengeInclude<ExtArgs> | null
    /**
     * Filter, which EventChallenges to fetch.
     */
    where?: EventChallengeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EventChallenges to fetch.
     */
    orderBy?: EventChallengeOrderByWithRelationInput | EventChallengeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EventChallenges.
     */
    cursor?: EventChallengeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EventChallenges from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EventChallenges.
     */
    skip?: number
    distinct?: EventChallengeScalarFieldEnum | EventChallengeScalarFieldEnum[]
  }

  /**
   * EventChallenge create
   */
  export type EventChallengeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventChallenge
     */
    select?: EventChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventChallengeInclude<ExtArgs> | null
    /**
     * The data needed to create a EventChallenge.
     */
    data: XOR<EventChallengeCreateInput, EventChallengeUncheckedCreateInput>
  }

  /**
   * EventChallenge createMany
   */
  export type EventChallengeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EventChallenges.
     */
    data: EventChallengeCreateManyInput | EventChallengeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EventChallenge update
   */
  export type EventChallengeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventChallenge
     */
    select?: EventChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventChallengeInclude<ExtArgs> | null
    /**
     * The data needed to update a EventChallenge.
     */
    data: XOR<EventChallengeUpdateInput, EventChallengeUncheckedUpdateInput>
    /**
     * Choose, which EventChallenge to update.
     */
    where: EventChallengeWhereUniqueInput
  }

  /**
   * EventChallenge updateMany
   */
  export type EventChallengeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EventChallenges.
     */
    data: XOR<EventChallengeUpdateManyMutationInput, EventChallengeUncheckedUpdateManyInput>
    /**
     * Filter which EventChallenges to update
     */
    where?: EventChallengeWhereInput
  }

  /**
   * EventChallenge upsert
   */
  export type EventChallengeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventChallenge
     */
    select?: EventChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventChallengeInclude<ExtArgs> | null
    /**
     * The filter to search for the EventChallenge to update in case it exists.
     */
    where: EventChallengeWhereUniqueInput
    /**
     * In case the EventChallenge found by the `where` argument doesn't exist, create a new EventChallenge with this data.
     */
    create: XOR<EventChallengeCreateInput, EventChallengeUncheckedCreateInput>
    /**
     * In case the EventChallenge was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EventChallengeUpdateInput, EventChallengeUncheckedUpdateInput>
  }

  /**
   * EventChallenge delete
   */
  export type EventChallengeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventChallenge
     */
    select?: EventChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventChallengeInclude<ExtArgs> | null
    /**
     * Filter which EventChallenge to delete.
     */
    where: EventChallengeWhereUniqueInput
  }

  /**
   * EventChallenge deleteMany
   */
  export type EventChallengeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EventChallenges to delete
     */
    where?: EventChallengeWhereInput
  }

  /**
   * EventChallenge without action
   */
  export type EventChallengeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EventChallenge
     */
    select?: EventChallengeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventChallengeInclude<ExtArgs> | null
  }


  /**
   * Model Roadmap
   */

  export type AggregateRoadmap = {
    _count: RoadmapCountAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  export type RoadmapMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    roleTarget: string | null
    createdAt: Date | null
  }

  export type RoadmapMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    roleTarget: string | null
    createdAt: Date | null
  }

  export type RoadmapCountAggregateOutputType = {
    id: number
    title: number
    description: number
    roleTarget: number
    createdAt: number
    _all: number
  }


  export type RoadmapMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    roleTarget?: true
    createdAt?: true
  }

  export type RoadmapMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    roleTarget?: true
    createdAt?: true
  }

  export type RoadmapCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    roleTarget?: true
    createdAt?: true
    _all?: true
  }

  export type RoadmapAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roadmap to aggregate.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Roadmaps
    **/
    _count?: true | RoadmapCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapMaxAggregateInputType
  }

  export type GetRoadmapAggregateType<T extends RoadmapAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmap]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmap[P]>
      : GetScalarType<T[P], AggregateRoadmap[P]>
  }




  export type RoadmapGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapWhereInput
    orderBy?: RoadmapOrderByWithAggregationInput | RoadmapOrderByWithAggregationInput[]
    by: RoadmapScalarFieldEnum[] | RoadmapScalarFieldEnum
    having?: RoadmapScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapCountAggregateInputType | true
    _min?: RoadmapMinAggregateInputType
    _max?: RoadmapMaxAggregateInputType
  }

  export type RoadmapGroupByOutputType = {
    id: string
    title: string
    description: string
    roleTarget: string
    createdAt: Date
    _count: RoadmapCountAggregateOutputType | null
    _min: RoadmapMinAggregateOutputType | null
    _max: RoadmapMaxAggregateOutputType | null
  }

  type GetRoadmapGroupByPayload<T extends RoadmapGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    roleTarget?: boolean
    createdAt?: boolean
    phases?: boolean | Roadmap$phasesArgs<ExtArgs>
    events?: boolean | Roadmap$eventsArgs<ExtArgs>
    _count?: boolean | RoadmapCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmap"]>


  export type RoadmapSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    roleTarget?: boolean
    createdAt?: boolean
  }

  export type RoadmapInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phases?: boolean | Roadmap$phasesArgs<ExtArgs>
    events?: boolean | Roadmap$eventsArgs<ExtArgs>
    _count?: boolean | RoadmapCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RoadmapPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Roadmap"
    objects: {
      phases: Prisma.$RoadmapPhasePayload<ExtArgs>[]
      events: Prisma.$EventPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      roleTarget: string
      createdAt: Date
    }, ExtArgs["result"]["roadmap"]>
    composites: {}
  }

  type RoadmapGetPayload<S extends boolean | null | undefined | RoadmapDefaultArgs> = $Result.GetResult<Prisma.$RoadmapPayload, S>

  type RoadmapCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoadmapFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadmapCountAggregateInputType | true
    }

  export interface RoadmapDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Roadmap'], meta: { name: 'Roadmap' } }
    /**
     * Find zero or one Roadmap that matches the filter.
     * @param {RoadmapFindUniqueArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapFindUniqueArgs>(args: SelectSubset<T, RoadmapFindUniqueArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Roadmap that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoadmapFindUniqueOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Roadmap that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindFirstArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapFindFirstArgs>(args?: SelectSubset<T, RoadmapFindFirstArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Roadmap that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindFirstOrThrowArgs} args - Arguments to find a Roadmap
     * @example
     * // Get one Roadmap
     * const roadmap = await prisma.roadmap.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Roadmaps that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Roadmaps
     * const roadmaps = await prisma.roadmap.findMany()
     * 
     * // Get first 10 Roadmaps
     * const roadmaps = await prisma.roadmap.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapWithIdOnly = await prisma.roadmap.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapFindManyArgs>(args?: SelectSubset<T, RoadmapFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Roadmap.
     * @param {RoadmapCreateArgs} args - Arguments to create a Roadmap.
     * @example
     * // Create one Roadmap
     * const Roadmap = await prisma.roadmap.create({
     *   data: {
     *     // ... data to create a Roadmap
     *   }
     * })
     * 
     */
    create<T extends RoadmapCreateArgs>(args: SelectSubset<T, RoadmapCreateArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Roadmaps.
     * @param {RoadmapCreateManyArgs} args - Arguments to create many Roadmaps.
     * @example
     * // Create many Roadmaps
     * const roadmap = await prisma.roadmap.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapCreateManyArgs>(args?: SelectSubset<T, RoadmapCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Roadmap.
     * @param {RoadmapDeleteArgs} args - Arguments to delete one Roadmap.
     * @example
     * // Delete one Roadmap
     * const Roadmap = await prisma.roadmap.delete({
     *   where: {
     *     // ... filter to delete one Roadmap
     *   }
     * })
     * 
     */
    delete<T extends RoadmapDeleteArgs>(args: SelectSubset<T, RoadmapDeleteArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Roadmap.
     * @param {RoadmapUpdateArgs} args - Arguments to update one Roadmap.
     * @example
     * // Update one Roadmap
     * const roadmap = await prisma.roadmap.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapUpdateArgs>(args: SelectSubset<T, RoadmapUpdateArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Roadmaps.
     * @param {RoadmapDeleteManyArgs} args - Arguments to filter Roadmaps to delete.
     * @example
     * // Delete a few Roadmaps
     * const { count } = await prisma.roadmap.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapDeleteManyArgs>(args?: SelectSubset<T, RoadmapDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Roadmaps
     * const roadmap = await prisma.roadmap.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapUpdateManyArgs>(args: SelectSubset<T, RoadmapUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Roadmap.
     * @param {RoadmapUpsertArgs} args - Arguments to update or create a Roadmap.
     * @example
     * // Update or create a Roadmap
     * const roadmap = await prisma.roadmap.upsert({
     *   create: {
     *     // ... data to create a Roadmap
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Roadmap we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapUpsertArgs>(args: SelectSubset<T, RoadmapUpsertArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Roadmaps.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapCountArgs} args - Arguments to filter Roadmaps to count.
     * @example
     * // Count the number of Roadmaps
     * const count = await prisma.roadmap.count({
     *   where: {
     *     // ... the filter for the Roadmaps we want to count
     *   }
     * })
    **/
    count<T extends RoadmapCountArgs>(
      args?: Subset<T, RoadmapCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapAggregateArgs>(args: Subset<T, RoadmapAggregateArgs>): Prisma.PrismaPromise<GetRoadmapAggregateType<T>>

    /**
     * Group by Roadmap.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Roadmap model
   */
  readonly fields: RoadmapFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Roadmap.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phases<T extends Roadmap$phasesArgs<ExtArgs> = {}>(args?: Subset<T, Roadmap$phasesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findMany"> | Null>
    events<T extends Roadmap$eventsArgs<ExtArgs> = {}>(args?: Subset<T, Roadmap$eventsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Roadmap model
   */ 
  interface RoadmapFieldRefs {
    readonly id: FieldRef<"Roadmap", 'String'>
    readonly title: FieldRef<"Roadmap", 'String'>
    readonly description: FieldRef<"Roadmap", 'String'>
    readonly roleTarget: FieldRef<"Roadmap", 'String'>
    readonly createdAt: FieldRef<"Roadmap", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Roadmap findUnique
   */
  export type RoadmapFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap findUniqueOrThrow
   */
  export type RoadmapFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap findFirst
   */
  export type RoadmapFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap findFirstOrThrow
   */
  export type RoadmapFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmap to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Roadmaps.
     */
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap findMany
   */
  export type RoadmapFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter, which Roadmaps to fetch.
     */
    where?: RoadmapWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Roadmaps to fetch.
     */
    orderBy?: RoadmapOrderByWithRelationInput | RoadmapOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Roadmaps.
     */
    cursor?: RoadmapWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Roadmaps from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Roadmaps.
     */
    skip?: number
    distinct?: RoadmapScalarFieldEnum | RoadmapScalarFieldEnum[]
  }

  /**
   * Roadmap create
   */
  export type RoadmapCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The data needed to create a Roadmap.
     */
    data: XOR<RoadmapCreateInput, RoadmapUncheckedCreateInput>
  }

  /**
   * Roadmap createMany
   */
  export type RoadmapCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Roadmaps.
     */
    data: RoadmapCreateManyInput | RoadmapCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Roadmap update
   */
  export type RoadmapUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The data needed to update a Roadmap.
     */
    data: XOR<RoadmapUpdateInput, RoadmapUncheckedUpdateInput>
    /**
     * Choose, which Roadmap to update.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap updateMany
   */
  export type RoadmapUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Roadmaps.
     */
    data: XOR<RoadmapUpdateManyMutationInput, RoadmapUncheckedUpdateManyInput>
    /**
     * Filter which Roadmaps to update
     */
    where?: RoadmapWhereInput
  }

  /**
   * Roadmap upsert
   */
  export type RoadmapUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * The filter to search for the Roadmap to update in case it exists.
     */
    where: RoadmapWhereUniqueInput
    /**
     * In case the Roadmap found by the `where` argument doesn't exist, create a new Roadmap with this data.
     */
    create: XOR<RoadmapCreateInput, RoadmapUncheckedCreateInput>
    /**
     * In case the Roadmap was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapUpdateInput, RoadmapUncheckedUpdateInput>
  }

  /**
   * Roadmap delete
   */
  export type RoadmapDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
    /**
     * Filter which Roadmap to delete.
     */
    where: RoadmapWhereUniqueInput
  }

  /**
   * Roadmap deleteMany
   */
  export type RoadmapDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Roadmaps to delete
     */
    where?: RoadmapWhereInput
  }

  /**
   * Roadmap.phases
   */
  export type Roadmap$phasesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    where?: RoadmapPhaseWhereInput
    orderBy?: RoadmapPhaseOrderByWithRelationInput | RoadmapPhaseOrderByWithRelationInput[]
    cursor?: RoadmapPhaseWhereUniqueInput
    take?: number
    skip?: number
    distinct?: RoadmapPhaseScalarFieldEnum | RoadmapPhaseScalarFieldEnum[]
  }

  /**
   * Roadmap.events
   */
  export type Roadmap$eventsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Event
     */
    select?: EventSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EventInclude<ExtArgs> | null
    where?: EventWhereInput
    orderBy?: EventOrderByWithRelationInput | EventOrderByWithRelationInput[]
    cursor?: EventWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EventScalarFieldEnum | EventScalarFieldEnum[]
  }

  /**
   * Roadmap without action
   */
  export type RoadmapDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Roadmap
     */
    select?: RoadmapSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapInclude<ExtArgs> | null
  }


  /**
   * Model RoadmapPhase
   */

  export type AggregateRoadmapPhase = {
    _count: RoadmapPhaseCountAggregateOutputType | null
    _avg: RoadmapPhaseAvgAggregateOutputType | null
    _sum: RoadmapPhaseSumAggregateOutputType | null
    _min: RoadmapPhaseMinAggregateOutputType | null
    _max: RoadmapPhaseMaxAggregateOutputType | null
  }

  export type RoadmapPhaseAvgAggregateOutputType = {
    order: number | null
  }

  export type RoadmapPhaseSumAggregateOutputType = {
    order: number | null
  }

  export type RoadmapPhaseMinAggregateOutputType = {
    id: string | null
    roadmapId: string | null
    order: number | null
    title: string | null
    level: string | null
    duration: string | null
    description: string | null
  }

  export type RoadmapPhaseMaxAggregateOutputType = {
    id: string | null
    roadmapId: string | null
    order: number | null
    title: string | null
    level: string | null
    duration: string | null
    description: string | null
  }

  export type RoadmapPhaseCountAggregateOutputType = {
    id: number
    roadmapId: number
    order: number
    title: number
    level: number
    duration: number
    description: number
    _all: number
  }


  export type RoadmapPhaseAvgAggregateInputType = {
    order?: true
  }

  export type RoadmapPhaseSumAggregateInputType = {
    order?: true
  }

  export type RoadmapPhaseMinAggregateInputType = {
    id?: true
    roadmapId?: true
    order?: true
    title?: true
    level?: true
    duration?: true
    description?: true
  }

  export type RoadmapPhaseMaxAggregateInputType = {
    id?: true
    roadmapId?: true
    order?: true
    title?: true
    level?: true
    duration?: true
    description?: true
  }

  export type RoadmapPhaseCountAggregateInputType = {
    id?: true
    roadmapId?: true
    order?: true
    title?: true
    level?: true
    duration?: true
    description?: true
    _all?: true
  }

  export type RoadmapPhaseAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapPhase to aggregate.
     */
    where?: RoadmapPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapPhases to fetch.
     */
    orderBy?: RoadmapPhaseOrderByWithRelationInput | RoadmapPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: RoadmapPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned RoadmapPhases
    **/
    _count?: true | RoadmapPhaseCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: RoadmapPhaseAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: RoadmapPhaseSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: RoadmapPhaseMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: RoadmapPhaseMaxAggregateInputType
  }

  export type GetRoadmapPhaseAggregateType<T extends RoadmapPhaseAggregateArgs> = {
        [P in keyof T & keyof AggregateRoadmapPhase]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateRoadmapPhase[P]>
      : GetScalarType<T[P], AggregateRoadmapPhase[P]>
  }




  export type RoadmapPhaseGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: RoadmapPhaseWhereInput
    orderBy?: RoadmapPhaseOrderByWithAggregationInput | RoadmapPhaseOrderByWithAggregationInput[]
    by: RoadmapPhaseScalarFieldEnum[] | RoadmapPhaseScalarFieldEnum
    having?: RoadmapPhaseScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: RoadmapPhaseCountAggregateInputType | true
    _avg?: RoadmapPhaseAvgAggregateInputType
    _sum?: RoadmapPhaseSumAggregateInputType
    _min?: RoadmapPhaseMinAggregateInputType
    _max?: RoadmapPhaseMaxAggregateInputType
  }

  export type RoadmapPhaseGroupByOutputType = {
    id: string
    roadmapId: string
    order: number
    title: string
    level: string | null
    duration: string | null
    description: string | null
    _count: RoadmapPhaseCountAggregateOutputType | null
    _avg: RoadmapPhaseAvgAggregateOutputType | null
    _sum: RoadmapPhaseSumAggregateOutputType | null
    _min: RoadmapPhaseMinAggregateOutputType | null
    _max: RoadmapPhaseMaxAggregateOutputType | null
  }

  type GetRoadmapPhaseGroupByPayload<T extends RoadmapPhaseGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<RoadmapPhaseGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof RoadmapPhaseGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], RoadmapPhaseGroupByOutputType[P]>
            : GetScalarType<T[P], RoadmapPhaseGroupByOutputType[P]>
        }
      >
    >


  export type RoadmapPhaseSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    roadmapId?: boolean
    order?: boolean
    title?: boolean
    level?: boolean
    duration?: boolean
    description?: boolean
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    sections?: boolean | RoadmapPhase$sectionsArgs<ExtArgs>
    playlists?: boolean | RoadmapPhase$playlistsArgs<ExtArgs>
    projects?: boolean | RoadmapPhase$projectsArgs<ExtArgs>
    _count?: boolean | RoadmapPhaseCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["roadmapPhase"]>


  export type RoadmapPhaseSelectScalar = {
    id?: boolean
    roadmapId?: boolean
    order?: boolean
    title?: boolean
    level?: boolean
    duration?: boolean
    description?: boolean
  }

  export type RoadmapPhaseInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    roadmap?: boolean | RoadmapDefaultArgs<ExtArgs>
    sections?: boolean | RoadmapPhase$sectionsArgs<ExtArgs>
    playlists?: boolean | RoadmapPhase$playlistsArgs<ExtArgs>
    projects?: boolean | RoadmapPhase$projectsArgs<ExtArgs>
    _count?: boolean | RoadmapPhaseCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $RoadmapPhasePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "RoadmapPhase"
    objects: {
      roadmap: Prisma.$RoadmapPayload<ExtArgs>
      sections: Prisma.$PhaseSectionPayload<ExtArgs>[]
      playlists: Prisma.$PhasePlaylistPayload<ExtArgs>[]
      projects: Prisma.$PhaseProjectPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      roadmapId: string
      order: number
      title: string
      level: string | null
      duration: string | null
      description: string | null
    }, ExtArgs["result"]["roadmapPhase"]>
    composites: {}
  }

  type RoadmapPhaseGetPayload<S extends boolean | null | undefined | RoadmapPhaseDefaultArgs> = $Result.GetResult<Prisma.$RoadmapPhasePayload, S>

  type RoadmapPhaseCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<RoadmapPhaseFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: RoadmapPhaseCountAggregateInputType | true
    }

  export interface RoadmapPhaseDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['RoadmapPhase'], meta: { name: 'RoadmapPhase' } }
    /**
     * Find zero or one RoadmapPhase that matches the filter.
     * @param {RoadmapPhaseFindUniqueArgs} args - Arguments to find a RoadmapPhase
     * @example
     * // Get one RoadmapPhase
     * const roadmapPhase = await prisma.roadmapPhase.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends RoadmapPhaseFindUniqueArgs>(args: SelectSubset<T, RoadmapPhaseFindUniqueArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one RoadmapPhase that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {RoadmapPhaseFindUniqueOrThrowArgs} args - Arguments to find a RoadmapPhase
     * @example
     * // Get one RoadmapPhase
     * const roadmapPhase = await prisma.roadmapPhase.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends RoadmapPhaseFindUniqueOrThrowArgs>(args: SelectSubset<T, RoadmapPhaseFindUniqueOrThrowArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first RoadmapPhase that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseFindFirstArgs} args - Arguments to find a RoadmapPhase
     * @example
     * // Get one RoadmapPhase
     * const roadmapPhase = await prisma.roadmapPhase.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends RoadmapPhaseFindFirstArgs>(args?: SelectSubset<T, RoadmapPhaseFindFirstArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first RoadmapPhase that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseFindFirstOrThrowArgs} args - Arguments to find a RoadmapPhase
     * @example
     * // Get one RoadmapPhase
     * const roadmapPhase = await prisma.roadmapPhase.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends RoadmapPhaseFindFirstOrThrowArgs>(args?: SelectSubset<T, RoadmapPhaseFindFirstOrThrowArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more RoadmapPhases that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all RoadmapPhases
     * const roadmapPhases = await prisma.roadmapPhase.findMany()
     * 
     * // Get first 10 RoadmapPhases
     * const roadmapPhases = await prisma.roadmapPhase.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const roadmapPhaseWithIdOnly = await prisma.roadmapPhase.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends RoadmapPhaseFindManyArgs>(args?: SelectSubset<T, RoadmapPhaseFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a RoadmapPhase.
     * @param {RoadmapPhaseCreateArgs} args - Arguments to create a RoadmapPhase.
     * @example
     * // Create one RoadmapPhase
     * const RoadmapPhase = await prisma.roadmapPhase.create({
     *   data: {
     *     // ... data to create a RoadmapPhase
     *   }
     * })
     * 
     */
    create<T extends RoadmapPhaseCreateArgs>(args: SelectSubset<T, RoadmapPhaseCreateArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many RoadmapPhases.
     * @param {RoadmapPhaseCreateManyArgs} args - Arguments to create many RoadmapPhases.
     * @example
     * // Create many RoadmapPhases
     * const roadmapPhase = await prisma.roadmapPhase.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends RoadmapPhaseCreateManyArgs>(args?: SelectSubset<T, RoadmapPhaseCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a RoadmapPhase.
     * @param {RoadmapPhaseDeleteArgs} args - Arguments to delete one RoadmapPhase.
     * @example
     * // Delete one RoadmapPhase
     * const RoadmapPhase = await prisma.roadmapPhase.delete({
     *   where: {
     *     // ... filter to delete one RoadmapPhase
     *   }
     * })
     * 
     */
    delete<T extends RoadmapPhaseDeleteArgs>(args: SelectSubset<T, RoadmapPhaseDeleteArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one RoadmapPhase.
     * @param {RoadmapPhaseUpdateArgs} args - Arguments to update one RoadmapPhase.
     * @example
     * // Update one RoadmapPhase
     * const roadmapPhase = await prisma.roadmapPhase.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends RoadmapPhaseUpdateArgs>(args: SelectSubset<T, RoadmapPhaseUpdateArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more RoadmapPhases.
     * @param {RoadmapPhaseDeleteManyArgs} args - Arguments to filter RoadmapPhases to delete.
     * @example
     * // Delete a few RoadmapPhases
     * const { count } = await prisma.roadmapPhase.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends RoadmapPhaseDeleteManyArgs>(args?: SelectSubset<T, RoadmapPhaseDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more RoadmapPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many RoadmapPhases
     * const roadmapPhase = await prisma.roadmapPhase.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends RoadmapPhaseUpdateManyArgs>(args: SelectSubset<T, RoadmapPhaseUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one RoadmapPhase.
     * @param {RoadmapPhaseUpsertArgs} args - Arguments to update or create a RoadmapPhase.
     * @example
     * // Update or create a RoadmapPhase
     * const roadmapPhase = await prisma.roadmapPhase.upsert({
     *   create: {
     *     // ... data to create a RoadmapPhase
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the RoadmapPhase we want to update
     *   }
     * })
     */
    upsert<T extends RoadmapPhaseUpsertArgs>(args: SelectSubset<T, RoadmapPhaseUpsertArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of RoadmapPhases.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseCountArgs} args - Arguments to filter RoadmapPhases to count.
     * @example
     * // Count the number of RoadmapPhases
     * const count = await prisma.roadmapPhase.count({
     *   where: {
     *     // ... the filter for the RoadmapPhases we want to count
     *   }
     * })
    **/
    count<T extends RoadmapPhaseCountArgs>(
      args?: Subset<T, RoadmapPhaseCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], RoadmapPhaseCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a RoadmapPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends RoadmapPhaseAggregateArgs>(args: Subset<T, RoadmapPhaseAggregateArgs>): Prisma.PrismaPromise<GetRoadmapPhaseAggregateType<T>>

    /**
     * Group by RoadmapPhase.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {RoadmapPhaseGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends RoadmapPhaseGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: RoadmapPhaseGroupByArgs['orderBy'] }
        : { orderBy?: RoadmapPhaseGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, RoadmapPhaseGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetRoadmapPhaseGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the RoadmapPhase model
   */
  readonly fields: RoadmapPhaseFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for RoadmapPhase.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__RoadmapPhaseClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    roadmap<T extends RoadmapDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapDefaultArgs<ExtArgs>>): Prisma__RoadmapClient<$Result.GetResult<Prisma.$RoadmapPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sections<T extends RoadmapPhase$sectionsArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapPhase$sectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhaseSectionPayload<ExtArgs>, T, "findMany"> | Null>
    playlists<T extends RoadmapPhase$playlistsArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapPhase$playlistsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhasePlaylistPayload<ExtArgs>, T, "findMany"> | Null>
    projects<T extends RoadmapPhase$projectsArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapPhase$projectsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhaseProjectPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the RoadmapPhase model
   */ 
  interface RoadmapPhaseFieldRefs {
    readonly id: FieldRef<"RoadmapPhase", 'String'>
    readonly roadmapId: FieldRef<"RoadmapPhase", 'String'>
    readonly order: FieldRef<"RoadmapPhase", 'Int'>
    readonly title: FieldRef<"RoadmapPhase", 'String'>
    readonly level: FieldRef<"RoadmapPhase", 'String'>
    readonly duration: FieldRef<"RoadmapPhase", 'String'>
    readonly description: FieldRef<"RoadmapPhase", 'String'>
  }
    

  // Custom InputTypes
  /**
   * RoadmapPhase findUnique
   */
  export type RoadmapPhaseFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapPhase to fetch.
     */
    where: RoadmapPhaseWhereUniqueInput
  }

  /**
   * RoadmapPhase findUniqueOrThrow
   */
  export type RoadmapPhaseFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapPhase to fetch.
     */
    where: RoadmapPhaseWhereUniqueInput
  }

  /**
   * RoadmapPhase findFirst
   */
  export type RoadmapPhaseFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapPhase to fetch.
     */
    where?: RoadmapPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapPhases to fetch.
     */
    orderBy?: RoadmapPhaseOrderByWithRelationInput | RoadmapPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapPhases.
     */
    cursor?: RoadmapPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapPhases.
     */
    distinct?: RoadmapPhaseScalarFieldEnum | RoadmapPhaseScalarFieldEnum[]
  }

  /**
   * RoadmapPhase findFirstOrThrow
   */
  export type RoadmapPhaseFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapPhase to fetch.
     */
    where?: RoadmapPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapPhases to fetch.
     */
    orderBy?: RoadmapPhaseOrderByWithRelationInput | RoadmapPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for RoadmapPhases.
     */
    cursor?: RoadmapPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapPhases.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of RoadmapPhases.
     */
    distinct?: RoadmapPhaseScalarFieldEnum | RoadmapPhaseScalarFieldEnum[]
  }

  /**
   * RoadmapPhase findMany
   */
  export type RoadmapPhaseFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * Filter, which RoadmapPhases to fetch.
     */
    where?: RoadmapPhaseWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of RoadmapPhases to fetch.
     */
    orderBy?: RoadmapPhaseOrderByWithRelationInput | RoadmapPhaseOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing RoadmapPhases.
     */
    cursor?: RoadmapPhaseWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` RoadmapPhases from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` RoadmapPhases.
     */
    skip?: number
    distinct?: RoadmapPhaseScalarFieldEnum | RoadmapPhaseScalarFieldEnum[]
  }

  /**
   * RoadmapPhase create
   */
  export type RoadmapPhaseCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * The data needed to create a RoadmapPhase.
     */
    data: XOR<RoadmapPhaseCreateInput, RoadmapPhaseUncheckedCreateInput>
  }

  /**
   * RoadmapPhase createMany
   */
  export type RoadmapPhaseCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many RoadmapPhases.
     */
    data: RoadmapPhaseCreateManyInput | RoadmapPhaseCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * RoadmapPhase update
   */
  export type RoadmapPhaseUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * The data needed to update a RoadmapPhase.
     */
    data: XOR<RoadmapPhaseUpdateInput, RoadmapPhaseUncheckedUpdateInput>
    /**
     * Choose, which RoadmapPhase to update.
     */
    where: RoadmapPhaseWhereUniqueInput
  }

  /**
   * RoadmapPhase updateMany
   */
  export type RoadmapPhaseUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update RoadmapPhases.
     */
    data: XOR<RoadmapPhaseUpdateManyMutationInput, RoadmapPhaseUncheckedUpdateManyInput>
    /**
     * Filter which RoadmapPhases to update
     */
    where?: RoadmapPhaseWhereInput
  }

  /**
   * RoadmapPhase upsert
   */
  export type RoadmapPhaseUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * The filter to search for the RoadmapPhase to update in case it exists.
     */
    where: RoadmapPhaseWhereUniqueInput
    /**
     * In case the RoadmapPhase found by the `where` argument doesn't exist, create a new RoadmapPhase with this data.
     */
    create: XOR<RoadmapPhaseCreateInput, RoadmapPhaseUncheckedCreateInput>
    /**
     * In case the RoadmapPhase was found with the provided `where` argument, update it with this data.
     */
    update: XOR<RoadmapPhaseUpdateInput, RoadmapPhaseUncheckedUpdateInput>
  }

  /**
   * RoadmapPhase delete
   */
  export type RoadmapPhaseDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
    /**
     * Filter which RoadmapPhase to delete.
     */
    where: RoadmapPhaseWhereUniqueInput
  }

  /**
   * RoadmapPhase deleteMany
   */
  export type RoadmapPhaseDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which RoadmapPhases to delete
     */
    where?: RoadmapPhaseWhereInput
  }

  /**
   * RoadmapPhase.sections
   */
  export type RoadmapPhase$sectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseSection
     */
    select?: PhaseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseSectionInclude<ExtArgs> | null
    where?: PhaseSectionWhereInput
    orderBy?: PhaseSectionOrderByWithRelationInput | PhaseSectionOrderByWithRelationInput[]
    cursor?: PhaseSectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhaseSectionScalarFieldEnum | PhaseSectionScalarFieldEnum[]
  }

  /**
   * RoadmapPhase.playlists
   */
  export type RoadmapPhase$playlistsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhasePlaylist
     */
    select?: PhasePlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhasePlaylistInclude<ExtArgs> | null
    where?: PhasePlaylistWhereInput
    orderBy?: PhasePlaylistOrderByWithRelationInput | PhasePlaylistOrderByWithRelationInput[]
    cursor?: PhasePlaylistWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhasePlaylistScalarFieldEnum | PhasePlaylistScalarFieldEnum[]
  }

  /**
   * RoadmapPhase.projects
   */
  export type RoadmapPhase$projectsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseProject
     */
    select?: PhaseProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseProjectInclude<ExtArgs> | null
    where?: PhaseProjectWhereInput
    orderBy?: PhaseProjectOrderByWithRelationInput | PhaseProjectOrderByWithRelationInput[]
    cursor?: PhaseProjectWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PhaseProjectScalarFieldEnum | PhaseProjectScalarFieldEnum[]
  }

  /**
   * RoadmapPhase without action
   */
  export type RoadmapPhaseDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the RoadmapPhase
     */
    select?: RoadmapPhaseSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: RoadmapPhaseInclude<ExtArgs> | null
  }


  /**
   * Model PhaseSection
   */

  export type AggregatePhaseSection = {
    _count: PhaseSectionCountAggregateOutputType | null
    _avg: PhaseSectionAvgAggregateOutputType | null
    _sum: PhaseSectionSumAggregateOutputType | null
    _min: PhaseSectionMinAggregateOutputType | null
    _max: PhaseSectionMaxAggregateOutputType | null
  }

  export type PhaseSectionAvgAggregateOutputType = {
    order: number | null
  }

  export type PhaseSectionSumAggregateOutputType = {
    order: number | null
  }

  export type PhaseSectionMinAggregateOutputType = {
    id: string | null
    phaseId: string | null
    title: string | null
    description: string | null
    order: number | null
  }

  export type PhaseSectionMaxAggregateOutputType = {
    id: string | null
    phaseId: string | null
    title: string | null
    description: string | null
    order: number | null
  }

  export type PhaseSectionCountAggregateOutputType = {
    id: number
    phaseId: number
    title: number
    description: number
    order: number
    _all: number
  }


  export type PhaseSectionAvgAggregateInputType = {
    order?: true
  }

  export type PhaseSectionSumAggregateInputType = {
    order?: true
  }

  export type PhaseSectionMinAggregateInputType = {
    id?: true
    phaseId?: true
    title?: true
    description?: true
    order?: true
  }

  export type PhaseSectionMaxAggregateInputType = {
    id?: true
    phaseId?: true
    title?: true
    description?: true
    order?: true
  }

  export type PhaseSectionCountAggregateInputType = {
    id?: true
    phaseId?: true
    title?: true
    description?: true
    order?: true
    _all?: true
  }

  export type PhaseSectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhaseSection to aggregate.
     */
    where?: PhaseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhaseSections to fetch.
     */
    orderBy?: PhaseSectionOrderByWithRelationInput | PhaseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhaseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhaseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhaseSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhaseSections
    **/
    _count?: true | PhaseSectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhaseSectionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhaseSectionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhaseSectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhaseSectionMaxAggregateInputType
  }

  export type GetPhaseSectionAggregateType<T extends PhaseSectionAggregateArgs> = {
        [P in keyof T & keyof AggregatePhaseSection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhaseSection[P]>
      : GetScalarType<T[P], AggregatePhaseSection[P]>
  }




  export type PhaseSectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhaseSectionWhereInput
    orderBy?: PhaseSectionOrderByWithAggregationInput | PhaseSectionOrderByWithAggregationInput[]
    by: PhaseSectionScalarFieldEnum[] | PhaseSectionScalarFieldEnum
    having?: PhaseSectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhaseSectionCountAggregateInputType | true
    _avg?: PhaseSectionAvgAggregateInputType
    _sum?: PhaseSectionSumAggregateInputType
    _min?: PhaseSectionMinAggregateInputType
    _max?: PhaseSectionMaxAggregateInputType
  }

  export type PhaseSectionGroupByOutputType = {
    id: string
    phaseId: string
    title: string
    description: string | null
    order: number
    _count: PhaseSectionCountAggregateOutputType | null
    _avg: PhaseSectionAvgAggregateOutputType | null
    _sum: PhaseSectionSumAggregateOutputType | null
    _min: PhaseSectionMinAggregateOutputType | null
    _max: PhaseSectionMaxAggregateOutputType | null
  }

  type GetPhaseSectionGroupByPayload<T extends PhaseSectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhaseSectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhaseSectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhaseSectionGroupByOutputType[P]>
            : GetScalarType<T[P], PhaseSectionGroupByOutputType[P]>
        }
      >
    >


  export type PhaseSectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phaseId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
    phase?: boolean | RoadmapPhaseDefaultArgs<ExtArgs>
    items?: boolean | PhaseSection$itemsArgs<ExtArgs>
    _count?: boolean | PhaseSectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phaseSection"]>


  export type PhaseSectionSelectScalar = {
    id?: boolean
    phaseId?: boolean
    title?: boolean
    description?: boolean
    order?: boolean
  }

  export type PhaseSectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phase?: boolean | RoadmapPhaseDefaultArgs<ExtArgs>
    items?: boolean | PhaseSection$itemsArgs<ExtArgs>
    _count?: boolean | PhaseSectionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $PhaseSectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhaseSection"
    objects: {
      phase: Prisma.$RoadmapPhasePayload<ExtArgs>
      items: Prisma.$SectionItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phaseId: string
      title: string
      description: string | null
      order: number
    }, ExtArgs["result"]["phaseSection"]>
    composites: {}
  }

  type PhaseSectionGetPayload<S extends boolean | null | undefined | PhaseSectionDefaultArgs> = $Result.GetResult<Prisma.$PhaseSectionPayload, S>

  type PhaseSectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhaseSectionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhaseSectionCountAggregateInputType | true
    }

  export interface PhaseSectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhaseSection'], meta: { name: 'PhaseSection' } }
    /**
     * Find zero or one PhaseSection that matches the filter.
     * @param {PhaseSectionFindUniqueArgs} args - Arguments to find a PhaseSection
     * @example
     * // Get one PhaseSection
     * const phaseSection = await prisma.phaseSection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhaseSectionFindUniqueArgs>(args: SelectSubset<T, PhaseSectionFindUniqueArgs<ExtArgs>>): Prisma__PhaseSectionClient<$Result.GetResult<Prisma.$PhaseSectionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PhaseSection that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PhaseSectionFindUniqueOrThrowArgs} args - Arguments to find a PhaseSection
     * @example
     * // Get one PhaseSection
     * const phaseSection = await prisma.phaseSection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhaseSectionFindUniqueOrThrowArgs>(args: SelectSubset<T, PhaseSectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhaseSectionClient<$Result.GetResult<Prisma.$PhaseSectionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PhaseSection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseSectionFindFirstArgs} args - Arguments to find a PhaseSection
     * @example
     * // Get one PhaseSection
     * const phaseSection = await prisma.phaseSection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhaseSectionFindFirstArgs>(args?: SelectSubset<T, PhaseSectionFindFirstArgs<ExtArgs>>): Prisma__PhaseSectionClient<$Result.GetResult<Prisma.$PhaseSectionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PhaseSection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseSectionFindFirstOrThrowArgs} args - Arguments to find a PhaseSection
     * @example
     * // Get one PhaseSection
     * const phaseSection = await prisma.phaseSection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhaseSectionFindFirstOrThrowArgs>(args?: SelectSubset<T, PhaseSectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhaseSectionClient<$Result.GetResult<Prisma.$PhaseSectionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PhaseSections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseSectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhaseSections
     * const phaseSections = await prisma.phaseSection.findMany()
     * 
     * // Get first 10 PhaseSections
     * const phaseSections = await prisma.phaseSection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phaseSectionWithIdOnly = await prisma.phaseSection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhaseSectionFindManyArgs>(args?: SelectSubset<T, PhaseSectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhaseSectionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PhaseSection.
     * @param {PhaseSectionCreateArgs} args - Arguments to create a PhaseSection.
     * @example
     * // Create one PhaseSection
     * const PhaseSection = await prisma.phaseSection.create({
     *   data: {
     *     // ... data to create a PhaseSection
     *   }
     * })
     * 
     */
    create<T extends PhaseSectionCreateArgs>(args: SelectSubset<T, PhaseSectionCreateArgs<ExtArgs>>): Prisma__PhaseSectionClient<$Result.GetResult<Prisma.$PhaseSectionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PhaseSections.
     * @param {PhaseSectionCreateManyArgs} args - Arguments to create many PhaseSections.
     * @example
     * // Create many PhaseSections
     * const phaseSection = await prisma.phaseSection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhaseSectionCreateManyArgs>(args?: SelectSubset<T, PhaseSectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PhaseSection.
     * @param {PhaseSectionDeleteArgs} args - Arguments to delete one PhaseSection.
     * @example
     * // Delete one PhaseSection
     * const PhaseSection = await prisma.phaseSection.delete({
     *   where: {
     *     // ... filter to delete one PhaseSection
     *   }
     * })
     * 
     */
    delete<T extends PhaseSectionDeleteArgs>(args: SelectSubset<T, PhaseSectionDeleteArgs<ExtArgs>>): Prisma__PhaseSectionClient<$Result.GetResult<Prisma.$PhaseSectionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PhaseSection.
     * @param {PhaseSectionUpdateArgs} args - Arguments to update one PhaseSection.
     * @example
     * // Update one PhaseSection
     * const phaseSection = await prisma.phaseSection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhaseSectionUpdateArgs>(args: SelectSubset<T, PhaseSectionUpdateArgs<ExtArgs>>): Prisma__PhaseSectionClient<$Result.GetResult<Prisma.$PhaseSectionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PhaseSections.
     * @param {PhaseSectionDeleteManyArgs} args - Arguments to filter PhaseSections to delete.
     * @example
     * // Delete a few PhaseSections
     * const { count } = await prisma.phaseSection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhaseSectionDeleteManyArgs>(args?: SelectSubset<T, PhaseSectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhaseSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseSectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhaseSections
     * const phaseSection = await prisma.phaseSection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhaseSectionUpdateManyArgs>(args: SelectSubset<T, PhaseSectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhaseSection.
     * @param {PhaseSectionUpsertArgs} args - Arguments to update or create a PhaseSection.
     * @example
     * // Update or create a PhaseSection
     * const phaseSection = await prisma.phaseSection.upsert({
     *   create: {
     *     // ... data to create a PhaseSection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhaseSection we want to update
     *   }
     * })
     */
    upsert<T extends PhaseSectionUpsertArgs>(args: SelectSubset<T, PhaseSectionUpsertArgs<ExtArgs>>): Prisma__PhaseSectionClient<$Result.GetResult<Prisma.$PhaseSectionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PhaseSections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseSectionCountArgs} args - Arguments to filter PhaseSections to count.
     * @example
     * // Count the number of PhaseSections
     * const count = await prisma.phaseSection.count({
     *   where: {
     *     // ... the filter for the PhaseSections we want to count
     *   }
     * })
    **/
    count<T extends PhaseSectionCountArgs>(
      args?: Subset<T, PhaseSectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhaseSectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhaseSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseSectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhaseSectionAggregateArgs>(args: Subset<T, PhaseSectionAggregateArgs>): Prisma.PrismaPromise<GetPhaseSectionAggregateType<T>>

    /**
     * Group by PhaseSection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseSectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhaseSectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhaseSectionGroupByArgs['orderBy'] }
        : { orderBy?: PhaseSectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhaseSectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhaseSectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhaseSection model
   */
  readonly fields: PhaseSectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhaseSection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhaseSectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phase<T extends RoadmapPhaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapPhaseDefaultArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    items<T extends PhaseSection$itemsArgs<ExtArgs> = {}>(args?: Subset<T, PhaseSection$itemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhaseSection model
   */ 
  interface PhaseSectionFieldRefs {
    readonly id: FieldRef<"PhaseSection", 'String'>
    readonly phaseId: FieldRef<"PhaseSection", 'String'>
    readonly title: FieldRef<"PhaseSection", 'String'>
    readonly description: FieldRef<"PhaseSection", 'String'>
    readonly order: FieldRef<"PhaseSection", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * PhaseSection findUnique
   */
  export type PhaseSectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseSection
     */
    select?: PhaseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseSectionInclude<ExtArgs> | null
    /**
     * Filter, which PhaseSection to fetch.
     */
    where: PhaseSectionWhereUniqueInput
  }

  /**
   * PhaseSection findUniqueOrThrow
   */
  export type PhaseSectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseSection
     */
    select?: PhaseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseSectionInclude<ExtArgs> | null
    /**
     * Filter, which PhaseSection to fetch.
     */
    where: PhaseSectionWhereUniqueInput
  }

  /**
   * PhaseSection findFirst
   */
  export type PhaseSectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseSection
     */
    select?: PhaseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseSectionInclude<ExtArgs> | null
    /**
     * Filter, which PhaseSection to fetch.
     */
    where?: PhaseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhaseSections to fetch.
     */
    orderBy?: PhaseSectionOrderByWithRelationInput | PhaseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhaseSections.
     */
    cursor?: PhaseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhaseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhaseSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhaseSections.
     */
    distinct?: PhaseSectionScalarFieldEnum | PhaseSectionScalarFieldEnum[]
  }

  /**
   * PhaseSection findFirstOrThrow
   */
  export type PhaseSectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseSection
     */
    select?: PhaseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseSectionInclude<ExtArgs> | null
    /**
     * Filter, which PhaseSection to fetch.
     */
    where?: PhaseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhaseSections to fetch.
     */
    orderBy?: PhaseSectionOrderByWithRelationInput | PhaseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhaseSections.
     */
    cursor?: PhaseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhaseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhaseSections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhaseSections.
     */
    distinct?: PhaseSectionScalarFieldEnum | PhaseSectionScalarFieldEnum[]
  }

  /**
   * PhaseSection findMany
   */
  export type PhaseSectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseSection
     */
    select?: PhaseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseSectionInclude<ExtArgs> | null
    /**
     * Filter, which PhaseSections to fetch.
     */
    where?: PhaseSectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhaseSections to fetch.
     */
    orderBy?: PhaseSectionOrderByWithRelationInput | PhaseSectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhaseSections.
     */
    cursor?: PhaseSectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhaseSections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhaseSections.
     */
    skip?: number
    distinct?: PhaseSectionScalarFieldEnum | PhaseSectionScalarFieldEnum[]
  }

  /**
   * PhaseSection create
   */
  export type PhaseSectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseSection
     */
    select?: PhaseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseSectionInclude<ExtArgs> | null
    /**
     * The data needed to create a PhaseSection.
     */
    data: XOR<PhaseSectionCreateInput, PhaseSectionUncheckedCreateInput>
  }

  /**
   * PhaseSection createMany
   */
  export type PhaseSectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhaseSections.
     */
    data: PhaseSectionCreateManyInput | PhaseSectionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhaseSection update
   */
  export type PhaseSectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseSection
     */
    select?: PhaseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseSectionInclude<ExtArgs> | null
    /**
     * The data needed to update a PhaseSection.
     */
    data: XOR<PhaseSectionUpdateInput, PhaseSectionUncheckedUpdateInput>
    /**
     * Choose, which PhaseSection to update.
     */
    where: PhaseSectionWhereUniqueInput
  }

  /**
   * PhaseSection updateMany
   */
  export type PhaseSectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhaseSections.
     */
    data: XOR<PhaseSectionUpdateManyMutationInput, PhaseSectionUncheckedUpdateManyInput>
    /**
     * Filter which PhaseSections to update
     */
    where?: PhaseSectionWhereInput
  }

  /**
   * PhaseSection upsert
   */
  export type PhaseSectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseSection
     */
    select?: PhaseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseSectionInclude<ExtArgs> | null
    /**
     * The filter to search for the PhaseSection to update in case it exists.
     */
    where: PhaseSectionWhereUniqueInput
    /**
     * In case the PhaseSection found by the `where` argument doesn't exist, create a new PhaseSection with this data.
     */
    create: XOR<PhaseSectionCreateInput, PhaseSectionUncheckedCreateInput>
    /**
     * In case the PhaseSection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhaseSectionUpdateInput, PhaseSectionUncheckedUpdateInput>
  }

  /**
   * PhaseSection delete
   */
  export type PhaseSectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseSection
     */
    select?: PhaseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseSectionInclude<ExtArgs> | null
    /**
     * Filter which PhaseSection to delete.
     */
    where: PhaseSectionWhereUniqueInput
  }

  /**
   * PhaseSection deleteMany
   */
  export type PhaseSectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhaseSections to delete
     */
    where?: PhaseSectionWhereInput
  }

  /**
   * PhaseSection.items
   */
  export type PhaseSection$itemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionItem
     */
    select?: SectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionItemInclude<ExtArgs> | null
    where?: SectionItemWhereInput
    orderBy?: SectionItemOrderByWithRelationInput | SectionItemOrderByWithRelationInput[]
    cursor?: SectionItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SectionItemScalarFieldEnum | SectionItemScalarFieldEnum[]
  }

  /**
   * PhaseSection without action
   */
  export type PhaseSectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseSection
     */
    select?: PhaseSectionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseSectionInclude<ExtArgs> | null
  }


  /**
   * Model SectionItem
   */

  export type AggregateSectionItem = {
    _count: SectionItemCountAggregateOutputType | null
    _avg: SectionItemAvgAggregateOutputType | null
    _sum: SectionItemSumAggregateOutputType | null
    _min: SectionItemMinAggregateOutputType | null
    _max: SectionItemMaxAggregateOutputType | null
  }

  export type SectionItemAvgAggregateOutputType = {
    order: number | null
  }

  export type SectionItemSumAggregateOutputType = {
    order: number | null
  }

  export type SectionItemMinAggregateOutputType = {
    id: string | null
    sectionId: string | null
    title: string | null
    order: number | null
  }

  export type SectionItemMaxAggregateOutputType = {
    id: string | null
    sectionId: string | null
    title: string | null
    order: number | null
  }

  export type SectionItemCountAggregateOutputType = {
    id: number
    sectionId: number
    title: number
    order: number
    _all: number
  }


  export type SectionItemAvgAggregateInputType = {
    order?: true
  }

  export type SectionItemSumAggregateInputType = {
    order?: true
  }

  export type SectionItemMinAggregateInputType = {
    id?: true
    sectionId?: true
    title?: true
    order?: true
  }

  export type SectionItemMaxAggregateInputType = {
    id?: true
    sectionId?: true
    title?: true
    order?: true
  }

  export type SectionItemCountAggregateInputType = {
    id?: true
    sectionId?: true
    title?: true
    order?: true
    _all?: true
  }

  export type SectionItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SectionItem to aggregate.
     */
    where?: SectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionItems to fetch.
     */
    orderBy?: SectionItemOrderByWithRelationInput | SectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SectionItems
    **/
    _count?: true | SectionItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SectionItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SectionItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SectionItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SectionItemMaxAggregateInputType
  }

  export type GetSectionItemAggregateType<T extends SectionItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSectionItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSectionItem[P]>
      : GetScalarType<T[P], AggregateSectionItem[P]>
  }




  export type SectionItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SectionItemWhereInput
    orderBy?: SectionItemOrderByWithAggregationInput | SectionItemOrderByWithAggregationInput[]
    by: SectionItemScalarFieldEnum[] | SectionItemScalarFieldEnum
    having?: SectionItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SectionItemCountAggregateInputType | true
    _avg?: SectionItemAvgAggregateInputType
    _sum?: SectionItemSumAggregateInputType
    _min?: SectionItemMinAggregateInputType
    _max?: SectionItemMaxAggregateInputType
  }

  export type SectionItemGroupByOutputType = {
    id: string
    sectionId: string
    title: string
    order: number
    _count: SectionItemCountAggregateOutputType | null
    _avg: SectionItemAvgAggregateOutputType | null
    _sum: SectionItemSumAggregateOutputType | null
    _min: SectionItemMinAggregateOutputType | null
    _max: SectionItemMaxAggregateOutputType | null
  }

  type GetSectionItemGroupByPayload<T extends SectionItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SectionItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SectionItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SectionItemGroupByOutputType[P]>
            : GetScalarType<T[P], SectionItemGroupByOutputType[P]>
        }
      >
    >


  export type SectionItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    sectionId?: boolean
    title?: boolean
    order?: boolean
    section?: boolean | PhaseSectionDefaultArgs<ExtArgs>
    subItems?: boolean | SectionItem$subItemsArgs<ExtArgs>
    _count?: boolean | SectionItemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["sectionItem"]>


  export type SectionItemSelectScalar = {
    id?: boolean
    sectionId?: boolean
    title?: boolean
    order?: boolean
  }

  export type SectionItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    section?: boolean | PhaseSectionDefaultArgs<ExtArgs>
    subItems?: boolean | SectionItem$subItemsArgs<ExtArgs>
    _count?: boolean | SectionItemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $SectionItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SectionItem"
    objects: {
      section: Prisma.$PhaseSectionPayload<ExtArgs>
      subItems: Prisma.$SubItemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      sectionId: string
      title: string
      order: number
    }, ExtArgs["result"]["sectionItem"]>
    composites: {}
  }

  type SectionItemGetPayload<S extends boolean | null | undefined | SectionItemDefaultArgs> = $Result.GetResult<Prisma.$SectionItemPayload, S>

  type SectionItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SectionItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SectionItemCountAggregateInputType | true
    }

  export interface SectionItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SectionItem'], meta: { name: 'SectionItem' } }
    /**
     * Find zero or one SectionItem that matches the filter.
     * @param {SectionItemFindUniqueArgs} args - Arguments to find a SectionItem
     * @example
     * // Get one SectionItem
     * const sectionItem = await prisma.sectionItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SectionItemFindUniqueArgs>(args: SelectSubset<T, SectionItemFindUniqueArgs<ExtArgs>>): Prisma__SectionItemClient<$Result.GetResult<Prisma.$SectionItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SectionItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SectionItemFindUniqueOrThrowArgs} args - Arguments to find a SectionItem
     * @example
     * // Get one SectionItem
     * const sectionItem = await prisma.sectionItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SectionItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SectionItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SectionItemClient<$Result.GetResult<Prisma.$SectionItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SectionItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionItemFindFirstArgs} args - Arguments to find a SectionItem
     * @example
     * // Get one SectionItem
     * const sectionItem = await prisma.sectionItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SectionItemFindFirstArgs>(args?: SelectSubset<T, SectionItemFindFirstArgs<ExtArgs>>): Prisma__SectionItemClient<$Result.GetResult<Prisma.$SectionItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SectionItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionItemFindFirstOrThrowArgs} args - Arguments to find a SectionItem
     * @example
     * // Get one SectionItem
     * const sectionItem = await prisma.sectionItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SectionItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SectionItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SectionItemClient<$Result.GetResult<Prisma.$SectionItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SectionItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SectionItems
     * const sectionItems = await prisma.sectionItem.findMany()
     * 
     * // Get first 10 SectionItems
     * const sectionItems = await prisma.sectionItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const sectionItemWithIdOnly = await prisma.sectionItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SectionItemFindManyArgs>(args?: SelectSubset<T, SectionItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SectionItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SectionItem.
     * @param {SectionItemCreateArgs} args - Arguments to create a SectionItem.
     * @example
     * // Create one SectionItem
     * const SectionItem = await prisma.sectionItem.create({
     *   data: {
     *     // ... data to create a SectionItem
     *   }
     * })
     * 
     */
    create<T extends SectionItemCreateArgs>(args: SelectSubset<T, SectionItemCreateArgs<ExtArgs>>): Prisma__SectionItemClient<$Result.GetResult<Prisma.$SectionItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SectionItems.
     * @param {SectionItemCreateManyArgs} args - Arguments to create many SectionItems.
     * @example
     * // Create many SectionItems
     * const sectionItem = await prisma.sectionItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SectionItemCreateManyArgs>(args?: SelectSubset<T, SectionItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SectionItem.
     * @param {SectionItemDeleteArgs} args - Arguments to delete one SectionItem.
     * @example
     * // Delete one SectionItem
     * const SectionItem = await prisma.sectionItem.delete({
     *   where: {
     *     // ... filter to delete one SectionItem
     *   }
     * })
     * 
     */
    delete<T extends SectionItemDeleteArgs>(args: SelectSubset<T, SectionItemDeleteArgs<ExtArgs>>): Prisma__SectionItemClient<$Result.GetResult<Prisma.$SectionItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SectionItem.
     * @param {SectionItemUpdateArgs} args - Arguments to update one SectionItem.
     * @example
     * // Update one SectionItem
     * const sectionItem = await prisma.sectionItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SectionItemUpdateArgs>(args: SelectSubset<T, SectionItemUpdateArgs<ExtArgs>>): Prisma__SectionItemClient<$Result.GetResult<Prisma.$SectionItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SectionItems.
     * @param {SectionItemDeleteManyArgs} args - Arguments to filter SectionItems to delete.
     * @example
     * // Delete a few SectionItems
     * const { count } = await prisma.sectionItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SectionItemDeleteManyArgs>(args?: SelectSubset<T, SectionItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SectionItems
     * const sectionItem = await prisma.sectionItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SectionItemUpdateManyArgs>(args: SelectSubset<T, SectionItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SectionItem.
     * @param {SectionItemUpsertArgs} args - Arguments to update or create a SectionItem.
     * @example
     * // Update or create a SectionItem
     * const sectionItem = await prisma.sectionItem.upsert({
     *   create: {
     *     // ... data to create a SectionItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SectionItem we want to update
     *   }
     * })
     */
    upsert<T extends SectionItemUpsertArgs>(args: SelectSubset<T, SectionItemUpsertArgs<ExtArgs>>): Prisma__SectionItemClient<$Result.GetResult<Prisma.$SectionItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SectionItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionItemCountArgs} args - Arguments to filter SectionItems to count.
     * @example
     * // Count the number of SectionItems
     * const count = await prisma.sectionItem.count({
     *   where: {
     *     // ... the filter for the SectionItems we want to count
     *   }
     * })
    **/
    count<T extends SectionItemCountArgs>(
      args?: Subset<T, SectionItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SectionItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SectionItemAggregateArgs>(args: Subset<T, SectionItemAggregateArgs>): Prisma.PrismaPromise<GetSectionItemAggregateType<T>>

    /**
     * Group by SectionItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SectionItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SectionItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SectionItemGroupByArgs['orderBy'] }
        : { orderBy?: SectionItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SectionItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSectionItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SectionItem model
   */
  readonly fields: SectionItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SectionItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SectionItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    section<T extends PhaseSectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, PhaseSectionDefaultArgs<ExtArgs>>): Prisma__PhaseSectionClient<$Result.GetResult<Prisma.$PhaseSectionPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    subItems<T extends SectionItem$subItemsArgs<ExtArgs> = {}>(args?: Subset<T, SectionItem$subItemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubItemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SectionItem model
   */ 
  interface SectionItemFieldRefs {
    readonly id: FieldRef<"SectionItem", 'String'>
    readonly sectionId: FieldRef<"SectionItem", 'String'>
    readonly title: FieldRef<"SectionItem", 'String'>
    readonly order: FieldRef<"SectionItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SectionItem findUnique
   */
  export type SectionItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionItem
     */
    select?: SectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionItemInclude<ExtArgs> | null
    /**
     * Filter, which SectionItem to fetch.
     */
    where: SectionItemWhereUniqueInput
  }

  /**
   * SectionItem findUniqueOrThrow
   */
  export type SectionItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionItem
     */
    select?: SectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionItemInclude<ExtArgs> | null
    /**
     * Filter, which SectionItem to fetch.
     */
    where: SectionItemWhereUniqueInput
  }

  /**
   * SectionItem findFirst
   */
  export type SectionItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionItem
     */
    select?: SectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionItemInclude<ExtArgs> | null
    /**
     * Filter, which SectionItem to fetch.
     */
    where?: SectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionItems to fetch.
     */
    orderBy?: SectionItemOrderByWithRelationInput | SectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectionItems.
     */
    cursor?: SectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectionItems.
     */
    distinct?: SectionItemScalarFieldEnum | SectionItemScalarFieldEnum[]
  }

  /**
   * SectionItem findFirstOrThrow
   */
  export type SectionItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionItem
     */
    select?: SectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionItemInclude<ExtArgs> | null
    /**
     * Filter, which SectionItem to fetch.
     */
    where?: SectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionItems to fetch.
     */
    orderBy?: SectionItemOrderByWithRelationInput | SectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SectionItems.
     */
    cursor?: SectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SectionItems.
     */
    distinct?: SectionItemScalarFieldEnum | SectionItemScalarFieldEnum[]
  }

  /**
   * SectionItem findMany
   */
  export type SectionItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionItem
     */
    select?: SectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionItemInclude<ExtArgs> | null
    /**
     * Filter, which SectionItems to fetch.
     */
    where?: SectionItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SectionItems to fetch.
     */
    orderBy?: SectionItemOrderByWithRelationInput | SectionItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SectionItems.
     */
    cursor?: SectionItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SectionItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SectionItems.
     */
    skip?: number
    distinct?: SectionItemScalarFieldEnum | SectionItemScalarFieldEnum[]
  }

  /**
   * SectionItem create
   */
  export type SectionItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionItem
     */
    select?: SectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SectionItem.
     */
    data: XOR<SectionItemCreateInput, SectionItemUncheckedCreateInput>
  }

  /**
   * SectionItem createMany
   */
  export type SectionItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SectionItems.
     */
    data: SectionItemCreateManyInput | SectionItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SectionItem update
   */
  export type SectionItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionItem
     */
    select?: SectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SectionItem.
     */
    data: XOR<SectionItemUpdateInput, SectionItemUncheckedUpdateInput>
    /**
     * Choose, which SectionItem to update.
     */
    where: SectionItemWhereUniqueInput
  }

  /**
   * SectionItem updateMany
   */
  export type SectionItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SectionItems.
     */
    data: XOR<SectionItemUpdateManyMutationInput, SectionItemUncheckedUpdateManyInput>
    /**
     * Filter which SectionItems to update
     */
    where?: SectionItemWhereInput
  }

  /**
   * SectionItem upsert
   */
  export type SectionItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionItem
     */
    select?: SectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SectionItem to update in case it exists.
     */
    where: SectionItemWhereUniqueInput
    /**
     * In case the SectionItem found by the `where` argument doesn't exist, create a new SectionItem with this data.
     */
    create: XOR<SectionItemCreateInput, SectionItemUncheckedCreateInput>
    /**
     * In case the SectionItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SectionItemUpdateInput, SectionItemUncheckedUpdateInput>
  }

  /**
   * SectionItem delete
   */
  export type SectionItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionItem
     */
    select?: SectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionItemInclude<ExtArgs> | null
    /**
     * Filter which SectionItem to delete.
     */
    where: SectionItemWhereUniqueInput
  }

  /**
   * SectionItem deleteMany
   */
  export type SectionItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SectionItems to delete
     */
    where?: SectionItemWhereInput
  }

  /**
   * SectionItem.subItems
   */
  export type SectionItem$subItemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubItem
     */
    select?: SubItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubItemInclude<ExtArgs> | null
    where?: SubItemWhereInput
    orderBy?: SubItemOrderByWithRelationInput | SubItemOrderByWithRelationInput[]
    cursor?: SubItemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: SubItemScalarFieldEnum | SubItemScalarFieldEnum[]
  }

  /**
   * SectionItem without action
   */
  export type SectionItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SectionItem
     */
    select?: SectionItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SectionItemInclude<ExtArgs> | null
  }


  /**
   * Model SubItem
   */

  export type AggregateSubItem = {
    _count: SubItemCountAggregateOutputType | null
    _avg: SubItemAvgAggregateOutputType | null
    _sum: SubItemSumAggregateOutputType | null
    _min: SubItemMinAggregateOutputType | null
    _max: SubItemMaxAggregateOutputType | null
  }

  export type SubItemAvgAggregateOutputType = {
    order: number | null
  }

  export type SubItemSumAggregateOutputType = {
    order: number | null
  }

  export type SubItemMinAggregateOutputType = {
    id: string | null
    itemId: string | null
    title: string | null
    videoUrl: string | null
    duration: string | null
    order: number | null
  }

  export type SubItemMaxAggregateOutputType = {
    id: string | null
    itemId: string | null
    title: string | null
    videoUrl: string | null
    duration: string | null
    order: number | null
  }

  export type SubItemCountAggregateOutputType = {
    id: number
    itemId: number
    title: number
    videoUrl: number
    duration: number
    order: number
    _all: number
  }


  export type SubItemAvgAggregateInputType = {
    order?: true
  }

  export type SubItemSumAggregateInputType = {
    order?: true
  }

  export type SubItemMinAggregateInputType = {
    id?: true
    itemId?: true
    title?: true
    videoUrl?: true
    duration?: true
    order?: true
  }

  export type SubItemMaxAggregateInputType = {
    id?: true
    itemId?: true
    title?: true
    videoUrl?: true
    duration?: true
    order?: true
  }

  export type SubItemCountAggregateInputType = {
    id?: true
    itemId?: true
    title?: true
    videoUrl?: true
    duration?: true
    order?: true
    _all?: true
  }

  export type SubItemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubItem to aggregate.
     */
    where?: SubItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubItems to fetch.
     */
    orderBy?: SubItemOrderByWithRelationInput | SubItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SubItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned SubItems
    **/
    _count?: true | SubItemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: SubItemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: SubItemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SubItemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SubItemMaxAggregateInputType
  }

  export type GetSubItemAggregateType<T extends SubItemAggregateArgs> = {
        [P in keyof T & keyof AggregateSubItem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSubItem[P]>
      : GetScalarType<T[P], AggregateSubItem[P]>
  }




  export type SubItemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SubItemWhereInput
    orderBy?: SubItemOrderByWithAggregationInput | SubItemOrderByWithAggregationInput[]
    by: SubItemScalarFieldEnum[] | SubItemScalarFieldEnum
    having?: SubItemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SubItemCountAggregateInputType | true
    _avg?: SubItemAvgAggregateInputType
    _sum?: SubItemSumAggregateInputType
    _min?: SubItemMinAggregateInputType
    _max?: SubItemMaxAggregateInputType
  }

  export type SubItemGroupByOutputType = {
    id: string
    itemId: string
    title: string
    videoUrl: string | null
    duration: string | null
    order: number
    _count: SubItemCountAggregateOutputType | null
    _avg: SubItemAvgAggregateOutputType | null
    _sum: SubItemSumAggregateOutputType | null
    _min: SubItemMinAggregateOutputType | null
    _max: SubItemMaxAggregateOutputType | null
  }

  type GetSubItemGroupByPayload<T extends SubItemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SubItemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SubItemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SubItemGroupByOutputType[P]>
            : GetScalarType<T[P], SubItemGroupByOutputType[P]>
        }
      >
    >


  export type SubItemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    itemId?: boolean
    title?: boolean
    videoUrl?: boolean
    duration?: boolean
    order?: boolean
    item?: boolean | SectionItemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["subItem"]>


  export type SubItemSelectScalar = {
    id?: boolean
    itemId?: boolean
    title?: boolean
    videoUrl?: boolean
    duration?: boolean
    order?: boolean
  }

  export type SubItemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    item?: boolean | SectionItemDefaultArgs<ExtArgs>
  }

  export type $SubItemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "SubItem"
    objects: {
      item: Prisma.$SectionItemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      itemId: string
      title: string
      videoUrl: string | null
      duration: string | null
      order: number
    }, ExtArgs["result"]["subItem"]>
    composites: {}
  }

  type SubItemGetPayload<S extends boolean | null | undefined | SubItemDefaultArgs> = $Result.GetResult<Prisma.$SubItemPayload, S>

  type SubItemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SubItemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SubItemCountAggregateInputType | true
    }

  export interface SubItemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['SubItem'], meta: { name: 'SubItem' } }
    /**
     * Find zero or one SubItem that matches the filter.
     * @param {SubItemFindUniqueArgs} args - Arguments to find a SubItem
     * @example
     * // Get one SubItem
     * const subItem = await prisma.subItem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SubItemFindUniqueArgs>(args: SelectSubset<T, SubItemFindUniqueArgs<ExtArgs>>): Prisma__SubItemClient<$Result.GetResult<Prisma.$SubItemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one SubItem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SubItemFindUniqueOrThrowArgs} args - Arguments to find a SubItem
     * @example
     * // Get one SubItem
     * const subItem = await prisma.subItem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SubItemFindUniqueOrThrowArgs>(args: SelectSubset<T, SubItemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SubItemClient<$Result.GetResult<Prisma.$SubItemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first SubItem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubItemFindFirstArgs} args - Arguments to find a SubItem
     * @example
     * // Get one SubItem
     * const subItem = await prisma.subItem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SubItemFindFirstArgs>(args?: SelectSubset<T, SubItemFindFirstArgs<ExtArgs>>): Prisma__SubItemClient<$Result.GetResult<Prisma.$SubItemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first SubItem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubItemFindFirstOrThrowArgs} args - Arguments to find a SubItem
     * @example
     * // Get one SubItem
     * const subItem = await prisma.subItem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SubItemFindFirstOrThrowArgs>(args?: SelectSubset<T, SubItemFindFirstOrThrowArgs<ExtArgs>>): Prisma__SubItemClient<$Result.GetResult<Prisma.$SubItemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more SubItems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubItemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all SubItems
     * const subItems = await prisma.subItem.findMany()
     * 
     * // Get first 10 SubItems
     * const subItems = await prisma.subItem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const subItemWithIdOnly = await prisma.subItem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SubItemFindManyArgs>(args?: SelectSubset<T, SubItemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SubItemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a SubItem.
     * @param {SubItemCreateArgs} args - Arguments to create a SubItem.
     * @example
     * // Create one SubItem
     * const SubItem = await prisma.subItem.create({
     *   data: {
     *     // ... data to create a SubItem
     *   }
     * })
     * 
     */
    create<T extends SubItemCreateArgs>(args: SelectSubset<T, SubItemCreateArgs<ExtArgs>>): Prisma__SubItemClient<$Result.GetResult<Prisma.$SubItemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many SubItems.
     * @param {SubItemCreateManyArgs} args - Arguments to create many SubItems.
     * @example
     * // Create many SubItems
     * const subItem = await prisma.subItem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SubItemCreateManyArgs>(args?: SelectSubset<T, SubItemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a SubItem.
     * @param {SubItemDeleteArgs} args - Arguments to delete one SubItem.
     * @example
     * // Delete one SubItem
     * const SubItem = await prisma.subItem.delete({
     *   where: {
     *     // ... filter to delete one SubItem
     *   }
     * })
     * 
     */
    delete<T extends SubItemDeleteArgs>(args: SelectSubset<T, SubItemDeleteArgs<ExtArgs>>): Prisma__SubItemClient<$Result.GetResult<Prisma.$SubItemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one SubItem.
     * @param {SubItemUpdateArgs} args - Arguments to update one SubItem.
     * @example
     * // Update one SubItem
     * const subItem = await prisma.subItem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SubItemUpdateArgs>(args: SelectSubset<T, SubItemUpdateArgs<ExtArgs>>): Prisma__SubItemClient<$Result.GetResult<Prisma.$SubItemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more SubItems.
     * @param {SubItemDeleteManyArgs} args - Arguments to filter SubItems to delete.
     * @example
     * // Delete a few SubItems
     * const { count } = await prisma.subItem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SubItemDeleteManyArgs>(args?: SelectSubset<T, SubItemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more SubItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubItemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many SubItems
     * const subItem = await prisma.subItem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SubItemUpdateManyArgs>(args: SelectSubset<T, SubItemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one SubItem.
     * @param {SubItemUpsertArgs} args - Arguments to update or create a SubItem.
     * @example
     * // Update or create a SubItem
     * const subItem = await prisma.subItem.upsert({
     *   create: {
     *     // ... data to create a SubItem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the SubItem we want to update
     *   }
     * })
     */
    upsert<T extends SubItemUpsertArgs>(args: SelectSubset<T, SubItemUpsertArgs<ExtArgs>>): Prisma__SubItemClient<$Result.GetResult<Prisma.$SubItemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of SubItems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubItemCountArgs} args - Arguments to filter SubItems to count.
     * @example
     * // Count the number of SubItems
     * const count = await prisma.subItem.count({
     *   where: {
     *     // ... the filter for the SubItems we want to count
     *   }
     * })
    **/
    count<T extends SubItemCountArgs>(
      args?: Subset<T, SubItemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SubItemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a SubItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubItemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SubItemAggregateArgs>(args: Subset<T, SubItemAggregateArgs>): Prisma.PrismaPromise<GetSubItemAggregateType<T>>

    /**
     * Group by SubItem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SubItemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SubItemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SubItemGroupByArgs['orderBy'] }
        : { orderBy?: SubItemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SubItemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSubItemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the SubItem model
   */
  readonly fields: SubItemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for SubItem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SubItemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    item<T extends SectionItemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, SectionItemDefaultArgs<ExtArgs>>): Prisma__SectionItemClient<$Result.GetResult<Prisma.$SectionItemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the SubItem model
   */ 
  interface SubItemFieldRefs {
    readonly id: FieldRef<"SubItem", 'String'>
    readonly itemId: FieldRef<"SubItem", 'String'>
    readonly title: FieldRef<"SubItem", 'String'>
    readonly videoUrl: FieldRef<"SubItem", 'String'>
    readonly duration: FieldRef<"SubItem", 'String'>
    readonly order: FieldRef<"SubItem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * SubItem findUnique
   */
  export type SubItemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubItem
     */
    select?: SubItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubItemInclude<ExtArgs> | null
    /**
     * Filter, which SubItem to fetch.
     */
    where: SubItemWhereUniqueInput
  }

  /**
   * SubItem findUniqueOrThrow
   */
  export type SubItemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubItem
     */
    select?: SubItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubItemInclude<ExtArgs> | null
    /**
     * Filter, which SubItem to fetch.
     */
    where: SubItemWhereUniqueInput
  }

  /**
   * SubItem findFirst
   */
  export type SubItemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubItem
     */
    select?: SubItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubItemInclude<ExtArgs> | null
    /**
     * Filter, which SubItem to fetch.
     */
    where?: SubItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubItems to fetch.
     */
    orderBy?: SubItemOrderByWithRelationInput | SubItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubItems.
     */
    cursor?: SubItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubItems.
     */
    distinct?: SubItemScalarFieldEnum | SubItemScalarFieldEnum[]
  }

  /**
   * SubItem findFirstOrThrow
   */
  export type SubItemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubItem
     */
    select?: SubItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubItemInclude<ExtArgs> | null
    /**
     * Filter, which SubItem to fetch.
     */
    where?: SubItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubItems to fetch.
     */
    orderBy?: SubItemOrderByWithRelationInput | SubItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for SubItems.
     */
    cursor?: SubItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubItems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of SubItems.
     */
    distinct?: SubItemScalarFieldEnum | SubItemScalarFieldEnum[]
  }

  /**
   * SubItem findMany
   */
  export type SubItemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubItem
     */
    select?: SubItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubItemInclude<ExtArgs> | null
    /**
     * Filter, which SubItems to fetch.
     */
    where?: SubItemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of SubItems to fetch.
     */
    orderBy?: SubItemOrderByWithRelationInput | SubItemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing SubItems.
     */
    cursor?: SubItemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` SubItems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` SubItems.
     */
    skip?: number
    distinct?: SubItemScalarFieldEnum | SubItemScalarFieldEnum[]
  }

  /**
   * SubItem create
   */
  export type SubItemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubItem
     */
    select?: SubItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubItemInclude<ExtArgs> | null
    /**
     * The data needed to create a SubItem.
     */
    data: XOR<SubItemCreateInput, SubItemUncheckedCreateInput>
  }

  /**
   * SubItem createMany
   */
  export type SubItemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many SubItems.
     */
    data: SubItemCreateManyInput | SubItemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * SubItem update
   */
  export type SubItemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubItem
     */
    select?: SubItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubItemInclude<ExtArgs> | null
    /**
     * The data needed to update a SubItem.
     */
    data: XOR<SubItemUpdateInput, SubItemUncheckedUpdateInput>
    /**
     * Choose, which SubItem to update.
     */
    where: SubItemWhereUniqueInput
  }

  /**
   * SubItem updateMany
   */
  export type SubItemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update SubItems.
     */
    data: XOR<SubItemUpdateManyMutationInput, SubItemUncheckedUpdateManyInput>
    /**
     * Filter which SubItems to update
     */
    where?: SubItemWhereInput
  }

  /**
   * SubItem upsert
   */
  export type SubItemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubItem
     */
    select?: SubItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubItemInclude<ExtArgs> | null
    /**
     * The filter to search for the SubItem to update in case it exists.
     */
    where: SubItemWhereUniqueInput
    /**
     * In case the SubItem found by the `where` argument doesn't exist, create a new SubItem with this data.
     */
    create: XOR<SubItemCreateInput, SubItemUncheckedCreateInput>
    /**
     * In case the SubItem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SubItemUpdateInput, SubItemUncheckedUpdateInput>
  }

  /**
   * SubItem delete
   */
  export type SubItemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubItem
     */
    select?: SubItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubItemInclude<ExtArgs> | null
    /**
     * Filter which SubItem to delete.
     */
    where: SubItemWhereUniqueInput
  }

  /**
   * SubItem deleteMany
   */
  export type SubItemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which SubItems to delete
     */
    where?: SubItemWhereInput
  }

  /**
   * SubItem without action
   */
  export type SubItemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the SubItem
     */
    select?: SubItemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: SubItemInclude<ExtArgs> | null
  }


  /**
   * Model PhasePlaylist
   */

  export type AggregatePhasePlaylist = {
    _count: PhasePlaylistCountAggregateOutputType | null
    _avg: PhasePlaylistAvgAggregateOutputType | null
    _sum: PhasePlaylistSumAggregateOutputType | null
    _min: PhasePlaylistMinAggregateOutputType | null
    _max: PhasePlaylistMaxAggregateOutputType | null
  }

  export type PhasePlaylistAvgAggregateOutputType = {
    videoCount: number | null
  }

  export type PhasePlaylistSumAggregateOutputType = {
    videoCount: number | null
  }

  export type PhasePlaylistMinAggregateOutputType = {
    id: string | null
    phaseId: string | null
    title: string | null
    author: string | null
    videoCount: number | null
    url: string | null
    thumbnail: string | null
  }

  export type PhasePlaylistMaxAggregateOutputType = {
    id: string | null
    phaseId: string | null
    title: string | null
    author: string | null
    videoCount: number | null
    url: string | null
    thumbnail: string | null
  }

  export type PhasePlaylistCountAggregateOutputType = {
    id: number
    phaseId: number
    title: number
    author: number
    videoCount: number
    url: number
    thumbnail: number
    _all: number
  }


  export type PhasePlaylistAvgAggregateInputType = {
    videoCount?: true
  }

  export type PhasePlaylistSumAggregateInputType = {
    videoCount?: true
  }

  export type PhasePlaylistMinAggregateInputType = {
    id?: true
    phaseId?: true
    title?: true
    author?: true
    videoCount?: true
    url?: true
    thumbnail?: true
  }

  export type PhasePlaylistMaxAggregateInputType = {
    id?: true
    phaseId?: true
    title?: true
    author?: true
    videoCount?: true
    url?: true
    thumbnail?: true
  }

  export type PhasePlaylistCountAggregateInputType = {
    id?: true
    phaseId?: true
    title?: true
    author?: true
    videoCount?: true
    url?: true
    thumbnail?: true
    _all?: true
  }

  export type PhasePlaylistAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhasePlaylist to aggregate.
     */
    where?: PhasePlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhasePlaylists to fetch.
     */
    orderBy?: PhasePlaylistOrderByWithRelationInput | PhasePlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhasePlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhasePlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhasePlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhasePlaylists
    **/
    _count?: true | PhasePlaylistCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PhasePlaylistAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PhasePlaylistSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhasePlaylistMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhasePlaylistMaxAggregateInputType
  }

  export type GetPhasePlaylistAggregateType<T extends PhasePlaylistAggregateArgs> = {
        [P in keyof T & keyof AggregatePhasePlaylist]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhasePlaylist[P]>
      : GetScalarType<T[P], AggregatePhasePlaylist[P]>
  }




  export type PhasePlaylistGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhasePlaylistWhereInput
    orderBy?: PhasePlaylistOrderByWithAggregationInput | PhasePlaylistOrderByWithAggregationInput[]
    by: PhasePlaylistScalarFieldEnum[] | PhasePlaylistScalarFieldEnum
    having?: PhasePlaylistScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhasePlaylistCountAggregateInputType | true
    _avg?: PhasePlaylistAvgAggregateInputType
    _sum?: PhasePlaylistSumAggregateInputType
    _min?: PhasePlaylistMinAggregateInputType
    _max?: PhasePlaylistMaxAggregateInputType
  }

  export type PhasePlaylistGroupByOutputType = {
    id: string
    phaseId: string
    title: string
    author: string | null
    videoCount: number
    url: string
    thumbnail: string | null
    _count: PhasePlaylistCountAggregateOutputType | null
    _avg: PhasePlaylistAvgAggregateOutputType | null
    _sum: PhasePlaylistSumAggregateOutputType | null
    _min: PhasePlaylistMinAggregateOutputType | null
    _max: PhasePlaylistMaxAggregateOutputType | null
  }

  type GetPhasePlaylistGroupByPayload<T extends PhasePlaylistGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhasePlaylistGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhasePlaylistGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhasePlaylistGroupByOutputType[P]>
            : GetScalarType<T[P], PhasePlaylistGroupByOutputType[P]>
        }
      >
    >


  export type PhasePlaylistSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phaseId?: boolean
    title?: boolean
    author?: boolean
    videoCount?: boolean
    url?: boolean
    thumbnail?: boolean
    phase?: boolean | RoadmapPhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phasePlaylist"]>


  export type PhasePlaylistSelectScalar = {
    id?: boolean
    phaseId?: boolean
    title?: boolean
    author?: boolean
    videoCount?: boolean
    url?: boolean
    thumbnail?: boolean
  }

  export type PhasePlaylistInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phase?: boolean | RoadmapPhaseDefaultArgs<ExtArgs>
  }

  export type $PhasePlaylistPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhasePlaylist"
    objects: {
      phase: Prisma.$RoadmapPhasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phaseId: string
      title: string
      author: string | null
      videoCount: number
      url: string
      thumbnail: string | null
    }, ExtArgs["result"]["phasePlaylist"]>
    composites: {}
  }

  type PhasePlaylistGetPayload<S extends boolean | null | undefined | PhasePlaylistDefaultArgs> = $Result.GetResult<Prisma.$PhasePlaylistPayload, S>

  type PhasePlaylistCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhasePlaylistFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhasePlaylistCountAggregateInputType | true
    }

  export interface PhasePlaylistDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhasePlaylist'], meta: { name: 'PhasePlaylist' } }
    /**
     * Find zero or one PhasePlaylist that matches the filter.
     * @param {PhasePlaylistFindUniqueArgs} args - Arguments to find a PhasePlaylist
     * @example
     * // Get one PhasePlaylist
     * const phasePlaylist = await prisma.phasePlaylist.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhasePlaylistFindUniqueArgs>(args: SelectSubset<T, PhasePlaylistFindUniqueArgs<ExtArgs>>): Prisma__PhasePlaylistClient<$Result.GetResult<Prisma.$PhasePlaylistPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PhasePlaylist that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PhasePlaylistFindUniqueOrThrowArgs} args - Arguments to find a PhasePlaylist
     * @example
     * // Get one PhasePlaylist
     * const phasePlaylist = await prisma.phasePlaylist.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhasePlaylistFindUniqueOrThrowArgs>(args: SelectSubset<T, PhasePlaylistFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhasePlaylistClient<$Result.GetResult<Prisma.$PhasePlaylistPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PhasePlaylist that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhasePlaylistFindFirstArgs} args - Arguments to find a PhasePlaylist
     * @example
     * // Get one PhasePlaylist
     * const phasePlaylist = await prisma.phasePlaylist.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhasePlaylistFindFirstArgs>(args?: SelectSubset<T, PhasePlaylistFindFirstArgs<ExtArgs>>): Prisma__PhasePlaylistClient<$Result.GetResult<Prisma.$PhasePlaylistPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PhasePlaylist that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhasePlaylistFindFirstOrThrowArgs} args - Arguments to find a PhasePlaylist
     * @example
     * // Get one PhasePlaylist
     * const phasePlaylist = await prisma.phasePlaylist.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhasePlaylistFindFirstOrThrowArgs>(args?: SelectSubset<T, PhasePlaylistFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhasePlaylistClient<$Result.GetResult<Prisma.$PhasePlaylistPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PhasePlaylists that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhasePlaylistFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhasePlaylists
     * const phasePlaylists = await prisma.phasePlaylist.findMany()
     * 
     * // Get first 10 PhasePlaylists
     * const phasePlaylists = await prisma.phasePlaylist.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phasePlaylistWithIdOnly = await prisma.phasePlaylist.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhasePlaylistFindManyArgs>(args?: SelectSubset<T, PhasePlaylistFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhasePlaylistPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PhasePlaylist.
     * @param {PhasePlaylistCreateArgs} args - Arguments to create a PhasePlaylist.
     * @example
     * // Create one PhasePlaylist
     * const PhasePlaylist = await prisma.phasePlaylist.create({
     *   data: {
     *     // ... data to create a PhasePlaylist
     *   }
     * })
     * 
     */
    create<T extends PhasePlaylistCreateArgs>(args: SelectSubset<T, PhasePlaylistCreateArgs<ExtArgs>>): Prisma__PhasePlaylistClient<$Result.GetResult<Prisma.$PhasePlaylistPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PhasePlaylists.
     * @param {PhasePlaylistCreateManyArgs} args - Arguments to create many PhasePlaylists.
     * @example
     * // Create many PhasePlaylists
     * const phasePlaylist = await prisma.phasePlaylist.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhasePlaylistCreateManyArgs>(args?: SelectSubset<T, PhasePlaylistCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PhasePlaylist.
     * @param {PhasePlaylistDeleteArgs} args - Arguments to delete one PhasePlaylist.
     * @example
     * // Delete one PhasePlaylist
     * const PhasePlaylist = await prisma.phasePlaylist.delete({
     *   where: {
     *     // ... filter to delete one PhasePlaylist
     *   }
     * })
     * 
     */
    delete<T extends PhasePlaylistDeleteArgs>(args: SelectSubset<T, PhasePlaylistDeleteArgs<ExtArgs>>): Prisma__PhasePlaylistClient<$Result.GetResult<Prisma.$PhasePlaylistPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PhasePlaylist.
     * @param {PhasePlaylistUpdateArgs} args - Arguments to update one PhasePlaylist.
     * @example
     * // Update one PhasePlaylist
     * const phasePlaylist = await prisma.phasePlaylist.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhasePlaylistUpdateArgs>(args: SelectSubset<T, PhasePlaylistUpdateArgs<ExtArgs>>): Prisma__PhasePlaylistClient<$Result.GetResult<Prisma.$PhasePlaylistPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PhasePlaylists.
     * @param {PhasePlaylistDeleteManyArgs} args - Arguments to filter PhasePlaylists to delete.
     * @example
     * // Delete a few PhasePlaylists
     * const { count } = await prisma.phasePlaylist.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhasePlaylistDeleteManyArgs>(args?: SelectSubset<T, PhasePlaylistDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhasePlaylists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhasePlaylistUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhasePlaylists
     * const phasePlaylist = await prisma.phasePlaylist.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhasePlaylistUpdateManyArgs>(args: SelectSubset<T, PhasePlaylistUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhasePlaylist.
     * @param {PhasePlaylistUpsertArgs} args - Arguments to update or create a PhasePlaylist.
     * @example
     * // Update or create a PhasePlaylist
     * const phasePlaylist = await prisma.phasePlaylist.upsert({
     *   create: {
     *     // ... data to create a PhasePlaylist
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhasePlaylist we want to update
     *   }
     * })
     */
    upsert<T extends PhasePlaylistUpsertArgs>(args: SelectSubset<T, PhasePlaylistUpsertArgs<ExtArgs>>): Prisma__PhasePlaylistClient<$Result.GetResult<Prisma.$PhasePlaylistPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PhasePlaylists.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhasePlaylistCountArgs} args - Arguments to filter PhasePlaylists to count.
     * @example
     * // Count the number of PhasePlaylists
     * const count = await prisma.phasePlaylist.count({
     *   where: {
     *     // ... the filter for the PhasePlaylists we want to count
     *   }
     * })
    **/
    count<T extends PhasePlaylistCountArgs>(
      args?: Subset<T, PhasePlaylistCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhasePlaylistCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhasePlaylist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhasePlaylistAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhasePlaylistAggregateArgs>(args: Subset<T, PhasePlaylistAggregateArgs>): Prisma.PrismaPromise<GetPhasePlaylistAggregateType<T>>

    /**
     * Group by PhasePlaylist.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhasePlaylistGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhasePlaylistGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhasePlaylistGroupByArgs['orderBy'] }
        : { orderBy?: PhasePlaylistGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhasePlaylistGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhasePlaylistGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhasePlaylist model
   */
  readonly fields: PhasePlaylistFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhasePlaylist.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhasePlaylistClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phase<T extends RoadmapPhaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapPhaseDefaultArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhasePlaylist model
   */ 
  interface PhasePlaylistFieldRefs {
    readonly id: FieldRef<"PhasePlaylist", 'String'>
    readonly phaseId: FieldRef<"PhasePlaylist", 'String'>
    readonly title: FieldRef<"PhasePlaylist", 'String'>
    readonly author: FieldRef<"PhasePlaylist", 'String'>
    readonly videoCount: FieldRef<"PhasePlaylist", 'Int'>
    readonly url: FieldRef<"PhasePlaylist", 'String'>
    readonly thumbnail: FieldRef<"PhasePlaylist", 'String'>
  }
    

  // Custom InputTypes
  /**
   * PhasePlaylist findUnique
   */
  export type PhasePlaylistFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhasePlaylist
     */
    select?: PhasePlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhasePlaylistInclude<ExtArgs> | null
    /**
     * Filter, which PhasePlaylist to fetch.
     */
    where: PhasePlaylistWhereUniqueInput
  }

  /**
   * PhasePlaylist findUniqueOrThrow
   */
  export type PhasePlaylistFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhasePlaylist
     */
    select?: PhasePlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhasePlaylistInclude<ExtArgs> | null
    /**
     * Filter, which PhasePlaylist to fetch.
     */
    where: PhasePlaylistWhereUniqueInput
  }

  /**
   * PhasePlaylist findFirst
   */
  export type PhasePlaylistFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhasePlaylist
     */
    select?: PhasePlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhasePlaylistInclude<ExtArgs> | null
    /**
     * Filter, which PhasePlaylist to fetch.
     */
    where?: PhasePlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhasePlaylists to fetch.
     */
    orderBy?: PhasePlaylistOrderByWithRelationInput | PhasePlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhasePlaylists.
     */
    cursor?: PhasePlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhasePlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhasePlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhasePlaylists.
     */
    distinct?: PhasePlaylistScalarFieldEnum | PhasePlaylistScalarFieldEnum[]
  }

  /**
   * PhasePlaylist findFirstOrThrow
   */
  export type PhasePlaylistFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhasePlaylist
     */
    select?: PhasePlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhasePlaylistInclude<ExtArgs> | null
    /**
     * Filter, which PhasePlaylist to fetch.
     */
    where?: PhasePlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhasePlaylists to fetch.
     */
    orderBy?: PhasePlaylistOrderByWithRelationInput | PhasePlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhasePlaylists.
     */
    cursor?: PhasePlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhasePlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhasePlaylists.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhasePlaylists.
     */
    distinct?: PhasePlaylistScalarFieldEnum | PhasePlaylistScalarFieldEnum[]
  }

  /**
   * PhasePlaylist findMany
   */
  export type PhasePlaylistFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhasePlaylist
     */
    select?: PhasePlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhasePlaylistInclude<ExtArgs> | null
    /**
     * Filter, which PhasePlaylists to fetch.
     */
    where?: PhasePlaylistWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhasePlaylists to fetch.
     */
    orderBy?: PhasePlaylistOrderByWithRelationInput | PhasePlaylistOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhasePlaylists.
     */
    cursor?: PhasePlaylistWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhasePlaylists from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhasePlaylists.
     */
    skip?: number
    distinct?: PhasePlaylistScalarFieldEnum | PhasePlaylistScalarFieldEnum[]
  }

  /**
   * PhasePlaylist create
   */
  export type PhasePlaylistCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhasePlaylist
     */
    select?: PhasePlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhasePlaylistInclude<ExtArgs> | null
    /**
     * The data needed to create a PhasePlaylist.
     */
    data: XOR<PhasePlaylistCreateInput, PhasePlaylistUncheckedCreateInput>
  }

  /**
   * PhasePlaylist createMany
   */
  export type PhasePlaylistCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhasePlaylists.
     */
    data: PhasePlaylistCreateManyInput | PhasePlaylistCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhasePlaylist update
   */
  export type PhasePlaylistUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhasePlaylist
     */
    select?: PhasePlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhasePlaylistInclude<ExtArgs> | null
    /**
     * The data needed to update a PhasePlaylist.
     */
    data: XOR<PhasePlaylistUpdateInput, PhasePlaylistUncheckedUpdateInput>
    /**
     * Choose, which PhasePlaylist to update.
     */
    where: PhasePlaylistWhereUniqueInput
  }

  /**
   * PhasePlaylist updateMany
   */
  export type PhasePlaylistUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhasePlaylists.
     */
    data: XOR<PhasePlaylistUpdateManyMutationInput, PhasePlaylistUncheckedUpdateManyInput>
    /**
     * Filter which PhasePlaylists to update
     */
    where?: PhasePlaylistWhereInput
  }

  /**
   * PhasePlaylist upsert
   */
  export type PhasePlaylistUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhasePlaylist
     */
    select?: PhasePlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhasePlaylistInclude<ExtArgs> | null
    /**
     * The filter to search for the PhasePlaylist to update in case it exists.
     */
    where: PhasePlaylistWhereUniqueInput
    /**
     * In case the PhasePlaylist found by the `where` argument doesn't exist, create a new PhasePlaylist with this data.
     */
    create: XOR<PhasePlaylistCreateInput, PhasePlaylistUncheckedCreateInput>
    /**
     * In case the PhasePlaylist was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhasePlaylistUpdateInput, PhasePlaylistUncheckedUpdateInput>
  }

  /**
   * PhasePlaylist delete
   */
  export type PhasePlaylistDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhasePlaylist
     */
    select?: PhasePlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhasePlaylistInclude<ExtArgs> | null
    /**
     * Filter which PhasePlaylist to delete.
     */
    where: PhasePlaylistWhereUniqueInput
  }

  /**
   * PhasePlaylist deleteMany
   */
  export type PhasePlaylistDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhasePlaylists to delete
     */
    where?: PhasePlaylistWhereInput
  }

  /**
   * PhasePlaylist without action
   */
  export type PhasePlaylistDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhasePlaylist
     */
    select?: PhasePlaylistSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhasePlaylistInclude<ExtArgs> | null
  }


  /**
   * Model PhaseProject
   */

  export type AggregatePhaseProject = {
    _count: PhaseProjectCountAggregateOutputType | null
    _min: PhaseProjectMinAggregateOutputType | null
    _max: PhaseProjectMaxAggregateOutputType | null
  }

  export type PhaseProjectMinAggregateOutputType = {
    id: string | null
    phaseId: string | null
    title: string | null
    description: string | null
  }

  export type PhaseProjectMaxAggregateOutputType = {
    id: string | null
    phaseId: string | null
    title: string | null
    description: string | null
  }

  export type PhaseProjectCountAggregateOutputType = {
    id: number
    phaseId: number
    title: number
    description: number
    tags: number
    _all: number
  }


  export type PhaseProjectMinAggregateInputType = {
    id?: true
    phaseId?: true
    title?: true
    description?: true
  }

  export type PhaseProjectMaxAggregateInputType = {
    id?: true
    phaseId?: true
    title?: true
    description?: true
  }

  export type PhaseProjectCountAggregateInputType = {
    id?: true
    phaseId?: true
    title?: true
    description?: true
    tags?: true
    _all?: true
  }

  export type PhaseProjectAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhaseProject to aggregate.
     */
    where?: PhaseProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhaseProjects to fetch.
     */
    orderBy?: PhaseProjectOrderByWithRelationInput | PhaseProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PhaseProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhaseProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhaseProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PhaseProjects
    **/
    _count?: true | PhaseProjectCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PhaseProjectMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PhaseProjectMaxAggregateInputType
  }

  export type GetPhaseProjectAggregateType<T extends PhaseProjectAggregateArgs> = {
        [P in keyof T & keyof AggregatePhaseProject]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePhaseProject[P]>
      : GetScalarType<T[P], AggregatePhaseProject[P]>
  }




  export type PhaseProjectGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PhaseProjectWhereInput
    orderBy?: PhaseProjectOrderByWithAggregationInput | PhaseProjectOrderByWithAggregationInput[]
    by: PhaseProjectScalarFieldEnum[] | PhaseProjectScalarFieldEnum
    having?: PhaseProjectScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PhaseProjectCountAggregateInputType | true
    _min?: PhaseProjectMinAggregateInputType
    _max?: PhaseProjectMaxAggregateInputType
  }

  export type PhaseProjectGroupByOutputType = {
    id: string
    phaseId: string
    title: string
    description: string | null
    tags: JsonValue | null
    _count: PhaseProjectCountAggregateOutputType | null
    _min: PhaseProjectMinAggregateOutputType | null
    _max: PhaseProjectMaxAggregateOutputType | null
  }

  type GetPhaseProjectGroupByPayload<T extends PhaseProjectGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PhaseProjectGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PhaseProjectGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PhaseProjectGroupByOutputType[P]>
            : GetScalarType<T[P], PhaseProjectGroupByOutputType[P]>
        }
      >
    >


  export type PhaseProjectSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    phaseId?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
    phase?: boolean | RoadmapPhaseDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["phaseProject"]>


  export type PhaseProjectSelectScalar = {
    id?: boolean
    phaseId?: boolean
    title?: boolean
    description?: boolean
    tags?: boolean
  }

  export type PhaseProjectInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    phase?: boolean | RoadmapPhaseDefaultArgs<ExtArgs>
  }

  export type $PhaseProjectPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PhaseProject"
    objects: {
      phase: Prisma.$RoadmapPhasePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      phaseId: string
      title: string
      description: string | null
      tags: Prisma.JsonValue | null
    }, ExtArgs["result"]["phaseProject"]>
    composites: {}
  }

  type PhaseProjectGetPayload<S extends boolean | null | undefined | PhaseProjectDefaultArgs> = $Result.GetResult<Prisma.$PhaseProjectPayload, S>

  type PhaseProjectCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PhaseProjectFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PhaseProjectCountAggregateInputType | true
    }

  export interface PhaseProjectDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PhaseProject'], meta: { name: 'PhaseProject' } }
    /**
     * Find zero or one PhaseProject that matches the filter.
     * @param {PhaseProjectFindUniqueArgs} args - Arguments to find a PhaseProject
     * @example
     * // Get one PhaseProject
     * const phaseProject = await prisma.phaseProject.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PhaseProjectFindUniqueArgs>(args: SelectSubset<T, PhaseProjectFindUniqueArgs<ExtArgs>>): Prisma__PhaseProjectClient<$Result.GetResult<Prisma.$PhaseProjectPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PhaseProject that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PhaseProjectFindUniqueOrThrowArgs} args - Arguments to find a PhaseProject
     * @example
     * // Get one PhaseProject
     * const phaseProject = await prisma.phaseProject.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PhaseProjectFindUniqueOrThrowArgs>(args: SelectSubset<T, PhaseProjectFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PhaseProjectClient<$Result.GetResult<Prisma.$PhaseProjectPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PhaseProject that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseProjectFindFirstArgs} args - Arguments to find a PhaseProject
     * @example
     * // Get one PhaseProject
     * const phaseProject = await prisma.phaseProject.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PhaseProjectFindFirstArgs>(args?: SelectSubset<T, PhaseProjectFindFirstArgs<ExtArgs>>): Prisma__PhaseProjectClient<$Result.GetResult<Prisma.$PhaseProjectPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PhaseProject that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseProjectFindFirstOrThrowArgs} args - Arguments to find a PhaseProject
     * @example
     * // Get one PhaseProject
     * const phaseProject = await prisma.phaseProject.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PhaseProjectFindFirstOrThrowArgs>(args?: SelectSubset<T, PhaseProjectFindFirstOrThrowArgs<ExtArgs>>): Prisma__PhaseProjectClient<$Result.GetResult<Prisma.$PhaseProjectPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PhaseProjects that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseProjectFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PhaseProjects
     * const phaseProjects = await prisma.phaseProject.findMany()
     * 
     * // Get first 10 PhaseProjects
     * const phaseProjects = await prisma.phaseProject.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const phaseProjectWithIdOnly = await prisma.phaseProject.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PhaseProjectFindManyArgs>(args?: SelectSubset<T, PhaseProjectFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PhaseProjectPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PhaseProject.
     * @param {PhaseProjectCreateArgs} args - Arguments to create a PhaseProject.
     * @example
     * // Create one PhaseProject
     * const PhaseProject = await prisma.phaseProject.create({
     *   data: {
     *     // ... data to create a PhaseProject
     *   }
     * })
     * 
     */
    create<T extends PhaseProjectCreateArgs>(args: SelectSubset<T, PhaseProjectCreateArgs<ExtArgs>>): Prisma__PhaseProjectClient<$Result.GetResult<Prisma.$PhaseProjectPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PhaseProjects.
     * @param {PhaseProjectCreateManyArgs} args - Arguments to create many PhaseProjects.
     * @example
     * // Create many PhaseProjects
     * const phaseProject = await prisma.phaseProject.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PhaseProjectCreateManyArgs>(args?: SelectSubset<T, PhaseProjectCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a PhaseProject.
     * @param {PhaseProjectDeleteArgs} args - Arguments to delete one PhaseProject.
     * @example
     * // Delete one PhaseProject
     * const PhaseProject = await prisma.phaseProject.delete({
     *   where: {
     *     // ... filter to delete one PhaseProject
     *   }
     * })
     * 
     */
    delete<T extends PhaseProjectDeleteArgs>(args: SelectSubset<T, PhaseProjectDeleteArgs<ExtArgs>>): Prisma__PhaseProjectClient<$Result.GetResult<Prisma.$PhaseProjectPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PhaseProject.
     * @param {PhaseProjectUpdateArgs} args - Arguments to update one PhaseProject.
     * @example
     * // Update one PhaseProject
     * const phaseProject = await prisma.phaseProject.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PhaseProjectUpdateArgs>(args: SelectSubset<T, PhaseProjectUpdateArgs<ExtArgs>>): Prisma__PhaseProjectClient<$Result.GetResult<Prisma.$PhaseProjectPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PhaseProjects.
     * @param {PhaseProjectDeleteManyArgs} args - Arguments to filter PhaseProjects to delete.
     * @example
     * // Delete a few PhaseProjects
     * const { count } = await prisma.phaseProject.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PhaseProjectDeleteManyArgs>(args?: SelectSubset<T, PhaseProjectDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PhaseProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseProjectUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PhaseProjects
     * const phaseProject = await prisma.phaseProject.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PhaseProjectUpdateManyArgs>(args: SelectSubset<T, PhaseProjectUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PhaseProject.
     * @param {PhaseProjectUpsertArgs} args - Arguments to update or create a PhaseProject.
     * @example
     * // Update or create a PhaseProject
     * const phaseProject = await prisma.phaseProject.upsert({
     *   create: {
     *     // ... data to create a PhaseProject
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PhaseProject we want to update
     *   }
     * })
     */
    upsert<T extends PhaseProjectUpsertArgs>(args: SelectSubset<T, PhaseProjectUpsertArgs<ExtArgs>>): Prisma__PhaseProjectClient<$Result.GetResult<Prisma.$PhaseProjectPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PhaseProjects.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseProjectCountArgs} args - Arguments to filter PhaseProjects to count.
     * @example
     * // Count the number of PhaseProjects
     * const count = await prisma.phaseProject.count({
     *   where: {
     *     // ... the filter for the PhaseProjects we want to count
     *   }
     * })
    **/
    count<T extends PhaseProjectCountArgs>(
      args?: Subset<T, PhaseProjectCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PhaseProjectCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PhaseProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseProjectAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PhaseProjectAggregateArgs>(args: Subset<T, PhaseProjectAggregateArgs>): Prisma.PrismaPromise<GetPhaseProjectAggregateType<T>>

    /**
     * Group by PhaseProject.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PhaseProjectGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PhaseProjectGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PhaseProjectGroupByArgs['orderBy'] }
        : { orderBy?: PhaseProjectGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PhaseProjectGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPhaseProjectGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PhaseProject model
   */
  readonly fields: PhaseProjectFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PhaseProject.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PhaseProjectClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    phase<T extends RoadmapPhaseDefaultArgs<ExtArgs> = {}>(args?: Subset<T, RoadmapPhaseDefaultArgs<ExtArgs>>): Prisma__RoadmapPhaseClient<$Result.GetResult<Prisma.$RoadmapPhasePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PhaseProject model
   */ 
  interface PhaseProjectFieldRefs {
    readonly id: FieldRef<"PhaseProject", 'String'>
    readonly phaseId: FieldRef<"PhaseProject", 'String'>
    readonly title: FieldRef<"PhaseProject", 'String'>
    readonly description: FieldRef<"PhaseProject", 'String'>
    readonly tags: FieldRef<"PhaseProject", 'Json'>
  }
    

  // Custom InputTypes
  /**
   * PhaseProject findUnique
   */
  export type PhaseProjectFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseProject
     */
    select?: PhaseProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseProjectInclude<ExtArgs> | null
    /**
     * Filter, which PhaseProject to fetch.
     */
    where: PhaseProjectWhereUniqueInput
  }

  /**
   * PhaseProject findUniqueOrThrow
   */
  export type PhaseProjectFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseProject
     */
    select?: PhaseProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseProjectInclude<ExtArgs> | null
    /**
     * Filter, which PhaseProject to fetch.
     */
    where: PhaseProjectWhereUniqueInput
  }

  /**
   * PhaseProject findFirst
   */
  export type PhaseProjectFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseProject
     */
    select?: PhaseProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseProjectInclude<ExtArgs> | null
    /**
     * Filter, which PhaseProject to fetch.
     */
    where?: PhaseProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhaseProjects to fetch.
     */
    orderBy?: PhaseProjectOrderByWithRelationInput | PhaseProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhaseProjects.
     */
    cursor?: PhaseProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhaseProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhaseProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhaseProjects.
     */
    distinct?: PhaseProjectScalarFieldEnum | PhaseProjectScalarFieldEnum[]
  }

  /**
   * PhaseProject findFirstOrThrow
   */
  export type PhaseProjectFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseProject
     */
    select?: PhaseProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseProjectInclude<ExtArgs> | null
    /**
     * Filter, which PhaseProject to fetch.
     */
    where?: PhaseProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhaseProjects to fetch.
     */
    orderBy?: PhaseProjectOrderByWithRelationInput | PhaseProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PhaseProjects.
     */
    cursor?: PhaseProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhaseProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhaseProjects.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PhaseProjects.
     */
    distinct?: PhaseProjectScalarFieldEnum | PhaseProjectScalarFieldEnum[]
  }

  /**
   * PhaseProject findMany
   */
  export type PhaseProjectFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseProject
     */
    select?: PhaseProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseProjectInclude<ExtArgs> | null
    /**
     * Filter, which PhaseProjects to fetch.
     */
    where?: PhaseProjectWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PhaseProjects to fetch.
     */
    orderBy?: PhaseProjectOrderByWithRelationInput | PhaseProjectOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PhaseProjects.
     */
    cursor?: PhaseProjectWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PhaseProjects from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PhaseProjects.
     */
    skip?: number
    distinct?: PhaseProjectScalarFieldEnum | PhaseProjectScalarFieldEnum[]
  }

  /**
   * PhaseProject create
   */
  export type PhaseProjectCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseProject
     */
    select?: PhaseProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseProjectInclude<ExtArgs> | null
    /**
     * The data needed to create a PhaseProject.
     */
    data: XOR<PhaseProjectCreateInput, PhaseProjectUncheckedCreateInput>
  }

  /**
   * PhaseProject createMany
   */
  export type PhaseProjectCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PhaseProjects.
     */
    data: PhaseProjectCreateManyInput | PhaseProjectCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PhaseProject update
   */
  export type PhaseProjectUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseProject
     */
    select?: PhaseProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseProjectInclude<ExtArgs> | null
    /**
     * The data needed to update a PhaseProject.
     */
    data: XOR<PhaseProjectUpdateInput, PhaseProjectUncheckedUpdateInput>
    /**
     * Choose, which PhaseProject to update.
     */
    where: PhaseProjectWhereUniqueInput
  }

  /**
   * PhaseProject updateMany
   */
  export type PhaseProjectUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PhaseProjects.
     */
    data: XOR<PhaseProjectUpdateManyMutationInput, PhaseProjectUncheckedUpdateManyInput>
    /**
     * Filter which PhaseProjects to update
     */
    where?: PhaseProjectWhereInput
  }

  /**
   * PhaseProject upsert
   */
  export type PhaseProjectUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseProject
     */
    select?: PhaseProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseProjectInclude<ExtArgs> | null
    /**
     * The filter to search for the PhaseProject to update in case it exists.
     */
    where: PhaseProjectWhereUniqueInput
    /**
     * In case the PhaseProject found by the `where` argument doesn't exist, create a new PhaseProject with this data.
     */
    create: XOR<PhaseProjectCreateInput, PhaseProjectUncheckedCreateInput>
    /**
     * In case the PhaseProject was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PhaseProjectUpdateInput, PhaseProjectUncheckedUpdateInput>
  }

  /**
   * PhaseProject delete
   */
  export type PhaseProjectDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseProject
     */
    select?: PhaseProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseProjectInclude<ExtArgs> | null
    /**
     * Filter which PhaseProject to delete.
     */
    where: PhaseProjectWhereUniqueInput
  }

  /**
   * PhaseProject deleteMany
   */
  export type PhaseProjectDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PhaseProjects to delete
     */
    where?: PhaseProjectWhereInput
  }

  /**
   * PhaseProject without action
   */
  export type PhaseProjectDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PhaseProject
     */
    select?: PhaseProjectSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PhaseProjectInclude<ExtArgs> | null
  }


  /**
   * Model DSASheet
   */

  export type AggregateDSASheet = {
    _count: DSASheetCountAggregateOutputType | null
    _min: DSASheetMinAggregateOutputType | null
    _max: DSASheetMaxAggregateOutputType | null
  }

  export type DSASheetMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    level: string | null
    createdAt: Date | null
  }

  export type DSASheetMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    level: string | null
    createdAt: Date | null
  }

  export type DSASheetCountAggregateOutputType = {
    id: number
    title: number
    description: number
    level: number
    createdAt: number
    _all: number
  }


  export type DSASheetMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    level?: true
    createdAt?: true
  }

  export type DSASheetMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    level?: true
    createdAt?: true
  }

  export type DSASheetCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    level?: true
    createdAt?: true
    _all?: true
  }

  export type DSASheetAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DSASheet to aggregate.
     */
    where?: DSASheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSASheets to fetch.
     */
    orderBy?: DSASheetOrderByWithRelationInput | DSASheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DSASheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSASheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSASheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DSASheets
    **/
    _count?: true | DSASheetCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DSASheetMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DSASheetMaxAggregateInputType
  }

  export type GetDSASheetAggregateType<T extends DSASheetAggregateArgs> = {
        [P in keyof T & keyof AggregateDSASheet]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDSASheet[P]>
      : GetScalarType<T[P], AggregateDSASheet[P]>
  }




  export type DSASheetGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DSASheetWhereInput
    orderBy?: DSASheetOrderByWithAggregationInput | DSASheetOrderByWithAggregationInput[]
    by: DSASheetScalarFieldEnum[] | DSASheetScalarFieldEnum
    having?: DSASheetScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DSASheetCountAggregateInputType | true
    _min?: DSASheetMinAggregateInputType
    _max?: DSASheetMaxAggregateInputType
  }

  export type DSASheetGroupByOutputType = {
    id: string
    title: string
    description: string
    level: string
    createdAt: Date
    _count: DSASheetCountAggregateOutputType | null
    _min: DSASheetMinAggregateOutputType | null
    _max: DSASheetMaxAggregateOutputType | null
  }

  type GetDSASheetGroupByPayload<T extends DSASheetGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DSASheetGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DSASheetGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DSASheetGroupByOutputType[P]>
            : GetScalarType<T[P], DSASheetGroupByOutputType[P]>
        }
      >
    >


  export type DSASheetSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    level?: boolean
    createdAt?: boolean
    topics?: boolean | DSASheet$topicsArgs<ExtArgs>
    _count?: boolean | DSASheetCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dSASheet"]>


  export type DSASheetSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    level?: boolean
    createdAt?: boolean
  }

  export type DSASheetInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topics?: boolean | DSASheet$topicsArgs<ExtArgs>
    _count?: boolean | DSASheetCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DSASheetPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DSASheet"
    objects: {
      topics: Prisma.$DSATopicPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string
      level: string
      createdAt: Date
    }, ExtArgs["result"]["dSASheet"]>
    composites: {}
  }

  type DSASheetGetPayload<S extends boolean | null | undefined | DSASheetDefaultArgs> = $Result.GetResult<Prisma.$DSASheetPayload, S>

  type DSASheetCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DSASheetFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DSASheetCountAggregateInputType | true
    }

  export interface DSASheetDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DSASheet'], meta: { name: 'DSASheet' } }
    /**
     * Find zero or one DSASheet that matches the filter.
     * @param {DSASheetFindUniqueArgs} args - Arguments to find a DSASheet
     * @example
     * // Get one DSASheet
     * const dSASheet = await prisma.dSASheet.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DSASheetFindUniqueArgs>(args: SelectSubset<T, DSASheetFindUniqueArgs<ExtArgs>>): Prisma__DSASheetClient<$Result.GetResult<Prisma.$DSASheetPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DSASheet that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DSASheetFindUniqueOrThrowArgs} args - Arguments to find a DSASheet
     * @example
     * // Get one DSASheet
     * const dSASheet = await prisma.dSASheet.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DSASheetFindUniqueOrThrowArgs>(args: SelectSubset<T, DSASheetFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DSASheetClient<$Result.GetResult<Prisma.$DSASheetPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DSASheet that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASheetFindFirstArgs} args - Arguments to find a DSASheet
     * @example
     * // Get one DSASheet
     * const dSASheet = await prisma.dSASheet.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DSASheetFindFirstArgs>(args?: SelectSubset<T, DSASheetFindFirstArgs<ExtArgs>>): Prisma__DSASheetClient<$Result.GetResult<Prisma.$DSASheetPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DSASheet that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASheetFindFirstOrThrowArgs} args - Arguments to find a DSASheet
     * @example
     * // Get one DSASheet
     * const dSASheet = await prisma.dSASheet.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DSASheetFindFirstOrThrowArgs>(args?: SelectSubset<T, DSASheetFindFirstOrThrowArgs<ExtArgs>>): Prisma__DSASheetClient<$Result.GetResult<Prisma.$DSASheetPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DSASheets that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASheetFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DSASheets
     * const dSASheets = await prisma.dSASheet.findMany()
     * 
     * // Get first 10 DSASheets
     * const dSASheets = await prisma.dSASheet.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dSASheetWithIdOnly = await prisma.dSASheet.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DSASheetFindManyArgs>(args?: SelectSubset<T, DSASheetFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DSASheetPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DSASheet.
     * @param {DSASheetCreateArgs} args - Arguments to create a DSASheet.
     * @example
     * // Create one DSASheet
     * const DSASheet = await prisma.dSASheet.create({
     *   data: {
     *     // ... data to create a DSASheet
     *   }
     * })
     * 
     */
    create<T extends DSASheetCreateArgs>(args: SelectSubset<T, DSASheetCreateArgs<ExtArgs>>): Prisma__DSASheetClient<$Result.GetResult<Prisma.$DSASheetPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DSASheets.
     * @param {DSASheetCreateManyArgs} args - Arguments to create many DSASheets.
     * @example
     * // Create many DSASheets
     * const dSASheet = await prisma.dSASheet.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DSASheetCreateManyArgs>(args?: SelectSubset<T, DSASheetCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DSASheet.
     * @param {DSASheetDeleteArgs} args - Arguments to delete one DSASheet.
     * @example
     * // Delete one DSASheet
     * const DSASheet = await prisma.dSASheet.delete({
     *   where: {
     *     // ... filter to delete one DSASheet
     *   }
     * })
     * 
     */
    delete<T extends DSASheetDeleteArgs>(args: SelectSubset<T, DSASheetDeleteArgs<ExtArgs>>): Prisma__DSASheetClient<$Result.GetResult<Prisma.$DSASheetPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DSASheet.
     * @param {DSASheetUpdateArgs} args - Arguments to update one DSASheet.
     * @example
     * // Update one DSASheet
     * const dSASheet = await prisma.dSASheet.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DSASheetUpdateArgs>(args: SelectSubset<T, DSASheetUpdateArgs<ExtArgs>>): Prisma__DSASheetClient<$Result.GetResult<Prisma.$DSASheetPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DSASheets.
     * @param {DSASheetDeleteManyArgs} args - Arguments to filter DSASheets to delete.
     * @example
     * // Delete a few DSASheets
     * const { count } = await prisma.dSASheet.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DSASheetDeleteManyArgs>(args?: SelectSubset<T, DSASheetDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DSASheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASheetUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DSASheets
     * const dSASheet = await prisma.dSASheet.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DSASheetUpdateManyArgs>(args: SelectSubset<T, DSASheetUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DSASheet.
     * @param {DSASheetUpsertArgs} args - Arguments to update or create a DSASheet.
     * @example
     * // Update or create a DSASheet
     * const dSASheet = await prisma.dSASheet.upsert({
     *   create: {
     *     // ... data to create a DSASheet
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DSASheet we want to update
     *   }
     * })
     */
    upsert<T extends DSASheetUpsertArgs>(args: SelectSubset<T, DSASheetUpsertArgs<ExtArgs>>): Prisma__DSASheetClient<$Result.GetResult<Prisma.$DSASheetPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DSASheets.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASheetCountArgs} args - Arguments to filter DSASheets to count.
     * @example
     * // Count the number of DSASheets
     * const count = await prisma.dSASheet.count({
     *   where: {
     *     // ... the filter for the DSASheets we want to count
     *   }
     * })
    **/
    count<T extends DSASheetCountArgs>(
      args?: Subset<T, DSASheetCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DSASheetCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DSASheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASheetAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DSASheetAggregateArgs>(args: Subset<T, DSASheetAggregateArgs>): Prisma.PrismaPromise<GetDSASheetAggregateType<T>>

    /**
     * Group by DSASheet.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASheetGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DSASheetGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DSASheetGroupByArgs['orderBy'] }
        : { orderBy?: DSASheetGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DSASheetGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDSASheetGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DSASheet model
   */
  readonly fields: DSASheetFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DSASheet.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DSASheetClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topics<T extends DSASheet$topicsArgs<ExtArgs> = {}>(args?: Subset<T, DSASheet$topicsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DSASheet model
   */ 
  interface DSASheetFieldRefs {
    readonly id: FieldRef<"DSASheet", 'String'>
    readonly title: FieldRef<"DSASheet", 'String'>
    readonly description: FieldRef<"DSASheet", 'String'>
    readonly level: FieldRef<"DSASheet", 'String'>
    readonly createdAt: FieldRef<"DSASheet", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * DSASheet findUnique
   */
  export type DSASheetFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASheet
     */
    select?: DSASheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASheetInclude<ExtArgs> | null
    /**
     * Filter, which DSASheet to fetch.
     */
    where: DSASheetWhereUniqueInput
  }

  /**
   * DSASheet findUniqueOrThrow
   */
  export type DSASheetFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASheet
     */
    select?: DSASheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASheetInclude<ExtArgs> | null
    /**
     * Filter, which DSASheet to fetch.
     */
    where: DSASheetWhereUniqueInput
  }

  /**
   * DSASheet findFirst
   */
  export type DSASheetFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASheet
     */
    select?: DSASheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASheetInclude<ExtArgs> | null
    /**
     * Filter, which DSASheet to fetch.
     */
    where?: DSASheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSASheets to fetch.
     */
    orderBy?: DSASheetOrderByWithRelationInput | DSASheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DSASheets.
     */
    cursor?: DSASheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSASheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSASheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DSASheets.
     */
    distinct?: DSASheetScalarFieldEnum | DSASheetScalarFieldEnum[]
  }

  /**
   * DSASheet findFirstOrThrow
   */
  export type DSASheetFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASheet
     */
    select?: DSASheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASheetInclude<ExtArgs> | null
    /**
     * Filter, which DSASheet to fetch.
     */
    where?: DSASheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSASheets to fetch.
     */
    orderBy?: DSASheetOrderByWithRelationInput | DSASheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DSASheets.
     */
    cursor?: DSASheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSASheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSASheets.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DSASheets.
     */
    distinct?: DSASheetScalarFieldEnum | DSASheetScalarFieldEnum[]
  }

  /**
   * DSASheet findMany
   */
  export type DSASheetFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASheet
     */
    select?: DSASheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASheetInclude<ExtArgs> | null
    /**
     * Filter, which DSASheets to fetch.
     */
    where?: DSASheetWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSASheets to fetch.
     */
    orderBy?: DSASheetOrderByWithRelationInput | DSASheetOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DSASheets.
     */
    cursor?: DSASheetWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSASheets from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSASheets.
     */
    skip?: number
    distinct?: DSASheetScalarFieldEnum | DSASheetScalarFieldEnum[]
  }

  /**
   * DSASheet create
   */
  export type DSASheetCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASheet
     */
    select?: DSASheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASheetInclude<ExtArgs> | null
    /**
     * The data needed to create a DSASheet.
     */
    data: XOR<DSASheetCreateInput, DSASheetUncheckedCreateInput>
  }

  /**
   * DSASheet createMany
   */
  export type DSASheetCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DSASheets.
     */
    data: DSASheetCreateManyInput | DSASheetCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DSASheet update
   */
  export type DSASheetUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASheet
     */
    select?: DSASheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASheetInclude<ExtArgs> | null
    /**
     * The data needed to update a DSASheet.
     */
    data: XOR<DSASheetUpdateInput, DSASheetUncheckedUpdateInput>
    /**
     * Choose, which DSASheet to update.
     */
    where: DSASheetWhereUniqueInput
  }

  /**
   * DSASheet updateMany
   */
  export type DSASheetUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DSASheets.
     */
    data: XOR<DSASheetUpdateManyMutationInput, DSASheetUncheckedUpdateManyInput>
    /**
     * Filter which DSASheets to update
     */
    where?: DSASheetWhereInput
  }

  /**
   * DSASheet upsert
   */
  export type DSASheetUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASheet
     */
    select?: DSASheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASheetInclude<ExtArgs> | null
    /**
     * The filter to search for the DSASheet to update in case it exists.
     */
    where: DSASheetWhereUniqueInput
    /**
     * In case the DSASheet found by the `where` argument doesn't exist, create a new DSASheet with this data.
     */
    create: XOR<DSASheetCreateInput, DSASheetUncheckedCreateInput>
    /**
     * In case the DSASheet was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DSASheetUpdateInput, DSASheetUncheckedUpdateInput>
  }

  /**
   * DSASheet delete
   */
  export type DSASheetDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASheet
     */
    select?: DSASheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASheetInclude<ExtArgs> | null
    /**
     * Filter which DSASheet to delete.
     */
    where: DSASheetWhereUniqueInput
  }

  /**
   * DSASheet deleteMany
   */
  export type DSASheetDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DSASheets to delete
     */
    where?: DSASheetWhereInput
  }

  /**
   * DSASheet.topics
   */
  export type DSASheet$topicsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    where?: DSATopicWhereInput
    orderBy?: DSATopicOrderByWithRelationInput | DSATopicOrderByWithRelationInput[]
    cursor?: DSATopicWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DSATopicScalarFieldEnum | DSATopicScalarFieldEnum[]
  }

  /**
   * DSASheet without action
   */
  export type DSASheetDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASheet
     */
    select?: DSASheetSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASheetInclude<ExtArgs> | null
  }


  /**
   * Model DSATopic
   */

  export type AggregateDSATopic = {
    _count: DSATopicCountAggregateOutputType | null
    _avg: DSATopicAvgAggregateOutputType | null
    _sum: DSATopicSumAggregateOutputType | null
    _min: DSATopicMinAggregateOutputType | null
    _max: DSATopicMaxAggregateOutputType | null
  }

  export type DSATopicAvgAggregateOutputType = {
    order: number | null
  }

  export type DSATopicSumAggregateOutputType = {
    order: number | null
  }

  export type DSATopicMinAggregateOutputType = {
    id: string | null
    title: string | null
    sheetId: string | null
    order: number | null
  }

  export type DSATopicMaxAggregateOutputType = {
    id: string | null
    title: string | null
    sheetId: string | null
    order: number | null
  }

  export type DSATopicCountAggregateOutputType = {
    id: number
    title: number
    sheetId: number
    order: number
    _all: number
  }


  export type DSATopicAvgAggregateInputType = {
    order?: true
  }

  export type DSATopicSumAggregateInputType = {
    order?: true
  }

  export type DSATopicMinAggregateInputType = {
    id?: true
    title?: true
    sheetId?: true
    order?: true
  }

  export type DSATopicMaxAggregateInputType = {
    id?: true
    title?: true
    sheetId?: true
    order?: true
  }

  export type DSATopicCountAggregateInputType = {
    id?: true
    title?: true
    sheetId?: true
    order?: true
    _all?: true
  }

  export type DSATopicAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DSATopic to aggregate.
     */
    where?: DSATopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSATopics to fetch.
     */
    orderBy?: DSATopicOrderByWithRelationInput | DSATopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DSATopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSATopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSATopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DSATopics
    **/
    _count?: true | DSATopicCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DSATopicAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DSATopicSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DSATopicMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DSATopicMaxAggregateInputType
  }

  export type GetDSATopicAggregateType<T extends DSATopicAggregateArgs> = {
        [P in keyof T & keyof AggregateDSATopic]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDSATopic[P]>
      : GetScalarType<T[P], AggregateDSATopic[P]>
  }




  export type DSATopicGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DSATopicWhereInput
    orderBy?: DSATopicOrderByWithAggregationInput | DSATopicOrderByWithAggregationInput[]
    by: DSATopicScalarFieldEnum[] | DSATopicScalarFieldEnum
    having?: DSATopicScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DSATopicCountAggregateInputType | true
    _avg?: DSATopicAvgAggregateInputType
    _sum?: DSATopicSumAggregateInputType
    _min?: DSATopicMinAggregateInputType
    _max?: DSATopicMaxAggregateInputType
  }

  export type DSATopicGroupByOutputType = {
    id: string
    title: string
    sheetId: string
    order: number
    _count: DSATopicCountAggregateOutputType | null
    _avg: DSATopicAvgAggregateOutputType | null
    _sum: DSATopicSumAggregateOutputType | null
    _min: DSATopicMinAggregateOutputType | null
    _max: DSATopicMaxAggregateOutputType | null
  }

  type GetDSATopicGroupByPayload<T extends DSATopicGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DSATopicGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DSATopicGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DSATopicGroupByOutputType[P]>
            : GetScalarType<T[P], DSATopicGroupByOutputType[P]>
        }
      >
    >


  export type DSATopicSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    sheetId?: boolean
    order?: boolean
    sheet?: boolean | DSASheetDefaultArgs<ExtArgs>
    problems?: boolean | DSATopic$problemsArgs<ExtArgs>
    _count?: boolean | DSATopicCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dSATopic"]>


  export type DSATopicSelectScalar = {
    id?: boolean
    title?: boolean
    sheetId?: boolean
    order?: boolean
  }

  export type DSATopicInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    sheet?: boolean | DSASheetDefaultArgs<ExtArgs>
    problems?: boolean | DSATopic$problemsArgs<ExtArgs>
    _count?: boolean | DSATopicCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DSATopicPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DSATopic"
    objects: {
      sheet: Prisma.$DSASheetPayload<ExtArgs>
      problems: Prisma.$DSAProblemPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      sheetId: string
      order: number
    }, ExtArgs["result"]["dSATopic"]>
    composites: {}
  }

  type DSATopicGetPayload<S extends boolean | null | undefined | DSATopicDefaultArgs> = $Result.GetResult<Prisma.$DSATopicPayload, S>

  type DSATopicCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DSATopicFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DSATopicCountAggregateInputType | true
    }

  export interface DSATopicDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DSATopic'], meta: { name: 'DSATopic' } }
    /**
     * Find zero or one DSATopic that matches the filter.
     * @param {DSATopicFindUniqueArgs} args - Arguments to find a DSATopic
     * @example
     * // Get one DSATopic
     * const dSATopic = await prisma.dSATopic.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DSATopicFindUniqueArgs>(args: SelectSubset<T, DSATopicFindUniqueArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DSATopic that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DSATopicFindUniqueOrThrowArgs} args - Arguments to find a DSATopic
     * @example
     * // Get one DSATopic
     * const dSATopic = await prisma.dSATopic.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DSATopicFindUniqueOrThrowArgs>(args: SelectSubset<T, DSATopicFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DSATopic that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicFindFirstArgs} args - Arguments to find a DSATopic
     * @example
     * // Get one DSATopic
     * const dSATopic = await prisma.dSATopic.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DSATopicFindFirstArgs>(args?: SelectSubset<T, DSATopicFindFirstArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DSATopic that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicFindFirstOrThrowArgs} args - Arguments to find a DSATopic
     * @example
     * // Get one DSATopic
     * const dSATopic = await prisma.dSATopic.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DSATopicFindFirstOrThrowArgs>(args?: SelectSubset<T, DSATopicFindFirstOrThrowArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DSATopics that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DSATopics
     * const dSATopics = await prisma.dSATopic.findMany()
     * 
     * // Get first 10 DSATopics
     * const dSATopics = await prisma.dSATopic.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dSATopicWithIdOnly = await prisma.dSATopic.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DSATopicFindManyArgs>(args?: SelectSubset<T, DSATopicFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DSATopic.
     * @param {DSATopicCreateArgs} args - Arguments to create a DSATopic.
     * @example
     * // Create one DSATopic
     * const DSATopic = await prisma.dSATopic.create({
     *   data: {
     *     // ... data to create a DSATopic
     *   }
     * })
     * 
     */
    create<T extends DSATopicCreateArgs>(args: SelectSubset<T, DSATopicCreateArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DSATopics.
     * @param {DSATopicCreateManyArgs} args - Arguments to create many DSATopics.
     * @example
     * // Create many DSATopics
     * const dSATopic = await prisma.dSATopic.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DSATopicCreateManyArgs>(args?: SelectSubset<T, DSATopicCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DSATopic.
     * @param {DSATopicDeleteArgs} args - Arguments to delete one DSATopic.
     * @example
     * // Delete one DSATopic
     * const DSATopic = await prisma.dSATopic.delete({
     *   where: {
     *     // ... filter to delete one DSATopic
     *   }
     * })
     * 
     */
    delete<T extends DSATopicDeleteArgs>(args: SelectSubset<T, DSATopicDeleteArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DSATopic.
     * @param {DSATopicUpdateArgs} args - Arguments to update one DSATopic.
     * @example
     * // Update one DSATopic
     * const dSATopic = await prisma.dSATopic.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DSATopicUpdateArgs>(args: SelectSubset<T, DSATopicUpdateArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DSATopics.
     * @param {DSATopicDeleteManyArgs} args - Arguments to filter DSATopics to delete.
     * @example
     * // Delete a few DSATopics
     * const { count } = await prisma.dSATopic.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DSATopicDeleteManyArgs>(args?: SelectSubset<T, DSATopicDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DSATopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DSATopics
     * const dSATopic = await prisma.dSATopic.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DSATopicUpdateManyArgs>(args: SelectSubset<T, DSATopicUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DSATopic.
     * @param {DSATopicUpsertArgs} args - Arguments to update or create a DSATopic.
     * @example
     * // Update or create a DSATopic
     * const dSATopic = await prisma.dSATopic.upsert({
     *   create: {
     *     // ... data to create a DSATopic
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DSATopic we want to update
     *   }
     * })
     */
    upsert<T extends DSATopicUpsertArgs>(args: SelectSubset<T, DSATopicUpsertArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DSATopics.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicCountArgs} args - Arguments to filter DSATopics to count.
     * @example
     * // Count the number of DSATopics
     * const count = await prisma.dSATopic.count({
     *   where: {
     *     // ... the filter for the DSATopics we want to count
     *   }
     * })
    **/
    count<T extends DSATopicCountArgs>(
      args?: Subset<T, DSATopicCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DSATopicCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DSATopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DSATopicAggregateArgs>(args: Subset<T, DSATopicAggregateArgs>): Prisma.PrismaPromise<GetDSATopicAggregateType<T>>

    /**
     * Group by DSATopic.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSATopicGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DSATopicGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DSATopicGroupByArgs['orderBy'] }
        : { orderBy?: DSATopicGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DSATopicGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDSATopicGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DSATopic model
   */
  readonly fields: DSATopicFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DSATopic.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DSATopicClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    sheet<T extends DSASheetDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DSASheetDefaultArgs<ExtArgs>>): Prisma__DSASheetClient<$Result.GetResult<Prisma.$DSASheetPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    problems<T extends DSATopic$problemsArgs<ExtArgs> = {}>(args?: Subset<T, DSATopic$problemsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DSAProblemPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DSATopic model
   */ 
  interface DSATopicFieldRefs {
    readonly id: FieldRef<"DSATopic", 'String'>
    readonly title: FieldRef<"DSATopic", 'String'>
    readonly sheetId: FieldRef<"DSATopic", 'String'>
    readonly order: FieldRef<"DSATopic", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DSATopic findUnique
   */
  export type DSATopicFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * Filter, which DSATopic to fetch.
     */
    where: DSATopicWhereUniqueInput
  }

  /**
   * DSATopic findUniqueOrThrow
   */
  export type DSATopicFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * Filter, which DSATopic to fetch.
     */
    where: DSATopicWhereUniqueInput
  }

  /**
   * DSATopic findFirst
   */
  export type DSATopicFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * Filter, which DSATopic to fetch.
     */
    where?: DSATopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSATopics to fetch.
     */
    orderBy?: DSATopicOrderByWithRelationInput | DSATopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DSATopics.
     */
    cursor?: DSATopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSATopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSATopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DSATopics.
     */
    distinct?: DSATopicScalarFieldEnum | DSATopicScalarFieldEnum[]
  }

  /**
   * DSATopic findFirstOrThrow
   */
  export type DSATopicFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * Filter, which DSATopic to fetch.
     */
    where?: DSATopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSATopics to fetch.
     */
    orderBy?: DSATopicOrderByWithRelationInput | DSATopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DSATopics.
     */
    cursor?: DSATopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSATopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSATopics.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DSATopics.
     */
    distinct?: DSATopicScalarFieldEnum | DSATopicScalarFieldEnum[]
  }

  /**
   * DSATopic findMany
   */
  export type DSATopicFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * Filter, which DSATopics to fetch.
     */
    where?: DSATopicWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSATopics to fetch.
     */
    orderBy?: DSATopicOrderByWithRelationInput | DSATopicOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DSATopics.
     */
    cursor?: DSATopicWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSATopics from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSATopics.
     */
    skip?: number
    distinct?: DSATopicScalarFieldEnum | DSATopicScalarFieldEnum[]
  }

  /**
   * DSATopic create
   */
  export type DSATopicCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * The data needed to create a DSATopic.
     */
    data: XOR<DSATopicCreateInput, DSATopicUncheckedCreateInput>
  }

  /**
   * DSATopic createMany
   */
  export type DSATopicCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DSATopics.
     */
    data: DSATopicCreateManyInput | DSATopicCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DSATopic update
   */
  export type DSATopicUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * The data needed to update a DSATopic.
     */
    data: XOR<DSATopicUpdateInput, DSATopicUncheckedUpdateInput>
    /**
     * Choose, which DSATopic to update.
     */
    where: DSATopicWhereUniqueInput
  }

  /**
   * DSATopic updateMany
   */
  export type DSATopicUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DSATopics.
     */
    data: XOR<DSATopicUpdateManyMutationInput, DSATopicUncheckedUpdateManyInput>
    /**
     * Filter which DSATopics to update
     */
    where?: DSATopicWhereInput
  }

  /**
   * DSATopic upsert
   */
  export type DSATopicUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * The filter to search for the DSATopic to update in case it exists.
     */
    where: DSATopicWhereUniqueInput
    /**
     * In case the DSATopic found by the `where` argument doesn't exist, create a new DSATopic with this data.
     */
    create: XOR<DSATopicCreateInput, DSATopicUncheckedCreateInput>
    /**
     * In case the DSATopic was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DSATopicUpdateInput, DSATopicUncheckedUpdateInput>
  }

  /**
   * DSATopic delete
   */
  export type DSATopicDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
    /**
     * Filter which DSATopic to delete.
     */
    where: DSATopicWhereUniqueInput
  }

  /**
   * DSATopic deleteMany
   */
  export type DSATopicDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DSATopics to delete
     */
    where?: DSATopicWhereInput
  }

  /**
   * DSATopic.problems
   */
  export type DSATopic$problemsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSAProblem
     */
    select?: DSAProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSAProblemInclude<ExtArgs> | null
    where?: DSAProblemWhereInput
    orderBy?: DSAProblemOrderByWithRelationInput | DSAProblemOrderByWithRelationInput[]
    cursor?: DSAProblemWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DSAProblemScalarFieldEnum | DSAProblemScalarFieldEnum[]
  }

  /**
   * DSATopic without action
   */
  export type DSATopicDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSATopic
     */
    select?: DSATopicSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSATopicInclude<ExtArgs> | null
  }


  /**
   * Model DSAProblem
   */

  export type AggregateDSAProblem = {
    _count: DSAProblemCountAggregateOutputType | null
    _avg: DSAProblemAvgAggregateOutputType | null
    _sum: DSAProblemSumAggregateOutputType | null
    _min: DSAProblemMinAggregateOutputType | null
    _max: DSAProblemMaxAggregateOutputType | null
  }

  export type DSAProblemAvgAggregateOutputType = {
    order: number | null
  }

  export type DSAProblemSumAggregateOutputType = {
    order: number | null
  }

  export type DSAProblemMinAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    difficulty: string | null
    topicId: string | null
    order: number | null
  }

  export type DSAProblemMaxAggregateOutputType = {
    id: string | null
    title: string | null
    description: string | null
    difficulty: string | null
    topicId: string | null
    order: number | null
  }

  export type DSAProblemCountAggregateOutputType = {
    id: number
    title: number
    description: number
    difficulty: number
    topicId: number
    order: number
    _all: number
  }


  export type DSAProblemAvgAggregateInputType = {
    order?: true
  }

  export type DSAProblemSumAggregateInputType = {
    order?: true
  }

  export type DSAProblemMinAggregateInputType = {
    id?: true
    title?: true
    description?: true
    difficulty?: true
    topicId?: true
    order?: true
  }

  export type DSAProblemMaxAggregateInputType = {
    id?: true
    title?: true
    description?: true
    difficulty?: true
    topicId?: true
    order?: true
  }

  export type DSAProblemCountAggregateInputType = {
    id?: true
    title?: true
    description?: true
    difficulty?: true
    topicId?: true
    order?: true
    _all?: true
  }

  export type DSAProblemAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DSAProblem to aggregate.
     */
    where?: DSAProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSAProblems to fetch.
     */
    orderBy?: DSAProblemOrderByWithRelationInput | DSAProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DSAProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSAProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSAProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DSAProblems
    **/
    _count?: true | DSAProblemCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DSAProblemAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DSAProblemSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DSAProblemMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DSAProblemMaxAggregateInputType
  }

  export type GetDSAProblemAggregateType<T extends DSAProblemAggregateArgs> = {
        [P in keyof T & keyof AggregateDSAProblem]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDSAProblem[P]>
      : GetScalarType<T[P], AggregateDSAProblem[P]>
  }




  export type DSAProblemGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DSAProblemWhereInput
    orderBy?: DSAProblemOrderByWithAggregationInput | DSAProblemOrderByWithAggregationInput[]
    by: DSAProblemScalarFieldEnum[] | DSAProblemScalarFieldEnum
    having?: DSAProblemScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DSAProblemCountAggregateInputType | true
    _avg?: DSAProblemAvgAggregateInputType
    _sum?: DSAProblemSumAggregateInputType
    _min?: DSAProblemMinAggregateInputType
    _max?: DSAProblemMaxAggregateInputType
  }

  export type DSAProblemGroupByOutputType = {
    id: string
    title: string
    description: string | null
    difficulty: string
    topicId: string
    order: number
    _count: DSAProblemCountAggregateOutputType | null
    _avg: DSAProblemAvgAggregateOutputType | null
    _sum: DSAProblemSumAggregateOutputType | null
    _min: DSAProblemMinAggregateOutputType | null
    _max: DSAProblemMaxAggregateOutputType | null
  }

  type GetDSAProblemGroupByPayload<T extends DSAProblemGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DSAProblemGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DSAProblemGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DSAProblemGroupByOutputType[P]>
            : GetScalarType<T[P], DSAProblemGroupByOutputType[P]>
        }
      >
    >


  export type DSAProblemSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    title?: boolean
    description?: boolean
    difficulty?: boolean
    topicId?: boolean
    order?: boolean
    topic?: boolean | DSATopicDefaultArgs<ExtArgs>
    solutions?: boolean | DSAProblem$solutionsArgs<ExtArgs>
    _count?: boolean | DSAProblemCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dSAProblem"]>


  export type DSAProblemSelectScalar = {
    id?: boolean
    title?: boolean
    description?: boolean
    difficulty?: boolean
    topicId?: boolean
    order?: boolean
  }

  export type DSAProblemInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    topic?: boolean | DSATopicDefaultArgs<ExtArgs>
    solutions?: boolean | DSAProblem$solutionsArgs<ExtArgs>
    _count?: boolean | DSAProblemCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $DSAProblemPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DSAProblem"
    objects: {
      topic: Prisma.$DSATopicPayload<ExtArgs>
      solutions: Prisma.$DSASolutionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      title: string
      description: string | null
      difficulty: string
      topicId: string
      order: number
    }, ExtArgs["result"]["dSAProblem"]>
    composites: {}
  }

  type DSAProblemGetPayload<S extends boolean | null | undefined | DSAProblemDefaultArgs> = $Result.GetResult<Prisma.$DSAProblemPayload, S>

  type DSAProblemCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DSAProblemFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DSAProblemCountAggregateInputType | true
    }

  export interface DSAProblemDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DSAProblem'], meta: { name: 'DSAProblem' } }
    /**
     * Find zero or one DSAProblem that matches the filter.
     * @param {DSAProblemFindUniqueArgs} args - Arguments to find a DSAProblem
     * @example
     * // Get one DSAProblem
     * const dSAProblem = await prisma.dSAProblem.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DSAProblemFindUniqueArgs>(args: SelectSubset<T, DSAProblemFindUniqueArgs<ExtArgs>>): Prisma__DSAProblemClient<$Result.GetResult<Prisma.$DSAProblemPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DSAProblem that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DSAProblemFindUniqueOrThrowArgs} args - Arguments to find a DSAProblem
     * @example
     * // Get one DSAProblem
     * const dSAProblem = await prisma.dSAProblem.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DSAProblemFindUniqueOrThrowArgs>(args: SelectSubset<T, DSAProblemFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DSAProblemClient<$Result.GetResult<Prisma.$DSAProblemPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DSAProblem that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSAProblemFindFirstArgs} args - Arguments to find a DSAProblem
     * @example
     * // Get one DSAProblem
     * const dSAProblem = await prisma.dSAProblem.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DSAProblemFindFirstArgs>(args?: SelectSubset<T, DSAProblemFindFirstArgs<ExtArgs>>): Prisma__DSAProblemClient<$Result.GetResult<Prisma.$DSAProblemPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DSAProblem that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSAProblemFindFirstOrThrowArgs} args - Arguments to find a DSAProblem
     * @example
     * // Get one DSAProblem
     * const dSAProblem = await prisma.dSAProblem.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DSAProblemFindFirstOrThrowArgs>(args?: SelectSubset<T, DSAProblemFindFirstOrThrowArgs<ExtArgs>>): Prisma__DSAProblemClient<$Result.GetResult<Prisma.$DSAProblemPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DSAProblems that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSAProblemFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DSAProblems
     * const dSAProblems = await prisma.dSAProblem.findMany()
     * 
     * // Get first 10 DSAProblems
     * const dSAProblems = await prisma.dSAProblem.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dSAProblemWithIdOnly = await prisma.dSAProblem.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DSAProblemFindManyArgs>(args?: SelectSubset<T, DSAProblemFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DSAProblemPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DSAProblem.
     * @param {DSAProblemCreateArgs} args - Arguments to create a DSAProblem.
     * @example
     * // Create one DSAProblem
     * const DSAProblem = await prisma.dSAProblem.create({
     *   data: {
     *     // ... data to create a DSAProblem
     *   }
     * })
     * 
     */
    create<T extends DSAProblemCreateArgs>(args: SelectSubset<T, DSAProblemCreateArgs<ExtArgs>>): Prisma__DSAProblemClient<$Result.GetResult<Prisma.$DSAProblemPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DSAProblems.
     * @param {DSAProblemCreateManyArgs} args - Arguments to create many DSAProblems.
     * @example
     * // Create many DSAProblems
     * const dSAProblem = await prisma.dSAProblem.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DSAProblemCreateManyArgs>(args?: SelectSubset<T, DSAProblemCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DSAProblem.
     * @param {DSAProblemDeleteArgs} args - Arguments to delete one DSAProblem.
     * @example
     * // Delete one DSAProblem
     * const DSAProblem = await prisma.dSAProblem.delete({
     *   where: {
     *     // ... filter to delete one DSAProblem
     *   }
     * })
     * 
     */
    delete<T extends DSAProblemDeleteArgs>(args: SelectSubset<T, DSAProblemDeleteArgs<ExtArgs>>): Prisma__DSAProblemClient<$Result.GetResult<Prisma.$DSAProblemPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DSAProblem.
     * @param {DSAProblemUpdateArgs} args - Arguments to update one DSAProblem.
     * @example
     * // Update one DSAProblem
     * const dSAProblem = await prisma.dSAProblem.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DSAProblemUpdateArgs>(args: SelectSubset<T, DSAProblemUpdateArgs<ExtArgs>>): Prisma__DSAProblemClient<$Result.GetResult<Prisma.$DSAProblemPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DSAProblems.
     * @param {DSAProblemDeleteManyArgs} args - Arguments to filter DSAProblems to delete.
     * @example
     * // Delete a few DSAProblems
     * const { count } = await prisma.dSAProblem.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DSAProblemDeleteManyArgs>(args?: SelectSubset<T, DSAProblemDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DSAProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSAProblemUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DSAProblems
     * const dSAProblem = await prisma.dSAProblem.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DSAProblemUpdateManyArgs>(args: SelectSubset<T, DSAProblemUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DSAProblem.
     * @param {DSAProblemUpsertArgs} args - Arguments to update or create a DSAProblem.
     * @example
     * // Update or create a DSAProblem
     * const dSAProblem = await prisma.dSAProblem.upsert({
     *   create: {
     *     // ... data to create a DSAProblem
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DSAProblem we want to update
     *   }
     * })
     */
    upsert<T extends DSAProblemUpsertArgs>(args: SelectSubset<T, DSAProblemUpsertArgs<ExtArgs>>): Prisma__DSAProblemClient<$Result.GetResult<Prisma.$DSAProblemPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DSAProblems.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSAProblemCountArgs} args - Arguments to filter DSAProblems to count.
     * @example
     * // Count the number of DSAProblems
     * const count = await prisma.dSAProblem.count({
     *   where: {
     *     // ... the filter for the DSAProblems we want to count
     *   }
     * })
    **/
    count<T extends DSAProblemCountArgs>(
      args?: Subset<T, DSAProblemCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DSAProblemCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DSAProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSAProblemAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DSAProblemAggregateArgs>(args: Subset<T, DSAProblemAggregateArgs>): Prisma.PrismaPromise<GetDSAProblemAggregateType<T>>

    /**
     * Group by DSAProblem.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSAProblemGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DSAProblemGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DSAProblemGroupByArgs['orderBy'] }
        : { orderBy?: DSAProblemGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DSAProblemGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDSAProblemGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DSAProblem model
   */
  readonly fields: DSAProblemFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DSAProblem.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DSAProblemClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    topic<T extends DSATopicDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DSATopicDefaultArgs<ExtArgs>>): Prisma__DSATopicClient<$Result.GetResult<Prisma.$DSATopicPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    solutions<T extends DSAProblem$solutionsArgs<ExtArgs> = {}>(args?: Subset<T, DSAProblem$solutionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DSASolutionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DSAProblem model
   */ 
  interface DSAProblemFieldRefs {
    readonly id: FieldRef<"DSAProblem", 'String'>
    readonly title: FieldRef<"DSAProblem", 'String'>
    readonly description: FieldRef<"DSAProblem", 'String'>
    readonly difficulty: FieldRef<"DSAProblem", 'String'>
    readonly topicId: FieldRef<"DSAProblem", 'String'>
    readonly order: FieldRef<"DSAProblem", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * DSAProblem findUnique
   */
  export type DSAProblemFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSAProblem
     */
    select?: DSAProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSAProblemInclude<ExtArgs> | null
    /**
     * Filter, which DSAProblem to fetch.
     */
    where: DSAProblemWhereUniqueInput
  }

  /**
   * DSAProblem findUniqueOrThrow
   */
  export type DSAProblemFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSAProblem
     */
    select?: DSAProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSAProblemInclude<ExtArgs> | null
    /**
     * Filter, which DSAProblem to fetch.
     */
    where: DSAProblemWhereUniqueInput
  }

  /**
   * DSAProblem findFirst
   */
  export type DSAProblemFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSAProblem
     */
    select?: DSAProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSAProblemInclude<ExtArgs> | null
    /**
     * Filter, which DSAProblem to fetch.
     */
    where?: DSAProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSAProblems to fetch.
     */
    orderBy?: DSAProblemOrderByWithRelationInput | DSAProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DSAProblems.
     */
    cursor?: DSAProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSAProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSAProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DSAProblems.
     */
    distinct?: DSAProblemScalarFieldEnum | DSAProblemScalarFieldEnum[]
  }

  /**
   * DSAProblem findFirstOrThrow
   */
  export type DSAProblemFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSAProblem
     */
    select?: DSAProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSAProblemInclude<ExtArgs> | null
    /**
     * Filter, which DSAProblem to fetch.
     */
    where?: DSAProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSAProblems to fetch.
     */
    orderBy?: DSAProblemOrderByWithRelationInput | DSAProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DSAProblems.
     */
    cursor?: DSAProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSAProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSAProblems.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DSAProblems.
     */
    distinct?: DSAProblemScalarFieldEnum | DSAProblemScalarFieldEnum[]
  }

  /**
   * DSAProblem findMany
   */
  export type DSAProblemFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSAProblem
     */
    select?: DSAProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSAProblemInclude<ExtArgs> | null
    /**
     * Filter, which DSAProblems to fetch.
     */
    where?: DSAProblemWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSAProblems to fetch.
     */
    orderBy?: DSAProblemOrderByWithRelationInput | DSAProblemOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DSAProblems.
     */
    cursor?: DSAProblemWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSAProblems from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSAProblems.
     */
    skip?: number
    distinct?: DSAProblemScalarFieldEnum | DSAProblemScalarFieldEnum[]
  }

  /**
   * DSAProblem create
   */
  export type DSAProblemCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSAProblem
     */
    select?: DSAProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSAProblemInclude<ExtArgs> | null
    /**
     * The data needed to create a DSAProblem.
     */
    data: XOR<DSAProblemCreateInput, DSAProblemUncheckedCreateInput>
  }

  /**
   * DSAProblem createMany
   */
  export type DSAProblemCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DSAProblems.
     */
    data: DSAProblemCreateManyInput | DSAProblemCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DSAProblem update
   */
  export type DSAProblemUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSAProblem
     */
    select?: DSAProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSAProblemInclude<ExtArgs> | null
    /**
     * The data needed to update a DSAProblem.
     */
    data: XOR<DSAProblemUpdateInput, DSAProblemUncheckedUpdateInput>
    /**
     * Choose, which DSAProblem to update.
     */
    where: DSAProblemWhereUniqueInput
  }

  /**
   * DSAProblem updateMany
   */
  export type DSAProblemUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DSAProblems.
     */
    data: XOR<DSAProblemUpdateManyMutationInput, DSAProblemUncheckedUpdateManyInput>
    /**
     * Filter which DSAProblems to update
     */
    where?: DSAProblemWhereInput
  }

  /**
   * DSAProblem upsert
   */
  export type DSAProblemUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSAProblem
     */
    select?: DSAProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSAProblemInclude<ExtArgs> | null
    /**
     * The filter to search for the DSAProblem to update in case it exists.
     */
    where: DSAProblemWhereUniqueInput
    /**
     * In case the DSAProblem found by the `where` argument doesn't exist, create a new DSAProblem with this data.
     */
    create: XOR<DSAProblemCreateInput, DSAProblemUncheckedCreateInput>
    /**
     * In case the DSAProblem was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DSAProblemUpdateInput, DSAProblemUncheckedUpdateInput>
  }

  /**
   * DSAProblem delete
   */
  export type DSAProblemDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSAProblem
     */
    select?: DSAProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSAProblemInclude<ExtArgs> | null
    /**
     * Filter which DSAProblem to delete.
     */
    where: DSAProblemWhereUniqueInput
  }

  /**
   * DSAProblem deleteMany
   */
  export type DSAProblemDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DSAProblems to delete
     */
    where?: DSAProblemWhereInput
  }

  /**
   * DSAProblem.solutions
   */
  export type DSAProblem$solutionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASolution
     */
    select?: DSASolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASolutionInclude<ExtArgs> | null
    where?: DSASolutionWhereInput
    orderBy?: DSASolutionOrderByWithRelationInput | DSASolutionOrderByWithRelationInput[]
    cursor?: DSASolutionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DSASolutionScalarFieldEnum | DSASolutionScalarFieldEnum[]
  }

  /**
   * DSAProblem without action
   */
  export type DSAProblemDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSAProblem
     */
    select?: DSAProblemSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSAProblemInclude<ExtArgs> | null
  }


  /**
   * Model DSASolution
   */

  export type AggregateDSASolution = {
    _count: DSASolutionCountAggregateOutputType | null
    _min: DSASolutionMinAggregateOutputType | null
    _max: DSASolutionMaxAggregateOutputType | null
  }

  export type DSASolutionMinAggregateOutputType = {
    id: string | null
    language: string | null
    code: string | null
    problemId: string | null
  }

  export type DSASolutionMaxAggregateOutputType = {
    id: string | null
    language: string | null
    code: string | null
    problemId: string | null
  }

  export type DSASolutionCountAggregateOutputType = {
    id: number
    language: number
    code: number
    problemId: number
    _all: number
  }


  export type DSASolutionMinAggregateInputType = {
    id?: true
    language?: true
    code?: true
    problemId?: true
  }

  export type DSASolutionMaxAggregateInputType = {
    id?: true
    language?: true
    code?: true
    problemId?: true
  }

  export type DSASolutionCountAggregateInputType = {
    id?: true
    language?: true
    code?: true
    problemId?: true
    _all?: true
  }

  export type DSASolutionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DSASolution to aggregate.
     */
    where?: DSASolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSASolutions to fetch.
     */
    orderBy?: DSASolutionOrderByWithRelationInput | DSASolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DSASolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSASolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSASolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned DSASolutions
    **/
    _count?: true | DSASolutionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DSASolutionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DSASolutionMaxAggregateInputType
  }

  export type GetDSASolutionAggregateType<T extends DSASolutionAggregateArgs> = {
        [P in keyof T & keyof AggregateDSASolution]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDSASolution[P]>
      : GetScalarType<T[P], AggregateDSASolution[P]>
  }




  export type DSASolutionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DSASolutionWhereInput
    orderBy?: DSASolutionOrderByWithAggregationInput | DSASolutionOrderByWithAggregationInput[]
    by: DSASolutionScalarFieldEnum[] | DSASolutionScalarFieldEnum
    having?: DSASolutionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DSASolutionCountAggregateInputType | true
    _min?: DSASolutionMinAggregateInputType
    _max?: DSASolutionMaxAggregateInputType
  }

  export type DSASolutionGroupByOutputType = {
    id: string
    language: string
    code: string
    problemId: string
    _count: DSASolutionCountAggregateOutputType | null
    _min: DSASolutionMinAggregateOutputType | null
    _max: DSASolutionMaxAggregateOutputType | null
  }

  type GetDSASolutionGroupByPayload<T extends DSASolutionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DSASolutionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DSASolutionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DSASolutionGroupByOutputType[P]>
            : GetScalarType<T[P], DSASolutionGroupByOutputType[P]>
        }
      >
    >


  export type DSASolutionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    language?: boolean
    code?: boolean
    problemId?: boolean
    problem?: boolean | DSAProblemDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["dSASolution"]>


  export type DSASolutionSelectScalar = {
    id?: boolean
    language?: boolean
    code?: boolean
    problemId?: boolean
  }

  export type DSASolutionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    problem?: boolean | DSAProblemDefaultArgs<ExtArgs>
  }

  export type $DSASolutionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "DSASolution"
    objects: {
      problem: Prisma.$DSAProblemPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      language: string
      code: string
      problemId: string
    }, ExtArgs["result"]["dSASolution"]>
    composites: {}
  }

  type DSASolutionGetPayload<S extends boolean | null | undefined | DSASolutionDefaultArgs> = $Result.GetResult<Prisma.$DSASolutionPayload, S>

  type DSASolutionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DSASolutionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DSASolutionCountAggregateInputType | true
    }

  export interface DSASolutionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['DSASolution'], meta: { name: 'DSASolution' } }
    /**
     * Find zero or one DSASolution that matches the filter.
     * @param {DSASolutionFindUniqueArgs} args - Arguments to find a DSASolution
     * @example
     * // Get one DSASolution
     * const dSASolution = await prisma.dSASolution.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DSASolutionFindUniqueArgs>(args: SelectSubset<T, DSASolutionFindUniqueArgs<ExtArgs>>): Prisma__DSASolutionClient<$Result.GetResult<Prisma.$DSASolutionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one DSASolution that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DSASolutionFindUniqueOrThrowArgs} args - Arguments to find a DSASolution
     * @example
     * // Get one DSASolution
     * const dSASolution = await prisma.dSASolution.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DSASolutionFindUniqueOrThrowArgs>(args: SelectSubset<T, DSASolutionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DSASolutionClient<$Result.GetResult<Prisma.$DSASolutionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first DSASolution that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASolutionFindFirstArgs} args - Arguments to find a DSASolution
     * @example
     * // Get one DSASolution
     * const dSASolution = await prisma.dSASolution.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DSASolutionFindFirstArgs>(args?: SelectSubset<T, DSASolutionFindFirstArgs<ExtArgs>>): Prisma__DSASolutionClient<$Result.GetResult<Prisma.$DSASolutionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first DSASolution that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASolutionFindFirstOrThrowArgs} args - Arguments to find a DSASolution
     * @example
     * // Get one DSASolution
     * const dSASolution = await prisma.dSASolution.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DSASolutionFindFirstOrThrowArgs>(args?: SelectSubset<T, DSASolutionFindFirstOrThrowArgs<ExtArgs>>): Prisma__DSASolutionClient<$Result.GetResult<Prisma.$DSASolutionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more DSASolutions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASolutionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all DSASolutions
     * const dSASolutions = await prisma.dSASolution.findMany()
     * 
     * // Get first 10 DSASolutions
     * const dSASolutions = await prisma.dSASolution.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const dSASolutionWithIdOnly = await prisma.dSASolution.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DSASolutionFindManyArgs>(args?: SelectSubset<T, DSASolutionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DSASolutionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a DSASolution.
     * @param {DSASolutionCreateArgs} args - Arguments to create a DSASolution.
     * @example
     * // Create one DSASolution
     * const DSASolution = await prisma.dSASolution.create({
     *   data: {
     *     // ... data to create a DSASolution
     *   }
     * })
     * 
     */
    create<T extends DSASolutionCreateArgs>(args: SelectSubset<T, DSASolutionCreateArgs<ExtArgs>>): Prisma__DSASolutionClient<$Result.GetResult<Prisma.$DSASolutionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many DSASolutions.
     * @param {DSASolutionCreateManyArgs} args - Arguments to create many DSASolutions.
     * @example
     * // Create many DSASolutions
     * const dSASolution = await prisma.dSASolution.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DSASolutionCreateManyArgs>(args?: SelectSubset<T, DSASolutionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a DSASolution.
     * @param {DSASolutionDeleteArgs} args - Arguments to delete one DSASolution.
     * @example
     * // Delete one DSASolution
     * const DSASolution = await prisma.dSASolution.delete({
     *   where: {
     *     // ... filter to delete one DSASolution
     *   }
     * })
     * 
     */
    delete<T extends DSASolutionDeleteArgs>(args: SelectSubset<T, DSASolutionDeleteArgs<ExtArgs>>): Prisma__DSASolutionClient<$Result.GetResult<Prisma.$DSASolutionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one DSASolution.
     * @param {DSASolutionUpdateArgs} args - Arguments to update one DSASolution.
     * @example
     * // Update one DSASolution
     * const dSASolution = await prisma.dSASolution.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DSASolutionUpdateArgs>(args: SelectSubset<T, DSASolutionUpdateArgs<ExtArgs>>): Prisma__DSASolutionClient<$Result.GetResult<Prisma.$DSASolutionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more DSASolutions.
     * @param {DSASolutionDeleteManyArgs} args - Arguments to filter DSASolutions to delete.
     * @example
     * // Delete a few DSASolutions
     * const { count } = await prisma.dSASolution.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DSASolutionDeleteManyArgs>(args?: SelectSubset<T, DSASolutionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more DSASolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASolutionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many DSASolutions
     * const dSASolution = await prisma.dSASolution.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DSASolutionUpdateManyArgs>(args: SelectSubset<T, DSASolutionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one DSASolution.
     * @param {DSASolutionUpsertArgs} args - Arguments to update or create a DSASolution.
     * @example
     * // Update or create a DSASolution
     * const dSASolution = await prisma.dSASolution.upsert({
     *   create: {
     *     // ... data to create a DSASolution
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the DSASolution we want to update
     *   }
     * })
     */
    upsert<T extends DSASolutionUpsertArgs>(args: SelectSubset<T, DSASolutionUpsertArgs<ExtArgs>>): Prisma__DSASolutionClient<$Result.GetResult<Prisma.$DSASolutionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of DSASolutions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASolutionCountArgs} args - Arguments to filter DSASolutions to count.
     * @example
     * // Count the number of DSASolutions
     * const count = await prisma.dSASolution.count({
     *   where: {
     *     // ... the filter for the DSASolutions we want to count
     *   }
     * })
    **/
    count<T extends DSASolutionCountArgs>(
      args?: Subset<T, DSASolutionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DSASolutionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a DSASolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASolutionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DSASolutionAggregateArgs>(args: Subset<T, DSASolutionAggregateArgs>): Prisma.PrismaPromise<GetDSASolutionAggregateType<T>>

    /**
     * Group by DSASolution.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DSASolutionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DSASolutionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DSASolutionGroupByArgs['orderBy'] }
        : { orderBy?: DSASolutionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DSASolutionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDSASolutionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the DSASolution model
   */
  readonly fields: DSASolutionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for DSASolution.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DSASolutionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    problem<T extends DSAProblemDefaultArgs<ExtArgs> = {}>(args?: Subset<T, DSAProblemDefaultArgs<ExtArgs>>): Prisma__DSAProblemClient<$Result.GetResult<Prisma.$DSAProblemPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the DSASolution model
   */ 
  interface DSASolutionFieldRefs {
    readonly id: FieldRef<"DSASolution", 'String'>
    readonly language: FieldRef<"DSASolution", 'String'>
    readonly code: FieldRef<"DSASolution", 'String'>
    readonly problemId: FieldRef<"DSASolution", 'String'>
  }
    

  // Custom InputTypes
  /**
   * DSASolution findUnique
   */
  export type DSASolutionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASolution
     */
    select?: DSASolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASolutionInclude<ExtArgs> | null
    /**
     * Filter, which DSASolution to fetch.
     */
    where: DSASolutionWhereUniqueInput
  }

  /**
   * DSASolution findUniqueOrThrow
   */
  export type DSASolutionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASolution
     */
    select?: DSASolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASolutionInclude<ExtArgs> | null
    /**
     * Filter, which DSASolution to fetch.
     */
    where: DSASolutionWhereUniqueInput
  }

  /**
   * DSASolution findFirst
   */
  export type DSASolutionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASolution
     */
    select?: DSASolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASolutionInclude<ExtArgs> | null
    /**
     * Filter, which DSASolution to fetch.
     */
    where?: DSASolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSASolutions to fetch.
     */
    orderBy?: DSASolutionOrderByWithRelationInput | DSASolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DSASolutions.
     */
    cursor?: DSASolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSASolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSASolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DSASolutions.
     */
    distinct?: DSASolutionScalarFieldEnum | DSASolutionScalarFieldEnum[]
  }

  /**
   * DSASolution findFirstOrThrow
   */
  export type DSASolutionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASolution
     */
    select?: DSASolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASolutionInclude<ExtArgs> | null
    /**
     * Filter, which DSASolution to fetch.
     */
    where?: DSASolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSASolutions to fetch.
     */
    orderBy?: DSASolutionOrderByWithRelationInput | DSASolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for DSASolutions.
     */
    cursor?: DSASolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSASolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSASolutions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of DSASolutions.
     */
    distinct?: DSASolutionScalarFieldEnum | DSASolutionScalarFieldEnum[]
  }

  /**
   * DSASolution findMany
   */
  export type DSASolutionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASolution
     */
    select?: DSASolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASolutionInclude<ExtArgs> | null
    /**
     * Filter, which DSASolutions to fetch.
     */
    where?: DSASolutionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of DSASolutions to fetch.
     */
    orderBy?: DSASolutionOrderByWithRelationInput | DSASolutionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing DSASolutions.
     */
    cursor?: DSASolutionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` DSASolutions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` DSASolutions.
     */
    skip?: number
    distinct?: DSASolutionScalarFieldEnum | DSASolutionScalarFieldEnum[]
  }

  /**
   * DSASolution create
   */
  export type DSASolutionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASolution
     */
    select?: DSASolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASolutionInclude<ExtArgs> | null
    /**
     * The data needed to create a DSASolution.
     */
    data: XOR<DSASolutionCreateInput, DSASolutionUncheckedCreateInput>
  }

  /**
   * DSASolution createMany
   */
  export type DSASolutionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many DSASolutions.
     */
    data: DSASolutionCreateManyInput | DSASolutionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * DSASolution update
   */
  export type DSASolutionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASolution
     */
    select?: DSASolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASolutionInclude<ExtArgs> | null
    /**
     * The data needed to update a DSASolution.
     */
    data: XOR<DSASolutionUpdateInput, DSASolutionUncheckedUpdateInput>
    /**
     * Choose, which DSASolution to update.
     */
    where: DSASolutionWhereUniqueInput
  }

  /**
   * DSASolution updateMany
   */
  export type DSASolutionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update DSASolutions.
     */
    data: XOR<DSASolutionUpdateManyMutationInput, DSASolutionUncheckedUpdateManyInput>
    /**
     * Filter which DSASolutions to update
     */
    where?: DSASolutionWhereInput
  }

  /**
   * DSASolution upsert
   */
  export type DSASolutionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASolution
     */
    select?: DSASolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASolutionInclude<ExtArgs> | null
    /**
     * The filter to search for the DSASolution to update in case it exists.
     */
    where: DSASolutionWhereUniqueInput
    /**
     * In case the DSASolution found by the `where` argument doesn't exist, create a new DSASolution with this data.
     */
    create: XOR<DSASolutionCreateInput, DSASolutionUncheckedCreateInput>
    /**
     * In case the DSASolution was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DSASolutionUpdateInput, DSASolutionUncheckedUpdateInput>
  }

  /**
   * DSASolution delete
   */
  export type DSASolutionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASolution
     */
    select?: DSASolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASolutionInclude<ExtArgs> | null
    /**
     * Filter which DSASolution to delete.
     */
    where: DSASolutionWhereUniqueInput
  }

  /**
   * DSASolution deleteMany
   */
  export type DSASolutionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which DSASolutions to delete
     */
    where?: DSASolutionWhereInput
  }

  /**
   * DSASolution without action
   */
  export type DSASolutionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DSASolution
     */
    select?: DSASolutionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DSASolutionInclude<ExtArgs> | null
  }


  /**
   * Model Certificate
   */

  export type AggregateCertificate = {
    _count: CertificateCountAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  export type CertificateMinAggregateOutputType = {
    id: string | null
    certificateId: string | null
    eventId: string | null
    userId: string | null
    teamId: string | null
    participantName: string | null
    position: string | null
    issuedAt: Date | null
  }

  export type CertificateMaxAggregateOutputType = {
    id: string | null
    certificateId: string | null
    eventId: string | null
    userId: string | null
    teamId: string | null
    participantName: string | null
    position: string | null
    issuedAt: Date | null
  }

  export type CertificateCountAggregateOutputType = {
    id: number
    certificateId: number
    eventId: number
    userId: number
    teamId: number
    participantName: number
    position: number
    issuedAt: number
    _all: number
  }


  export type CertificateMinAggregateInputType = {
    id?: true
    certificateId?: true
    eventId?: true
    userId?: true
    teamId?: true
    participantName?: true
    position?: true
    issuedAt?: true
  }

  export type CertificateMaxAggregateInputType = {
    id?: true
    certificateId?: true
    eventId?: true
    userId?: true
    teamId?: true
    participantName?: true
    position?: true
    issuedAt?: true
  }

  export type CertificateCountAggregateInputType = {
    id?: true
    certificateId?: true
    eventId?: true
    userId?: true
    teamId?: true
    participantName?: true
    position?: true
    issuedAt?: true
    _all?: true
  }

  export type CertificateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificate to aggregate.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Certificates
    **/
    _count?: true | CertificateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CertificateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CertificateMaxAggregateInputType
  }

  export type GetCertificateAggregateType<T extends CertificateAggregateArgs> = {
        [P in keyof T & keyof AggregateCertificate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCertificate[P]>
      : GetScalarType<T[P], AggregateCertificate[P]>
  }




  export type CertificateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: CertificateWhereInput
    orderBy?: CertificateOrderByWithAggregationInput | CertificateOrderByWithAggregationInput[]
    by: CertificateScalarFieldEnum[] | CertificateScalarFieldEnum
    having?: CertificateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CertificateCountAggregateInputType | true
    _min?: CertificateMinAggregateInputType
    _max?: CertificateMaxAggregateInputType
  }

  export type CertificateGroupByOutputType = {
    id: string
    certificateId: string
    eventId: string
    userId: string
    teamId: string | null
    participantName: string
    position: string | null
    issuedAt: Date
    _count: CertificateCountAggregateOutputType | null
    _min: CertificateMinAggregateOutputType | null
    _max: CertificateMaxAggregateOutputType | null
  }

  type GetCertificateGroupByPayload<T extends CertificateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CertificateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CertificateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CertificateGroupByOutputType[P]>
            : GetScalarType<T[P], CertificateGroupByOutputType[P]>
        }
      >
    >


  export type CertificateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    certificateId?: boolean
    eventId?: boolean
    userId?: boolean
    teamId?: boolean
    participantName?: boolean
    position?: boolean
    issuedAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | Certificate$teamArgs<ExtArgs>
  }, ExtArgs["result"]["certificate"]>


  export type CertificateSelectScalar = {
    id?: boolean
    certificateId?: boolean
    eventId?: boolean
    userId?: boolean
    teamId?: boolean
    participantName?: boolean
    position?: boolean
    issuedAt?: boolean
  }

  export type CertificateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    user?: boolean | UserDefaultArgs<ExtArgs>
    team?: boolean | Certificate$teamArgs<ExtArgs>
  }

  export type $CertificatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Certificate"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      user: Prisma.$UserPayload<ExtArgs>
      team: Prisma.$TeamPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      certificateId: string
      eventId: string
      userId: string
      teamId: string | null
      participantName: string
      position: string | null
      issuedAt: Date
    }, ExtArgs["result"]["certificate"]>
    composites: {}
  }

  type CertificateGetPayload<S extends boolean | null | undefined | CertificateDefaultArgs> = $Result.GetResult<Prisma.$CertificatePayload, S>

  type CertificateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<CertificateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: CertificateCountAggregateInputType | true
    }

  export interface CertificateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Certificate'], meta: { name: 'Certificate' } }
    /**
     * Find zero or one Certificate that matches the filter.
     * @param {CertificateFindUniqueArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends CertificateFindUniqueArgs>(args: SelectSubset<T, CertificateFindUniqueArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Certificate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {CertificateFindUniqueOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends CertificateFindUniqueOrThrowArgs>(args: SelectSubset<T, CertificateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Certificate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends CertificateFindFirstArgs>(args?: SelectSubset<T, CertificateFindFirstArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Certificate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindFirstOrThrowArgs} args - Arguments to find a Certificate
     * @example
     * // Get one Certificate
     * const certificate = await prisma.certificate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends CertificateFindFirstOrThrowArgs>(args?: SelectSubset<T, CertificateFindFirstOrThrowArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Certificates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Certificates
     * const certificates = await prisma.certificate.findMany()
     * 
     * // Get first 10 Certificates
     * const certificates = await prisma.certificate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const certificateWithIdOnly = await prisma.certificate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends CertificateFindManyArgs>(args?: SelectSubset<T, CertificateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Certificate.
     * @param {CertificateCreateArgs} args - Arguments to create a Certificate.
     * @example
     * // Create one Certificate
     * const Certificate = await prisma.certificate.create({
     *   data: {
     *     // ... data to create a Certificate
     *   }
     * })
     * 
     */
    create<T extends CertificateCreateArgs>(args: SelectSubset<T, CertificateCreateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Certificates.
     * @param {CertificateCreateManyArgs} args - Arguments to create many Certificates.
     * @example
     * // Create many Certificates
     * const certificate = await prisma.certificate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends CertificateCreateManyArgs>(args?: SelectSubset<T, CertificateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Certificate.
     * @param {CertificateDeleteArgs} args - Arguments to delete one Certificate.
     * @example
     * // Delete one Certificate
     * const Certificate = await prisma.certificate.delete({
     *   where: {
     *     // ... filter to delete one Certificate
     *   }
     * })
     * 
     */
    delete<T extends CertificateDeleteArgs>(args: SelectSubset<T, CertificateDeleteArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Certificate.
     * @param {CertificateUpdateArgs} args - Arguments to update one Certificate.
     * @example
     * // Update one Certificate
     * const certificate = await prisma.certificate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends CertificateUpdateArgs>(args: SelectSubset<T, CertificateUpdateArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Certificates.
     * @param {CertificateDeleteManyArgs} args - Arguments to filter Certificates to delete.
     * @example
     * // Delete a few Certificates
     * const { count } = await prisma.certificate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends CertificateDeleteManyArgs>(args?: SelectSubset<T, CertificateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Certificates
     * const certificate = await prisma.certificate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends CertificateUpdateManyArgs>(args: SelectSubset<T, CertificateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Certificate.
     * @param {CertificateUpsertArgs} args - Arguments to update or create a Certificate.
     * @example
     * // Update or create a Certificate
     * const certificate = await prisma.certificate.upsert({
     *   create: {
     *     // ... data to create a Certificate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Certificate we want to update
     *   }
     * })
     */
    upsert<T extends CertificateUpsertArgs>(args: SelectSubset<T, CertificateUpsertArgs<ExtArgs>>): Prisma__CertificateClient<$Result.GetResult<Prisma.$CertificatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Certificates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateCountArgs} args - Arguments to filter Certificates to count.
     * @example
     * // Count the number of Certificates
     * const count = await prisma.certificate.count({
     *   where: {
     *     // ... the filter for the Certificates we want to count
     *   }
     * })
    **/
    count<T extends CertificateCountArgs>(
      args?: Subset<T, CertificateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CertificateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CertificateAggregateArgs>(args: Subset<T, CertificateAggregateArgs>): Prisma.PrismaPromise<GetCertificateAggregateType<T>>

    /**
     * Group by Certificate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CertificateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends CertificateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: CertificateGroupByArgs['orderBy'] }
        : { orderBy?: CertificateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, CertificateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCertificateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Certificate model
   */
  readonly fields: CertificateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Certificate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__CertificateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    user<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    team<T extends Certificate$teamArgs<ExtArgs> = {}>(args?: Subset<T, Certificate$teamArgs<ExtArgs>>): Prisma__TeamClient<$Result.GetResult<Prisma.$TeamPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Certificate model
   */ 
  interface CertificateFieldRefs {
    readonly id: FieldRef<"Certificate", 'String'>
    readonly certificateId: FieldRef<"Certificate", 'String'>
    readonly eventId: FieldRef<"Certificate", 'String'>
    readonly userId: FieldRef<"Certificate", 'String'>
    readonly teamId: FieldRef<"Certificate", 'String'>
    readonly participantName: FieldRef<"Certificate", 'String'>
    readonly position: FieldRef<"Certificate", 'String'>
    readonly issuedAt: FieldRef<"Certificate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Certificate findUnique
   */
  export type CertificateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findUniqueOrThrow
   */
  export type CertificateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate findFirst
   */
  export type CertificateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findFirstOrThrow
   */
  export type CertificateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificate to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Certificates.
     */
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate findMany
   */
  export type CertificateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter, which Certificates to fetch.
     */
    where?: CertificateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Certificates to fetch.
     */
    orderBy?: CertificateOrderByWithRelationInput | CertificateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Certificates.
     */
    cursor?: CertificateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Certificates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Certificates.
     */
    skip?: number
    distinct?: CertificateScalarFieldEnum | CertificateScalarFieldEnum[]
  }

  /**
   * Certificate create
   */
  export type CertificateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to create a Certificate.
     */
    data: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
  }

  /**
   * Certificate createMany
   */
  export type CertificateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Certificates.
     */
    data: CertificateCreateManyInput | CertificateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Certificate update
   */
  export type CertificateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The data needed to update a Certificate.
     */
    data: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
    /**
     * Choose, which Certificate to update.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate updateMany
   */
  export type CertificateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Certificates.
     */
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyInput>
    /**
     * Filter which Certificates to update
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate upsert
   */
  export type CertificateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * The filter to search for the Certificate to update in case it exists.
     */
    where: CertificateWhereUniqueInput
    /**
     * In case the Certificate found by the `where` argument doesn't exist, create a new Certificate with this data.
     */
    create: XOR<CertificateCreateInput, CertificateUncheckedCreateInput>
    /**
     * In case the Certificate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<CertificateUpdateInput, CertificateUncheckedUpdateInput>
  }

  /**
   * Certificate delete
   */
  export type CertificateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
    /**
     * Filter which Certificate to delete.
     */
    where: CertificateWhereUniqueInput
  }

  /**
   * Certificate deleteMany
   */
  export type CertificateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Certificates to delete
     */
    where?: CertificateWhereInput
  }

  /**
   * Certificate.team
   */
  export type Certificate$teamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Team
     */
    select?: TeamSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TeamInclude<ExtArgs> | null
    where?: TeamWhereInput
  }

  /**
   * Certificate without action
   */
  export type CertificateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Certificate
     */
    select?: CertificateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: CertificateInclude<ExtArgs> | null
  }


  /**
   * Model EmailLog
   */

  export type AggregateEmailLog = {
    _count: EmailLogCountAggregateOutputType | null
    _avg: EmailLogAvgAggregateOutputType | null
    _sum: EmailLogSumAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  export type EmailLogAvgAggregateOutputType = {
    recipientCount: number | null
  }

  export type EmailLogSumAggregateOutputType = {
    recipientCount: number | null
  }

  export type EmailLogMinAggregateOutputType = {
    id: string | null
    eventId: string | null
    subject: string | null
    message: string | null
    recipientCount: number | null
    sentBy: string | null
    sentAt: Date | null
  }

  export type EmailLogMaxAggregateOutputType = {
    id: string | null
    eventId: string | null
    subject: string | null
    message: string | null
    recipientCount: number | null
    sentBy: string | null
    sentAt: Date | null
  }

  export type EmailLogCountAggregateOutputType = {
    id: number
    eventId: number
    subject: number
    message: number
    recipientCount: number
    sentBy: number
    sentAt: number
    _all: number
  }


  export type EmailLogAvgAggregateInputType = {
    recipientCount?: true
  }

  export type EmailLogSumAggregateInputType = {
    recipientCount?: true
  }

  export type EmailLogMinAggregateInputType = {
    id?: true
    eventId?: true
    subject?: true
    message?: true
    recipientCount?: true
    sentBy?: true
    sentAt?: true
  }

  export type EmailLogMaxAggregateInputType = {
    id?: true
    eventId?: true
    subject?: true
    message?: true
    recipientCount?: true
    sentBy?: true
    sentAt?: true
  }

  export type EmailLogCountAggregateInputType = {
    id?: true
    eventId?: true
    subject?: true
    message?: true
    recipientCount?: true
    sentBy?: true
    sentAt?: true
    _all?: true
  }

  export type EmailLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLog to aggregate.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmailLogs
    **/
    _count?: true | EmailLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmailLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmailLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmailLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmailLogMaxAggregateInputType
  }

  export type GetEmailLogAggregateType<T extends EmailLogAggregateArgs> = {
        [P in keyof T & keyof AggregateEmailLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmailLog[P]>
      : GetScalarType<T[P], AggregateEmailLog[P]>
  }




  export type EmailLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmailLogWhereInput
    orderBy?: EmailLogOrderByWithAggregationInput | EmailLogOrderByWithAggregationInput[]
    by: EmailLogScalarFieldEnum[] | EmailLogScalarFieldEnum
    having?: EmailLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmailLogCountAggregateInputType | true
    _avg?: EmailLogAvgAggregateInputType
    _sum?: EmailLogSumAggregateInputType
    _min?: EmailLogMinAggregateInputType
    _max?: EmailLogMaxAggregateInputType
  }

  export type EmailLogGroupByOutputType = {
    id: string
    eventId: string
    subject: string
    message: string
    recipientCount: number
    sentBy: string
    sentAt: Date
    _count: EmailLogCountAggregateOutputType | null
    _avg: EmailLogAvgAggregateOutputType | null
    _sum: EmailLogSumAggregateOutputType | null
    _min: EmailLogMinAggregateOutputType | null
    _max: EmailLogMaxAggregateOutputType | null
  }

  type GetEmailLogGroupByPayload<T extends EmailLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmailLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmailLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
            : GetScalarType<T[P], EmailLogGroupByOutputType[P]>
        }
      >
    >


  export type EmailLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    eventId?: boolean
    subject?: boolean
    message?: boolean
    recipientCount?: boolean
    sentBy?: boolean
    sentAt?: boolean
    event?: boolean | EventDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["emailLog"]>


  export type EmailLogSelectScalar = {
    id?: boolean
    eventId?: boolean
    subject?: boolean
    message?: boolean
    recipientCount?: boolean
    sentBy?: boolean
    sentAt?: boolean
  }

  export type EmailLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    event?: boolean | EventDefaultArgs<ExtArgs>
    sender?: boolean | UserDefaultArgs<ExtArgs>
  }

  export type $EmailLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmailLog"
    objects: {
      event: Prisma.$EventPayload<ExtArgs>
      sender: Prisma.$UserPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      eventId: string
      subject: string
      message: string
      recipientCount: number
      sentBy: string
      sentAt: Date
    }, ExtArgs["result"]["emailLog"]>
    composites: {}
  }

  type EmailLogGetPayload<S extends boolean | null | undefined | EmailLogDefaultArgs> = $Result.GetResult<Prisma.$EmailLogPayload, S>

  type EmailLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmailLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmailLogCountAggregateInputType | true
    }

  export interface EmailLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmailLog'], meta: { name: 'EmailLog' } }
    /**
     * Find zero or one EmailLog that matches the filter.
     * @param {EmailLogFindUniqueArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmailLogFindUniqueArgs>(args: SelectSubset<T, EmailLogFindUniqueArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmailLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmailLogFindUniqueOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmailLogFindUniqueOrThrowArgs>(args: SelectSubset<T, EmailLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmailLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmailLogFindFirstArgs>(args?: SelectSubset<T, EmailLogFindFirstArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmailLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindFirstOrThrowArgs} args - Arguments to find a EmailLog
     * @example
     * // Get one EmailLog
     * const emailLog = await prisma.emailLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmailLogFindFirstOrThrowArgs>(args?: SelectSubset<T, EmailLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmailLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmailLogs
     * const emailLogs = await prisma.emailLog.findMany()
     * 
     * // Get first 10 EmailLogs
     * const emailLogs = await prisma.emailLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const emailLogWithIdOnly = await prisma.emailLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmailLogFindManyArgs>(args?: SelectSubset<T, EmailLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmailLog.
     * @param {EmailLogCreateArgs} args - Arguments to create a EmailLog.
     * @example
     * // Create one EmailLog
     * const EmailLog = await prisma.emailLog.create({
     *   data: {
     *     // ... data to create a EmailLog
     *   }
     * })
     * 
     */
    create<T extends EmailLogCreateArgs>(args: SelectSubset<T, EmailLogCreateArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmailLogs.
     * @param {EmailLogCreateManyArgs} args - Arguments to create many EmailLogs.
     * @example
     * // Create many EmailLogs
     * const emailLog = await prisma.emailLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmailLogCreateManyArgs>(args?: SelectSubset<T, EmailLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a EmailLog.
     * @param {EmailLogDeleteArgs} args - Arguments to delete one EmailLog.
     * @example
     * // Delete one EmailLog
     * const EmailLog = await prisma.emailLog.delete({
     *   where: {
     *     // ... filter to delete one EmailLog
     *   }
     * })
     * 
     */
    delete<T extends EmailLogDeleteArgs>(args: SelectSubset<T, EmailLogDeleteArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmailLog.
     * @param {EmailLogUpdateArgs} args - Arguments to update one EmailLog.
     * @example
     * // Update one EmailLog
     * const emailLog = await prisma.emailLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmailLogUpdateArgs>(args: SelectSubset<T, EmailLogUpdateArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmailLogs.
     * @param {EmailLogDeleteManyArgs} args - Arguments to filter EmailLogs to delete.
     * @example
     * // Delete a few EmailLogs
     * const { count } = await prisma.emailLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmailLogDeleteManyArgs>(args?: SelectSubset<T, EmailLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmailLogs
     * const emailLog = await prisma.emailLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmailLogUpdateManyArgs>(args: SelectSubset<T, EmailLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmailLog.
     * @param {EmailLogUpsertArgs} args - Arguments to update or create a EmailLog.
     * @example
     * // Update or create a EmailLog
     * const emailLog = await prisma.emailLog.upsert({
     *   create: {
     *     // ... data to create a EmailLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmailLog we want to update
     *   }
     * })
     */
    upsert<T extends EmailLogUpsertArgs>(args: SelectSubset<T, EmailLogUpsertArgs<ExtArgs>>): Prisma__EmailLogClient<$Result.GetResult<Prisma.$EmailLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmailLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogCountArgs} args - Arguments to filter EmailLogs to count.
     * @example
     * // Count the number of EmailLogs
     * const count = await prisma.emailLog.count({
     *   where: {
     *     // ... the filter for the EmailLogs we want to count
     *   }
     * })
    **/
    count<T extends EmailLogCountArgs>(
      args?: Subset<T, EmailLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmailLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmailLogAggregateArgs>(args: Subset<T, EmailLogAggregateArgs>): Prisma.PrismaPromise<GetEmailLogAggregateType<T>>

    /**
     * Group by EmailLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmailLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmailLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmailLogGroupByArgs['orderBy'] }
        : { orderBy?: EmailLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmailLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmailLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmailLog model
   */
  readonly fields: EmailLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmailLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmailLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    event<T extends EventDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EventDefaultArgs<ExtArgs>>): Prisma__EventClient<$Result.GetResult<Prisma.$EventPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    sender<T extends UserDefaultArgs<ExtArgs> = {}>(args?: Subset<T, UserDefaultArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmailLog model
   */ 
  interface EmailLogFieldRefs {
    readonly id: FieldRef<"EmailLog", 'String'>
    readonly eventId: FieldRef<"EmailLog", 'String'>
    readonly subject: FieldRef<"EmailLog", 'String'>
    readonly message: FieldRef<"EmailLog", 'String'>
    readonly recipientCount: FieldRef<"EmailLog", 'Int'>
    readonly sentBy: FieldRef<"EmailLog", 'String'>
    readonly sentAt: FieldRef<"EmailLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmailLog findUnique
   */
  export type EmailLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog findUniqueOrThrow
   */
  export type EmailLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog findFirst
   */
  export type EmailLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog findFirstOrThrow
   */
  export type EmailLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLog to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmailLogs.
     */
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog findMany
   */
  export type EmailLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter, which EmailLogs to fetch.
     */
    where?: EmailLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmailLogs to fetch.
     */
    orderBy?: EmailLogOrderByWithRelationInput | EmailLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmailLogs.
     */
    cursor?: EmailLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmailLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmailLogs.
     */
    skip?: number
    distinct?: EmailLogScalarFieldEnum | EmailLogScalarFieldEnum[]
  }

  /**
   * EmailLog create
   */
  export type EmailLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The data needed to create a EmailLog.
     */
    data: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
  }

  /**
   * EmailLog createMany
   */
  export type EmailLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmailLogs.
     */
    data: EmailLogCreateManyInput | EmailLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmailLog update
   */
  export type EmailLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The data needed to update a EmailLog.
     */
    data: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
    /**
     * Choose, which EmailLog to update.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog updateMany
   */
  export type EmailLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmailLogs.
     */
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyInput>
    /**
     * Filter which EmailLogs to update
     */
    where?: EmailLogWhereInput
  }

  /**
   * EmailLog upsert
   */
  export type EmailLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * The filter to search for the EmailLog to update in case it exists.
     */
    where: EmailLogWhereUniqueInput
    /**
     * In case the EmailLog found by the `where` argument doesn't exist, create a new EmailLog with this data.
     */
    create: XOR<EmailLogCreateInput, EmailLogUncheckedCreateInput>
    /**
     * In case the EmailLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmailLogUpdateInput, EmailLogUncheckedUpdateInput>
  }

  /**
   * EmailLog delete
   */
  export type EmailLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
    /**
     * Filter which EmailLog to delete.
     */
    where: EmailLogWhereUniqueInput
  }

  /**
   * EmailLog deleteMany
   */
  export type EmailLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmailLogs to delete
     */
    where?: EmailLogWhereInput
  }

  /**
   * EmailLog without action
   */
  export type EmailLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmailLog
     */
    select?: EmailLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmailLogInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    fullName: 'fullName',
    whatsapp: 'whatsapp',
    gender: 'gender',
    graduation: 'graduation',
    specialization: 'specialization',
    year: 'year',
    regNumber: 'regNumber',
    skills: 'skills',
    domain: 'domain',
    githubUrl: 'githubUrl',
    codingUrl: 'codingUrl',
    profilePicture: 'profilePicture',
    totalPoints: 'totalPoints',
    currentStreak: 'currentStreak',
    longestStreak: 'longestStreak',
    level: 'level',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    lastActive: 'lastActive'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const EventCategoryScalarFieldEnum: {
    id: 'id',
    name: 'name',
    slug: 'slug',
    description: 'description',
    icon: 'icon',
    color: 'color',
    parentId: 'parentId',
    createdAt: 'createdAt'
  };

  export type EventCategoryScalarFieldEnum = (typeof EventCategoryScalarFieldEnum)[keyof typeof EventCategoryScalarFieldEnum]


  export const EventTypeScalarFieldEnum: {
    id: 'id',
    categoryId: 'categoryId',
    name: 'name',
    slug: 'slug',
    description: 'description',
    defaultDurationHours: 'defaultDurationHours',
    createdAt: 'createdAt'
  };

  export type EventTypeScalarFieldEnum = (typeof EventTypeScalarFieldEnum)[keyof typeof EventTypeScalarFieldEnum]


  export const EventScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    categoryId: 'categoryId',
    eventType: 'eventType',
    mode: 'mode',
    registrationStart: 'registrationStart',
    registrationEnd: 'registrationEnd',
    maxParticipants: 'maxParticipants',
    isTeamEvent: 'isTeamEvent',
    allowIndividual: 'allowIndividual',
    minTeamSize: 'minTeamSize',
    maxTeamSize: 'maxTeamSize',
    teamFormationDeadline: 'teamFormationDeadline',
    restrictSameCollege: 'restrictSameCollege',
    eventStart: 'eventStart',
    eventEnd: 'eventEnd',
    isPaid: 'isPaid',
    registrationFee: 'registrationFee',
    currency: 'currency',
    hasSubmission: 'hasSubmission',
    submissionStart: 'submissionStart',
    submissionDeadline: 'submissionDeadline',
    submissionTemplateUrl: 'submissionTemplateUrl',
    rules: 'rules',
    eligibility: 'eligibility',
    rewards: 'rewards',
    prizes: 'prizes',
    venue: 'venue',
    meetingLink: 'meetingLink',
    resourceLinks: 'resourceLinks',
    bannerImage: 'bannerImage',
    images: 'images',
    status: 'status',
    isFeatured: 'isFeatured',
    hasRoadmap: 'hasRoadmap',
    roadmapId: 'roadmapId',
    hasChallenges: 'hasChallenges',
    problemCount: 'problemCount',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EventScalarFieldEnum = (typeof EventScalarFieldEnum)[keyof typeof EventScalarFieldEnum]


  export const TeamScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    teamName: 'teamName',
    teamLeaderId: 'teamLeaderId',
    isComplete: 'isComplete',
    isLocked: 'isLocked',
    collegeName: 'collegeName',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TeamScalarFieldEnum = (typeof TeamScalarFieldEnum)[keyof typeof TeamScalarFieldEnum]


  export const TeamMemberScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId',
    isLeader: 'isLeader',
    status: 'status',
    joinedAt: 'joinedAt',
    leftAt: 'leftAt'
  };

  export type TeamMemberScalarFieldEnum = (typeof TeamMemberScalarFieldEnum)[keyof typeof TeamMemberScalarFieldEnum]


  export const TeamJoinRequestScalarFieldEnum: {
    id: 'id',
    teamId: 'teamId',
    userId: 'userId',
    requestType: 'requestType',
    status: 'status',
    message: 'message',
    responseMessage: 'responseMessage',
    createdAt: 'createdAt',
    respondedAt: 'respondedAt'
  };

  export type TeamJoinRequestScalarFieldEnum = (typeof TeamJoinRequestScalarFieldEnum)[keyof typeof TeamJoinRequestScalarFieldEnum]


  export const EventRegistrationScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    teamId: 'teamId',
    participationType: 'participationType',
    paymentStatus: 'paymentStatus',
    paymentId: 'paymentId',
    amountPaid: 'amountPaid',
    paidAt: 'paidAt',
    status: 'status',
    registeredAt: 'registeredAt',
    cancelledAt: 'cancelledAt'
  };

  export type EventRegistrationScalarFieldEnum = (typeof EventRegistrationScalarFieldEnum)[keyof typeof EventRegistrationScalarFieldEnum]


  export const EventSubmissionScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    userId: 'userId',
    teamId: 'teamId',
    projectDeckUrl: 'projectDeckUrl',
    presentationPdfUrl: 'presentationPdfUrl',
    mvpLink: 'mvpLink',
    demoVideoUrl: 'demoVideoUrl',
    githubRepoUrl: 'githubRepoUrl',
    technologiesUsed: 'technologiesUsed',
    aiToolsIntegrated: 'aiToolsIntegrated',
    solutionDescription: 'solutionDescription',
    score: 'score',
    rank: 'rank',
    feedback: 'feedback',
    status: 'status',
    submittedAt: 'submittedAt',
    updatedAt: 'updatedAt',
    evaluatedAt: 'evaluatedAt'
  };

  export type EventSubmissionScalarFieldEnum = (typeof EventSubmissionScalarFieldEnum)[keyof typeof EventSubmissionScalarFieldEnum]


  export const ChallengeScalarFieldEnum: {
    id: 'id',
    title: 'title',
    slug: 'slug',
    description: 'description',
    challengeType: 'challengeType',
    difficulty: 'difficulty',
    durationDays: 'durationDays',
    startDate: 'startDate',
    endDate: 'endDate',
    category: 'category',
    tags: 'tags',
    pointsPerDay: 'pointsPerDay',
    bonusPoints: 'bonusPoints',
    badges: 'badges',
    hasLeaderboard: 'hasLeaderboard',
    isPublic: 'isPublic',
    maxParticipants: 'maxParticipants',
    bannerImage: 'bannerImage',
    icon: 'icon',
    status: 'status',
    totalParticipants: 'totalParticipants',
    activeParticipants: 'activeParticipants',
    completionRate: 'completionRate',
    createdBy: 'createdBy',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ChallengeScalarFieldEnum = (typeof ChallengeScalarFieldEnum)[keyof typeof ChallengeScalarFieldEnum]


  export const ChallengeTaskScalarFieldEnum: {
    id: 'id',
    challengeId: 'challengeId',
    dayNumber: 'dayNumber',
    title: 'title',
    description: 'description',
    taskType: 'taskType',
    content: 'content',
    resourceLinks: 'resourceLinks',
    hints: 'hints',
    difficulty: 'difficulty',
    points: 'points',
    autoValidate: 'autoValidate',
    validationUrl: 'validationUrl',
    createdAt: 'createdAt'
  };

  export type ChallengeTaskScalarFieldEnum = (typeof ChallengeTaskScalarFieldEnum)[keyof typeof ChallengeTaskScalarFieldEnum]


  export const UserChallengeProgressScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    challengeId: 'challengeId',
    status: 'status',
    completedDays: 'completedDays',
    totalDays: 'totalDays',
    completionPercentage: 'completionPercentage',
    currentStreak: 'currentStreak',
    longestStreak: 'longestStreak',
    lastCompletedDate: 'lastCompletedDate',
    totalPoints: 'totalPoints',
    bonusPoints: 'bonusPoints',
    currentRank: 'currentRank',
    startedAt: 'startedAt',
    lastActivity: 'lastActivity',
    completedAt: 'completedAt',
    certificateIssued: 'certificateIssued',
    certificateUrl: 'certificateUrl',
    completedTaskIds: 'completedTaskIds',
    skippedTaskIds: 'skippedTaskIds'
  };

  export type UserChallengeProgressScalarFieldEnum = (typeof UserChallengeProgressScalarFieldEnum)[keyof typeof UserChallengeProgressScalarFieldEnum]


  export const UserTaskCompletionScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    challengeId: 'challengeId',
    taskId: 'taskId',
    progressId: 'progressId',
    completedAt: 'completedAt',
    timeTaken: 'timeTaken',
    submissionUrl: 'submissionUrl',
    submissionText: 'submissionText',
    submissionFiles: 'submissionFiles',
    isVerified: 'isVerified',
    verifiedBy: 'verifiedBy',
    verifiedAt: 'verifiedAt',
    score: 'score',
    pointsEarned: 'pointsEarned',
    userNotes: 'userNotes',
    feedback: 'feedback'
  };

  export type UserTaskCompletionScalarFieldEnum = (typeof UserTaskCompletionScalarFieldEnum)[keyof typeof UserTaskCompletionScalarFieldEnum]


  export const UserBadgeScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    badgeType: 'badgeType',
    badgeName: 'badgeName',
    badgeDescription: 'badgeDescription',
    badgeIcon: 'badgeIcon',
    badgeColor: 'badgeColor',
    relatedChallengeId: 'relatedChallengeId',
    relatedEventId: 'relatedEventId',
    pointsAwarded: 'pointsAwarded',
    earnedAt: 'earnedAt'
  };

  export type UserBadgeScalarFieldEnum = (typeof UserBadgeScalarFieldEnum)[keyof typeof UserBadgeScalarFieldEnum]


  export const UserAchievementScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    achievementType: 'achievementType',
    achievementName: 'achievementName',
    description: 'description',
    value: 'value',
    target: 'target',
    rarity: 'rarity',
    earnedAt: 'earnedAt'
  };

  export type UserAchievementScalarFieldEnum = (typeof UserAchievementScalarFieldEnum)[keyof typeof UserAchievementScalarFieldEnum]


  export const LeaderboardScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    leaderboardType: 'leaderboardType',
    relatedId: 'relatedId',
    timePeriod: 'timePeriod',
    score: 'score',
    rank: 'rank',
    previousRank: 'previousRank',
    totalCompletions: 'totalCompletions',
    currentStreak: 'currentStreak',
    updatedAt: 'updatedAt'
  };

  export type LeaderboardScalarFieldEnum = (typeof LeaderboardScalarFieldEnum)[keyof typeof LeaderboardScalarFieldEnum]


  export const EventChallengeScalarFieldEnum: {
    eventId: 'eventId',
    challengeId: 'challengeId'
  };

  export type EventChallengeScalarFieldEnum = (typeof EventChallengeScalarFieldEnum)[keyof typeof EventChallengeScalarFieldEnum]


  export const RoadmapScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    roleTarget: 'roleTarget',
    createdAt: 'createdAt'
  };

  export type RoadmapScalarFieldEnum = (typeof RoadmapScalarFieldEnum)[keyof typeof RoadmapScalarFieldEnum]


  export const RoadmapPhaseScalarFieldEnum: {
    id: 'id',
    roadmapId: 'roadmapId',
    order: 'order',
    title: 'title',
    level: 'level',
    duration: 'duration',
    description: 'description'
  };

  export type RoadmapPhaseScalarFieldEnum = (typeof RoadmapPhaseScalarFieldEnum)[keyof typeof RoadmapPhaseScalarFieldEnum]


  export const PhaseSectionScalarFieldEnum: {
    id: 'id',
    phaseId: 'phaseId',
    title: 'title',
    description: 'description',
    order: 'order'
  };

  export type PhaseSectionScalarFieldEnum = (typeof PhaseSectionScalarFieldEnum)[keyof typeof PhaseSectionScalarFieldEnum]


  export const SectionItemScalarFieldEnum: {
    id: 'id',
    sectionId: 'sectionId',
    title: 'title',
    order: 'order'
  };

  export type SectionItemScalarFieldEnum = (typeof SectionItemScalarFieldEnum)[keyof typeof SectionItemScalarFieldEnum]


  export const SubItemScalarFieldEnum: {
    id: 'id',
    itemId: 'itemId',
    title: 'title',
    videoUrl: 'videoUrl',
    duration: 'duration',
    order: 'order'
  };

  export type SubItemScalarFieldEnum = (typeof SubItemScalarFieldEnum)[keyof typeof SubItemScalarFieldEnum]


  export const PhasePlaylistScalarFieldEnum: {
    id: 'id',
    phaseId: 'phaseId',
    title: 'title',
    author: 'author',
    videoCount: 'videoCount',
    url: 'url',
    thumbnail: 'thumbnail'
  };

  export type PhasePlaylistScalarFieldEnum = (typeof PhasePlaylistScalarFieldEnum)[keyof typeof PhasePlaylistScalarFieldEnum]


  export const PhaseProjectScalarFieldEnum: {
    id: 'id',
    phaseId: 'phaseId',
    title: 'title',
    description: 'description',
    tags: 'tags'
  };

  export type PhaseProjectScalarFieldEnum = (typeof PhaseProjectScalarFieldEnum)[keyof typeof PhaseProjectScalarFieldEnum]


  export const DSASheetScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    level: 'level',
    createdAt: 'createdAt'
  };

  export type DSASheetScalarFieldEnum = (typeof DSASheetScalarFieldEnum)[keyof typeof DSASheetScalarFieldEnum]


  export const DSATopicScalarFieldEnum: {
    id: 'id',
    title: 'title',
    sheetId: 'sheetId',
    order: 'order'
  };

  export type DSATopicScalarFieldEnum = (typeof DSATopicScalarFieldEnum)[keyof typeof DSATopicScalarFieldEnum]


  export const DSAProblemScalarFieldEnum: {
    id: 'id',
    title: 'title',
    description: 'description',
    difficulty: 'difficulty',
    topicId: 'topicId',
    order: 'order'
  };

  export type DSAProblemScalarFieldEnum = (typeof DSAProblemScalarFieldEnum)[keyof typeof DSAProblemScalarFieldEnum]


  export const DSASolutionScalarFieldEnum: {
    id: 'id',
    language: 'language',
    code: 'code',
    problemId: 'problemId'
  };

  export type DSASolutionScalarFieldEnum = (typeof DSASolutionScalarFieldEnum)[keyof typeof DSASolutionScalarFieldEnum]


  export const CertificateScalarFieldEnum: {
    id: 'id',
    certificateId: 'certificateId',
    eventId: 'eventId',
    userId: 'userId',
    teamId: 'teamId',
    participantName: 'participantName',
    position: 'position',
    issuedAt: 'issuedAt'
  };

  export type CertificateScalarFieldEnum = (typeof CertificateScalarFieldEnum)[keyof typeof CertificateScalarFieldEnum]


  export const EmailLogScalarFieldEnum: {
    id: 'id',
    eventId: 'eventId',
    subject: 'subject',
    message: 'message',
    recipientCount: 'recipientCount',
    sentBy: 'sentBy',
    sentAt: 'sentAt'
  };

  export type EmailLogScalarFieldEnum = (typeof EmailLogScalarFieldEnum)[keyof typeof EmailLogScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const NullableJsonNullValueInput: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull
  };

  export type NullableJsonNullValueInput = (typeof NullableJsonNullValueInput)[keyof typeof NullableJsonNullValueInput]


  export const JsonNullValueFilter: {
    DbNull: typeof DbNull,
    JsonNull: typeof JsonNull,
    AnyNull: typeof AnyNull
  };

  export type JsonNullValueFilter = (typeof JsonNullValueFilter)[keyof typeof JsonNullValueFilter]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'Json'
   */
  export type JsonFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Json'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'Decimal'
   */
  export type DecimalFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Decimal'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    fullName?: StringFilter<"User"> | string
    whatsapp?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    graduation?: StringNullableFilter<"User"> | string | null
    specialization?: StringNullableFilter<"User"> | string | null
    year?: StringNullableFilter<"User"> | string | null
    regNumber?: StringNullableFilter<"User"> | string | null
    skills?: JsonNullableFilter<"User">
    domain?: StringNullableFilter<"User"> | string | null
    githubUrl?: StringNullableFilter<"User"> | string | null
    codingUrl?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    totalPoints?: IntFilter<"User"> | number
    currentStreak?: IntFilter<"User"> | number
    longestStreak?: IntFilter<"User"> | number
    level?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastActive?: DateTimeNullableFilter<"User"> | Date | string | null
    eventRegistrations?: EventRegistrationListRelationFilter
    teamsLeading?: TeamListRelationFilter
    teamMemberships?: TeamMemberListRelationFilter
    teamJoinRequests?: TeamJoinRequestListRelationFilter
    submissions?: EventSubmissionListRelationFilter
    challengeProgress?: UserChallengeProgressListRelationFilter
    taskCompletions?: UserTaskCompletionListRelationFilter
    badges?: UserBadgeListRelationFilter
    achievements?: UserAchievementListRelationFilter
    leaderboardEntries?: LeaderboardListRelationFilter
    eventsCreated?: EventListRelationFilter
    challengesCreated?: ChallengeListRelationFilter
    certificates?: CertificateListRelationFilter
    emailsSent?: EmailLogListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    whatsapp?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    graduation?: SortOrderInput | SortOrder
    specialization?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    regNumber?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    domain?: SortOrderInput | SortOrder
    githubUrl?: SortOrderInput | SortOrder
    codingUrl?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    totalPoints?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActive?: SortOrderInput | SortOrder
    eventRegistrations?: EventRegistrationOrderByRelationAggregateInput
    teamsLeading?: TeamOrderByRelationAggregateInput
    teamMemberships?: TeamMemberOrderByRelationAggregateInput
    teamJoinRequests?: TeamJoinRequestOrderByRelationAggregateInput
    submissions?: EventSubmissionOrderByRelationAggregateInput
    challengeProgress?: UserChallengeProgressOrderByRelationAggregateInput
    taskCompletions?: UserTaskCompletionOrderByRelationAggregateInput
    badges?: UserBadgeOrderByRelationAggregateInput
    achievements?: UserAchievementOrderByRelationAggregateInput
    leaderboardEntries?: LeaderboardOrderByRelationAggregateInput
    eventsCreated?: EventOrderByRelationAggregateInput
    challengesCreated?: ChallengeOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
    emailsSent?: EmailLogOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    fullName?: StringFilter<"User"> | string
    whatsapp?: StringNullableFilter<"User"> | string | null
    gender?: StringNullableFilter<"User"> | string | null
    graduation?: StringNullableFilter<"User"> | string | null
    specialization?: StringNullableFilter<"User"> | string | null
    year?: StringNullableFilter<"User"> | string | null
    regNumber?: StringNullableFilter<"User"> | string | null
    skills?: JsonNullableFilter<"User">
    domain?: StringNullableFilter<"User"> | string | null
    githubUrl?: StringNullableFilter<"User"> | string | null
    codingUrl?: StringNullableFilter<"User"> | string | null
    profilePicture?: StringNullableFilter<"User"> | string | null
    totalPoints?: IntFilter<"User"> | number
    currentStreak?: IntFilter<"User"> | number
    longestStreak?: IntFilter<"User"> | number
    level?: IntFilter<"User"> | number
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    lastActive?: DateTimeNullableFilter<"User"> | Date | string | null
    eventRegistrations?: EventRegistrationListRelationFilter
    teamsLeading?: TeamListRelationFilter
    teamMemberships?: TeamMemberListRelationFilter
    teamJoinRequests?: TeamJoinRequestListRelationFilter
    submissions?: EventSubmissionListRelationFilter
    challengeProgress?: UserChallengeProgressListRelationFilter
    taskCompletions?: UserTaskCompletionListRelationFilter
    badges?: UserBadgeListRelationFilter
    achievements?: UserAchievementListRelationFilter
    leaderboardEntries?: LeaderboardListRelationFilter
    eventsCreated?: EventListRelationFilter
    challengesCreated?: ChallengeListRelationFilter
    certificates?: CertificateListRelationFilter
    emailsSent?: EmailLogListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    whatsapp?: SortOrderInput | SortOrder
    gender?: SortOrderInput | SortOrder
    graduation?: SortOrderInput | SortOrder
    specialization?: SortOrderInput | SortOrder
    year?: SortOrderInput | SortOrder
    regNumber?: SortOrderInput | SortOrder
    skills?: SortOrderInput | SortOrder
    domain?: SortOrderInput | SortOrder
    githubUrl?: SortOrderInput | SortOrder
    codingUrl?: SortOrderInput | SortOrder
    profilePicture?: SortOrderInput | SortOrder
    totalPoints?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActive?: SortOrderInput | SortOrder
    _count?: UserCountOrderByAggregateInput
    _avg?: UserAvgOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
    _sum?: UserSumOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    fullName?: StringWithAggregatesFilter<"User"> | string
    whatsapp?: StringNullableWithAggregatesFilter<"User"> | string | null
    gender?: StringNullableWithAggregatesFilter<"User"> | string | null
    graduation?: StringNullableWithAggregatesFilter<"User"> | string | null
    specialization?: StringNullableWithAggregatesFilter<"User"> | string | null
    year?: StringNullableWithAggregatesFilter<"User"> | string | null
    regNumber?: StringNullableWithAggregatesFilter<"User"> | string | null
    skills?: JsonNullableWithAggregatesFilter<"User">
    domain?: StringNullableWithAggregatesFilter<"User"> | string | null
    githubUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    codingUrl?: StringNullableWithAggregatesFilter<"User"> | string | null
    profilePicture?: StringNullableWithAggregatesFilter<"User"> | string | null
    totalPoints?: IntWithAggregatesFilter<"User"> | number
    currentStreak?: IntWithAggregatesFilter<"User"> | number
    longestStreak?: IntWithAggregatesFilter<"User"> | number
    level?: IntWithAggregatesFilter<"User"> | number
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    lastActive?: DateTimeNullableWithAggregatesFilter<"User"> | Date | string | null
  }

  export type EventCategoryWhereInput = {
    AND?: EventCategoryWhereInput | EventCategoryWhereInput[]
    OR?: EventCategoryWhereInput[]
    NOT?: EventCategoryWhereInput | EventCategoryWhereInput[]
    id?: StringFilter<"EventCategory"> | string
    name?: StringFilter<"EventCategory"> | string
    slug?: StringFilter<"EventCategory"> | string
    description?: StringNullableFilter<"EventCategory"> | string | null
    icon?: StringNullableFilter<"EventCategory"> | string | null
    color?: StringNullableFilter<"EventCategory"> | string | null
    parentId?: StringNullableFilter<"EventCategory"> | string | null
    createdAt?: DateTimeFilter<"EventCategory"> | Date | string
    parent?: XOR<EventCategoryNullableRelationFilter, EventCategoryWhereInput> | null
    children?: EventCategoryListRelationFilter
    events?: EventListRelationFilter
    eventTypes?: EventTypeListRelationFilter
  }

  export type EventCategoryOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    parent?: EventCategoryOrderByWithRelationInput
    children?: EventCategoryOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
    eventTypes?: EventTypeOrderByRelationAggregateInput
  }

  export type EventCategoryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    slug?: string
    AND?: EventCategoryWhereInput | EventCategoryWhereInput[]
    OR?: EventCategoryWhereInput[]
    NOT?: EventCategoryWhereInput | EventCategoryWhereInput[]
    description?: StringNullableFilter<"EventCategory"> | string | null
    icon?: StringNullableFilter<"EventCategory"> | string | null
    color?: StringNullableFilter<"EventCategory"> | string | null
    parentId?: StringNullableFilter<"EventCategory"> | string | null
    createdAt?: DateTimeFilter<"EventCategory"> | Date | string
    parent?: XOR<EventCategoryNullableRelationFilter, EventCategoryWhereInput> | null
    children?: EventCategoryListRelationFilter
    events?: EventListRelationFilter
    eventTypes?: EventTypeListRelationFilter
  }, "id" | "name" | "slug">

  export type EventCategoryOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    parentId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EventCategoryCountOrderByAggregateInput
    _max?: EventCategoryMaxOrderByAggregateInput
    _min?: EventCategoryMinOrderByAggregateInput
  }

  export type EventCategoryScalarWhereWithAggregatesInput = {
    AND?: EventCategoryScalarWhereWithAggregatesInput | EventCategoryScalarWhereWithAggregatesInput[]
    OR?: EventCategoryScalarWhereWithAggregatesInput[]
    NOT?: EventCategoryScalarWhereWithAggregatesInput | EventCategoryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventCategory"> | string
    name?: StringWithAggregatesFilter<"EventCategory"> | string
    slug?: StringWithAggregatesFilter<"EventCategory"> | string
    description?: StringNullableWithAggregatesFilter<"EventCategory"> | string | null
    icon?: StringNullableWithAggregatesFilter<"EventCategory"> | string | null
    color?: StringNullableWithAggregatesFilter<"EventCategory"> | string | null
    parentId?: StringNullableWithAggregatesFilter<"EventCategory"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EventCategory"> | Date | string
  }

  export type EventTypeWhereInput = {
    AND?: EventTypeWhereInput | EventTypeWhereInput[]
    OR?: EventTypeWhereInput[]
    NOT?: EventTypeWhereInput | EventTypeWhereInput[]
    id?: StringFilter<"EventType"> | string
    categoryId?: StringFilter<"EventType"> | string
    name?: StringFilter<"EventType"> | string
    slug?: StringFilter<"EventType"> | string
    description?: StringNullableFilter<"EventType"> | string | null
    defaultDurationHours?: IntNullableFilter<"EventType"> | number | null
    createdAt?: DateTimeFilter<"EventType"> | Date | string
    category?: XOR<EventCategoryRelationFilter, EventCategoryWhereInput>
  }

  export type EventTypeOrderByWithRelationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultDurationHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    category?: EventCategoryOrderByWithRelationInput
  }

  export type EventTypeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    categoryId_slug?: EventTypeCategoryIdSlugCompoundUniqueInput
    AND?: EventTypeWhereInput | EventTypeWhereInput[]
    OR?: EventTypeWhereInput[]
    NOT?: EventTypeWhereInput | EventTypeWhereInput[]
    categoryId?: StringFilter<"EventType"> | string
    name?: StringFilter<"EventType"> | string
    description?: StringNullableFilter<"EventType"> | string | null
    defaultDurationHours?: IntNullableFilter<"EventType"> | number | null
    createdAt?: DateTimeFilter<"EventType"> | Date | string
    category?: XOR<EventCategoryRelationFilter, EventCategoryWhereInput>
  }, "id" | "slug" | "categoryId_slug">

  export type EventTypeOrderByWithAggregationInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrderInput | SortOrder
    defaultDurationHours?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: EventTypeCountOrderByAggregateInput
    _avg?: EventTypeAvgOrderByAggregateInput
    _max?: EventTypeMaxOrderByAggregateInput
    _min?: EventTypeMinOrderByAggregateInput
    _sum?: EventTypeSumOrderByAggregateInput
  }

  export type EventTypeScalarWhereWithAggregatesInput = {
    AND?: EventTypeScalarWhereWithAggregatesInput | EventTypeScalarWhereWithAggregatesInput[]
    OR?: EventTypeScalarWhereWithAggregatesInput[]
    NOT?: EventTypeScalarWhereWithAggregatesInput | EventTypeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventType"> | string
    categoryId?: StringWithAggregatesFilter<"EventType"> | string
    name?: StringWithAggregatesFilter<"EventType"> | string
    slug?: StringWithAggregatesFilter<"EventType"> | string
    description?: StringNullableWithAggregatesFilter<"EventType"> | string | null
    defaultDurationHours?: IntNullableWithAggregatesFilter<"EventType"> | number | null
    createdAt?: DateTimeWithAggregatesFilter<"EventType"> | Date | string
  }

  export type EventWhereInput = {
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    slug?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    categoryId?: StringFilter<"Event"> | string
    eventType?: StringFilter<"Event"> | string
    mode?: StringFilter<"Event"> | string
    registrationStart?: DateTimeFilter<"Event"> | Date | string
    registrationEnd?: DateTimeFilter<"Event"> | Date | string
    maxParticipants?: IntNullableFilter<"Event"> | number | null
    isTeamEvent?: BoolFilter<"Event"> | boolean
    allowIndividual?: BoolFilter<"Event"> | boolean
    minTeamSize?: IntFilter<"Event"> | number
    maxTeamSize?: IntFilter<"Event"> | number
    teamFormationDeadline?: DateTimeNullableFilter<"Event"> | Date | string | null
    restrictSameCollege?: BoolFilter<"Event"> | boolean
    eventStart?: DateTimeFilter<"Event"> | Date | string
    eventEnd?: DateTimeFilter<"Event"> | Date | string
    isPaid?: BoolFilter<"Event"> | boolean
    registrationFee?: DecimalNullableFilter<"Event"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Event"> | string
    hasSubmission?: BoolFilter<"Event"> | boolean
    submissionStart?: DateTimeNullableFilter<"Event"> | Date | string | null
    submissionDeadline?: DateTimeNullableFilter<"Event"> | Date | string | null
    submissionTemplateUrl?: StringNullableFilter<"Event"> | string | null
    rules?: StringNullableFilter<"Event"> | string | null
    eligibility?: StringNullableFilter<"Event"> | string | null
    rewards?: StringNullableFilter<"Event"> | string | null
    prizes?: JsonNullableFilter<"Event">
    venue?: StringNullableFilter<"Event"> | string | null
    meetingLink?: StringNullableFilter<"Event"> | string | null
    resourceLinks?: JsonNullableFilter<"Event">
    bannerImage?: StringNullableFilter<"Event"> | string | null
    images?: JsonNullableFilter<"Event">
    status?: StringFilter<"Event"> | string
    isFeatured?: BoolFilter<"Event"> | boolean
    hasRoadmap?: BoolFilter<"Event"> | boolean
    roadmapId?: StringNullableFilter<"Event"> | string | null
    hasChallenges?: BoolFilter<"Event"> | boolean
    problemCount?: IntFilter<"Event"> | number
    createdBy?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    category?: XOR<EventCategoryRelationFilter, EventCategoryWhereInput>
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    roadmap?: XOR<RoadmapNullableRelationFilter, RoadmapWhereInput> | null
    registrations?: EventRegistrationListRelationFilter
    teams?: TeamListRelationFilter
    submissions?: EventSubmissionListRelationFilter
    eventChallenges?: EventChallengeListRelationFilter
    emailLogs?: EmailLogListRelationFilter
    certificates?: CertificateListRelationFilter
  }

  export type EventOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    eventType?: SortOrder
    mode?: SortOrder
    registrationStart?: SortOrder
    registrationEnd?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    isTeamEvent?: SortOrder
    allowIndividual?: SortOrder
    minTeamSize?: SortOrder
    maxTeamSize?: SortOrder
    teamFormationDeadline?: SortOrderInput | SortOrder
    restrictSameCollege?: SortOrder
    eventStart?: SortOrder
    eventEnd?: SortOrder
    isPaid?: SortOrder
    registrationFee?: SortOrderInput | SortOrder
    currency?: SortOrder
    hasSubmission?: SortOrder
    submissionStart?: SortOrderInput | SortOrder
    submissionDeadline?: SortOrderInput | SortOrder
    submissionTemplateUrl?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    eligibility?: SortOrderInput | SortOrder
    rewards?: SortOrderInput | SortOrder
    prizes?: SortOrderInput | SortOrder
    venue?: SortOrderInput | SortOrder
    meetingLink?: SortOrderInput | SortOrder
    resourceLinks?: SortOrderInput | SortOrder
    bannerImage?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    hasRoadmap?: SortOrder
    roadmapId?: SortOrderInput | SortOrder
    hasChallenges?: SortOrder
    problemCount?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: EventCategoryOrderByWithRelationInput
    creator?: UserOrderByWithRelationInput
    roadmap?: RoadmapOrderByWithRelationInput
    registrations?: EventRegistrationOrderByRelationAggregateInput
    teams?: TeamOrderByRelationAggregateInput
    submissions?: EventSubmissionOrderByRelationAggregateInput
    eventChallenges?: EventChallengeOrderByRelationAggregateInput
    emailLogs?: EmailLogOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
  }

  export type EventWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: EventWhereInput | EventWhereInput[]
    OR?: EventWhereInput[]
    NOT?: EventWhereInput | EventWhereInput[]
    title?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    categoryId?: StringFilter<"Event"> | string
    eventType?: StringFilter<"Event"> | string
    mode?: StringFilter<"Event"> | string
    registrationStart?: DateTimeFilter<"Event"> | Date | string
    registrationEnd?: DateTimeFilter<"Event"> | Date | string
    maxParticipants?: IntNullableFilter<"Event"> | number | null
    isTeamEvent?: BoolFilter<"Event"> | boolean
    allowIndividual?: BoolFilter<"Event"> | boolean
    minTeamSize?: IntFilter<"Event"> | number
    maxTeamSize?: IntFilter<"Event"> | number
    teamFormationDeadline?: DateTimeNullableFilter<"Event"> | Date | string | null
    restrictSameCollege?: BoolFilter<"Event"> | boolean
    eventStart?: DateTimeFilter<"Event"> | Date | string
    eventEnd?: DateTimeFilter<"Event"> | Date | string
    isPaid?: BoolFilter<"Event"> | boolean
    registrationFee?: DecimalNullableFilter<"Event"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Event"> | string
    hasSubmission?: BoolFilter<"Event"> | boolean
    submissionStart?: DateTimeNullableFilter<"Event"> | Date | string | null
    submissionDeadline?: DateTimeNullableFilter<"Event"> | Date | string | null
    submissionTemplateUrl?: StringNullableFilter<"Event"> | string | null
    rules?: StringNullableFilter<"Event"> | string | null
    eligibility?: StringNullableFilter<"Event"> | string | null
    rewards?: StringNullableFilter<"Event"> | string | null
    prizes?: JsonNullableFilter<"Event">
    venue?: StringNullableFilter<"Event"> | string | null
    meetingLink?: StringNullableFilter<"Event"> | string | null
    resourceLinks?: JsonNullableFilter<"Event">
    bannerImage?: StringNullableFilter<"Event"> | string | null
    images?: JsonNullableFilter<"Event">
    status?: StringFilter<"Event"> | string
    isFeatured?: BoolFilter<"Event"> | boolean
    hasRoadmap?: BoolFilter<"Event"> | boolean
    roadmapId?: StringNullableFilter<"Event"> | string | null
    hasChallenges?: BoolFilter<"Event"> | boolean
    problemCount?: IntFilter<"Event"> | number
    createdBy?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
    category?: XOR<EventCategoryRelationFilter, EventCategoryWhereInput>
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    roadmap?: XOR<RoadmapNullableRelationFilter, RoadmapWhereInput> | null
    registrations?: EventRegistrationListRelationFilter
    teams?: TeamListRelationFilter
    submissions?: EventSubmissionListRelationFilter
    eventChallenges?: EventChallengeListRelationFilter
    emailLogs?: EmailLogListRelationFilter
    certificates?: CertificateListRelationFilter
  }, "id" | "slug">

  export type EventOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    eventType?: SortOrder
    mode?: SortOrder
    registrationStart?: SortOrder
    registrationEnd?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    isTeamEvent?: SortOrder
    allowIndividual?: SortOrder
    minTeamSize?: SortOrder
    maxTeamSize?: SortOrder
    teamFormationDeadline?: SortOrderInput | SortOrder
    restrictSameCollege?: SortOrder
    eventStart?: SortOrder
    eventEnd?: SortOrder
    isPaid?: SortOrder
    registrationFee?: SortOrderInput | SortOrder
    currency?: SortOrder
    hasSubmission?: SortOrder
    submissionStart?: SortOrderInput | SortOrder
    submissionDeadline?: SortOrderInput | SortOrder
    submissionTemplateUrl?: SortOrderInput | SortOrder
    rules?: SortOrderInput | SortOrder
    eligibility?: SortOrderInput | SortOrder
    rewards?: SortOrderInput | SortOrder
    prizes?: SortOrderInput | SortOrder
    venue?: SortOrderInput | SortOrder
    meetingLink?: SortOrderInput | SortOrder
    resourceLinks?: SortOrderInput | SortOrder
    bannerImage?: SortOrderInput | SortOrder
    images?: SortOrderInput | SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    hasRoadmap?: SortOrder
    roadmapId?: SortOrderInput | SortOrder
    hasChallenges?: SortOrder
    problemCount?: SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EventCountOrderByAggregateInput
    _avg?: EventAvgOrderByAggregateInput
    _max?: EventMaxOrderByAggregateInput
    _min?: EventMinOrderByAggregateInput
    _sum?: EventSumOrderByAggregateInput
  }

  export type EventScalarWhereWithAggregatesInput = {
    AND?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    OR?: EventScalarWhereWithAggregatesInput[]
    NOT?: EventScalarWhereWithAggregatesInput | EventScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Event"> | string
    title?: StringWithAggregatesFilter<"Event"> | string
    slug?: StringWithAggregatesFilter<"Event"> | string
    description?: StringWithAggregatesFilter<"Event"> | string
    categoryId?: StringWithAggregatesFilter<"Event"> | string
    eventType?: StringWithAggregatesFilter<"Event"> | string
    mode?: StringWithAggregatesFilter<"Event"> | string
    registrationStart?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    registrationEnd?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    maxParticipants?: IntNullableWithAggregatesFilter<"Event"> | number | null
    isTeamEvent?: BoolWithAggregatesFilter<"Event"> | boolean
    allowIndividual?: BoolWithAggregatesFilter<"Event"> | boolean
    minTeamSize?: IntWithAggregatesFilter<"Event"> | number
    maxTeamSize?: IntWithAggregatesFilter<"Event"> | number
    teamFormationDeadline?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    restrictSameCollege?: BoolWithAggregatesFilter<"Event"> | boolean
    eventStart?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    eventEnd?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    isPaid?: BoolWithAggregatesFilter<"Event"> | boolean
    registrationFee?: DecimalNullableWithAggregatesFilter<"Event"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringWithAggregatesFilter<"Event"> | string
    hasSubmission?: BoolWithAggregatesFilter<"Event"> | boolean
    submissionStart?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    submissionDeadline?: DateTimeNullableWithAggregatesFilter<"Event"> | Date | string | null
    submissionTemplateUrl?: StringNullableWithAggregatesFilter<"Event"> | string | null
    rules?: StringNullableWithAggregatesFilter<"Event"> | string | null
    eligibility?: StringNullableWithAggregatesFilter<"Event"> | string | null
    rewards?: StringNullableWithAggregatesFilter<"Event"> | string | null
    prizes?: JsonNullableWithAggregatesFilter<"Event">
    venue?: StringNullableWithAggregatesFilter<"Event"> | string | null
    meetingLink?: StringNullableWithAggregatesFilter<"Event"> | string | null
    resourceLinks?: JsonNullableWithAggregatesFilter<"Event">
    bannerImage?: StringNullableWithAggregatesFilter<"Event"> | string | null
    images?: JsonNullableWithAggregatesFilter<"Event">
    status?: StringWithAggregatesFilter<"Event"> | string
    isFeatured?: BoolWithAggregatesFilter<"Event"> | boolean
    hasRoadmap?: BoolWithAggregatesFilter<"Event"> | boolean
    roadmapId?: StringNullableWithAggregatesFilter<"Event"> | string | null
    hasChallenges?: BoolWithAggregatesFilter<"Event"> | boolean
    problemCount?: IntWithAggregatesFilter<"Event"> | number
    createdBy?: StringNullableWithAggregatesFilter<"Event"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Event"> | Date | string
  }

  export type TeamWhereInput = {
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    id?: StringFilter<"Team"> | string
    eventId?: StringFilter<"Team"> | string
    teamName?: StringFilter<"Team"> | string
    teamLeaderId?: StringFilter<"Team"> | string
    isComplete?: BoolFilter<"Team"> | boolean
    isLocked?: BoolFilter<"Team"> | boolean
    collegeName?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    leader?: XOR<UserRelationFilter, UserWhereInput>
    members?: TeamMemberListRelationFilter
    joinRequests?: TeamJoinRequestListRelationFilter
    registrations?: EventRegistrationListRelationFilter
    submissions?: EventSubmissionListRelationFilter
    certificates?: CertificateListRelationFilter
  }

  export type TeamOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    teamName?: SortOrder
    teamLeaderId?: SortOrder
    isComplete?: SortOrder
    isLocked?: SortOrder
    collegeName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    event?: EventOrderByWithRelationInput
    leader?: UserOrderByWithRelationInput
    members?: TeamMemberOrderByRelationAggregateInput
    joinRequests?: TeamJoinRequestOrderByRelationAggregateInput
    registrations?: EventRegistrationOrderByRelationAggregateInput
    submissions?: EventSubmissionOrderByRelationAggregateInput
    certificates?: CertificateOrderByRelationAggregateInput
  }

  export type TeamWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_teamName?: TeamEventIdTeamNameCompoundUniqueInput
    AND?: TeamWhereInput | TeamWhereInput[]
    OR?: TeamWhereInput[]
    NOT?: TeamWhereInput | TeamWhereInput[]
    eventId?: StringFilter<"Team"> | string
    teamName?: StringFilter<"Team"> | string
    teamLeaderId?: StringFilter<"Team"> | string
    isComplete?: BoolFilter<"Team"> | boolean
    isLocked?: BoolFilter<"Team"> | boolean
    collegeName?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    leader?: XOR<UserRelationFilter, UserWhereInput>
    members?: TeamMemberListRelationFilter
    joinRequests?: TeamJoinRequestListRelationFilter
    registrations?: EventRegistrationListRelationFilter
    submissions?: EventSubmissionListRelationFilter
    certificates?: CertificateListRelationFilter
  }, "id" | "eventId_teamName">

  export type TeamOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    teamName?: SortOrder
    teamLeaderId?: SortOrder
    isComplete?: SortOrder
    isLocked?: SortOrder
    collegeName?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TeamCountOrderByAggregateInput
    _max?: TeamMaxOrderByAggregateInput
    _min?: TeamMinOrderByAggregateInput
  }

  export type TeamScalarWhereWithAggregatesInput = {
    AND?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    OR?: TeamScalarWhereWithAggregatesInput[]
    NOT?: TeamScalarWhereWithAggregatesInput | TeamScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Team"> | string
    eventId?: StringWithAggregatesFilter<"Team"> | string
    teamName?: StringWithAggregatesFilter<"Team"> | string
    teamLeaderId?: StringWithAggregatesFilter<"Team"> | string
    isComplete?: BoolWithAggregatesFilter<"Team"> | boolean
    isLocked?: BoolWithAggregatesFilter<"Team"> | boolean
    collegeName?: StringNullableWithAggregatesFilter<"Team"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Team"> | Date | string
  }

  export type TeamMemberWhereInput = {
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    isLeader?: BoolFilter<"TeamMember"> | boolean
    status?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    leftAt?: DateTimeNullableFilter<"TeamMember"> | Date | string | null
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TeamMemberOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    isLeader?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamMemberWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_userId?: TeamMemberTeamIdUserIdCompoundUniqueInput
    AND?: TeamMemberWhereInput | TeamMemberWhereInput[]
    OR?: TeamMemberWhereInput[]
    NOT?: TeamMemberWhereInput | TeamMemberWhereInput[]
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    isLeader?: BoolFilter<"TeamMember"> | boolean
    status?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    leftAt?: DateTimeNullableFilter<"TeamMember"> | Date | string | null
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamMemberOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    isLeader?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrderInput | SortOrder
    _count?: TeamMemberCountOrderByAggregateInput
    _max?: TeamMemberMaxOrderByAggregateInput
    _min?: TeamMemberMinOrderByAggregateInput
  }

  export type TeamMemberScalarWhereWithAggregatesInput = {
    AND?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    OR?: TeamMemberScalarWhereWithAggregatesInput[]
    NOT?: TeamMemberScalarWhereWithAggregatesInput | TeamMemberScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamMember"> | string
    teamId?: StringWithAggregatesFilter<"TeamMember"> | string
    userId?: StringWithAggregatesFilter<"TeamMember"> | string
    isLeader?: BoolWithAggregatesFilter<"TeamMember"> | boolean
    status?: StringWithAggregatesFilter<"TeamMember"> | string
    joinedAt?: DateTimeWithAggregatesFilter<"TeamMember"> | Date | string
    leftAt?: DateTimeNullableWithAggregatesFilter<"TeamMember"> | Date | string | null
  }

  export type TeamJoinRequestWhereInput = {
    AND?: TeamJoinRequestWhereInput | TeamJoinRequestWhereInput[]
    OR?: TeamJoinRequestWhereInput[]
    NOT?: TeamJoinRequestWhereInput | TeamJoinRequestWhereInput[]
    id?: StringFilter<"TeamJoinRequest"> | string
    teamId?: StringFilter<"TeamJoinRequest"> | string
    userId?: StringFilter<"TeamJoinRequest"> | string
    requestType?: StringFilter<"TeamJoinRequest"> | string
    status?: StringFilter<"TeamJoinRequest"> | string
    message?: StringNullableFilter<"TeamJoinRequest"> | string | null
    responseMessage?: StringNullableFilter<"TeamJoinRequest"> | string | null
    createdAt?: DateTimeFilter<"TeamJoinRequest"> | Date | string
    respondedAt?: DateTimeNullableFilter<"TeamJoinRequest"> | Date | string | null
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type TeamJoinRequestOrderByWithRelationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    requestType?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    responseMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    team?: TeamOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
  }

  export type TeamJoinRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    teamId_userId?: TeamJoinRequestTeamIdUserIdCompoundUniqueInput
    AND?: TeamJoinRequestWhereInput | TeamJoinRequestWhereInput[]
    OR?: TeamJoinRequestWhereInput[]
    NOT?: TeamJoinRequestWhereInput | TeamJoinRequestWhereInput[]
    teamId?: StringFilter<"TeamJoinRequest"> | string
    userId?: StringFilter<"TeamJoinRequest"> | string
    requestType?: StringFilter<"TeamJoinRequest"> | string
    status?: StringFilter<"TeamJoinRequest"> | string
    message?: StringNullableFilter<"TeamJoinRequest"> | string | null
    responseMessage?: StringNullableFilter<"TeamJoinRequest"> | string | null
    createdAt?: DateTimeFilter<"TeamJoinRequest"> | Date | string
    respondedAt?: DateTimeNullableFilter<"TeamJoinRequest"> | Date | string | null
    team?: XOR<TeamRelationFilter, TeamWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "teamId_userId">

  export type TeamJoinRequestOrderByWithAggregationInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    requestType?: SortOrder
    status?: SortOrder
    message?: SortOrderInput | SortOrder
    responseMessage?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrderInput | SortOrder
    _count?: TeamJoinRequestCountOrderByAggregateInput
    _max?: TeamJoinRequestMaxOrderByAggregateInput
    _min?: TeamJoinRequestMinOrderByAggregateInput
  }

  export type TeamJoinRequestScalarWhereWithAggregatesInput = {
    AND?: TeamJoinRequestScalarWhereWithAggregatesInput | TeamJoinRequestScalarWhereWithAggregatesInput[]
    OR?: TeamJoinRequestScalarWhereWithAggregatesInput[]
    NOT?: TeamJoinRequestScalarWhereWithAggregatesInput | TeamJoinRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TeamJoinRequest"> | string
    teamId?: StringWithAggregatesFilter<"TeamJoinRequest"> | string
    userId?: StringWithAggregatesFilter<"TeamJoinRequest"> | string
    requestType?: StringWithAggregatesFilter<"TeamJoinRequest"> | string
    status?: StringWithAggregatesFilter<"TeamJoinRequest"> | string
    message?: StringNullableWithAggregatesFilter<"TeamJoinRequest"> | string | null
    responseMessage?: StringNullableWithAggregatesFilter<"TeamJoinRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TeamJoinRequest"> | Date | string
    respondedAt?: DateTimeNullableWithAggregatesFilter<"TeamJoinRequest"> | Date | string | null
  }

  export type EventRegistrationWhereInput = {
    AND?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    OR?: EventRegistrationWhereInput[]
    NOT?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    id?: StringFilter<"EventRegistration"> | string
    eventId?: StringFilter<"EventRegistration"> | string
    userId?: StringFilter<"EventRegistration"> | string
    teamId?: StringNullableFilter<"EventRegistration"> | string | null
    participationType?: StringFilter<"EventRegistration"> | string
    paymentStatus?: StringFilter<"EventRegistration"> | string
    paymentId?: StringNullableFilter<"EventRegistration"> | string | null
    amountPaid?: DecimalNullableFilter<"EventRegistration"> | Decimal | DecimalJsLike | number | string | null
    paidAt?: DateTimeNullableFilter<"EventRegistration"> | Date | string | null
    status?: StringFilter<"EventRegistration"> | string
    registeredAt?: DateTimeFilter<"EventRegistration"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"EventRegistration"> | Date | string | null
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
  }

  export type EventRegistrationOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    participationType?: SortOrder
    paymentStatus?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    status?: SortOrder
    registeredAt?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    event?: EventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type EventRegistrationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_userId?: EventRegistrationEventIdUserIdCompoundUniqueInput
    AND?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    OR?: EventRegistrationWhereInput[]
    NOT?: EventRegistrationWhereInput | EventRegistrationWhereInput[]
    eventId?: StringFilter<"EventRegistration"> | string
    userId?: StringFilter<"EventRegistration"> | string
    teamId?: StringNullableFilter<"EventRegistration"> | string | null
    participationType?: StringFilter<"EventRegistration"> | string
    paymentStatus?: StringFilter<"EventRegistration"> | string
    paymentId?: StringNullableFilter<"EventRegistration"> | string | null
    amountPaid?: DecimalNullableFilter<"EventRegistration"> | Decimal | DecimalJsLike | number | string | null
    paidAt?: DateTimeNullableFilter<"EventRegistration"> | Date | string | null
    status?: StringFilter<"EventRegistration"> | string
    registeredAt?: DateTimeFilter<"EventRegistration"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"EventRegistration"> | Date | string | null
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
  }, "id" | "eventId_userId">

  export type EventRegistrationOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    participationType?: SortOrder
    paymentStatus?: SortOrder
    paymentId?: SortOrderInput | SortOrder
    amountPaid?: SortOrderInput | SortOrder
    paidAt?: SortOrderInput | SortOrder
    status?: SortOrder
    registeredAt?: SortOrder
    cancelledAt?: SortOrderInput | SortOrder
    _count?: EventRegistrationCountOrderByAggregateInput
    _avg?: EventRegistrationAvgOrderByAggregateInput
    _max?: EventRegistrationMaxOrderByAggregateInput
    _min?: EventRegistrationMinOrderByAggregateInput
    _sum?: EventRegistrationSumOrderByAggregateInput
  }

  export type EventRegistrationScalarWhereWithAggregatesInput = {
    AND?: EventRegistrationScalarWhereWithAggregatesInput | EventRegistrationScalarWhereWithAggregatesInput[]
    OR?: EventRegistrationScalarWhereWithAggregatesInput[]
    NOT?: EventRegistrationScalarWhereWithAggregatesInput | EventRegistrationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventRegistration"> | string
    eventId?: StringWithAggregatesFilter<"EventRegistration"> | string
    userId?: StringWithAggregatesFilter<"EventRegistration"> | string
    teamId?: StringNullableWithAggregatesFilter<"EventRegistration"> | string | null
    participationType?: StringWithAggregatesFilter<"EventRegistration"> | string
    paymentStatus?: StringWithAggregatesFilter<"EventRegistration"> | string
    paymentId?: StringNullableWithAggregatesFilter<"EventRegistration"> | string | null
    amountPaid?: DecimalNullableWithAggregatesFilter<"EventRegistration"> | Decimal | DecimalJsLike | number | string | null
    paidAt?: DateTimeNullableWithAggregatesFilter<"EventRegistration"> | Date | string | null
    status?: StringWithAggregatesFilter<"EventRegistration"> | string
    registeredAt?: DateTimeWithAggregatesFilter<"EventRegistration"> | Date | string
    cancelledAt?: DateTimeNullableWithAggregatesFilter<"EventRegistration"> | Date | string | null
  }

  export type EventSubmissionWhereInput = {
    AND?: EventSubmissionWhereInput | EventSubmissionWhereInput[]
    OR?: EventSubmissionWhereInput[]
    NOT?: EventSubmissionWhereInput | EventSubmissionWhereInput[]
    id?: StringFilter<"EventSubmission"> | string
    eventId?: StringFilter<"EventSubmission"> | string
    userId?: StringFilter<"EventSubmission"> | string
    teamId?: StringNullableFilter<"EventSubmission"> | string | null
    projectDeckUrl?: StringNullableFilter<"EventSubmission"> | string | null
    presentationPdfUrl?: StringNullableFilter<"EventSubmission"> | string | null
    mvpLink?: StringNullableFilter<"EventSubmission"> | string | null
    demoVideoUrl?: StringNullableFilter<"EventSubmission"> | string | null
    githubRepoUrl?: StringNullableFilter<"EventSubmission"> | string | null
    technologiesUsed?: StringNullableFilter<"EventSubmission"> | string | null
    aiToolsIntegrated?: StringNullableFilter<"EventSubmission"> | string | null
    solutionDescription?: StringNullableFilter<"EventSubmission"> | string | null
    score?: DecimalNullableFilter<"EventSubmission"> | Decimal | DecimalJsLike | number | string | null
    rank?: IntNullableFilter<"EventSubmission"> | number | null
    feedback?: StringNullableFilter<"EventSubmission"> | string | null
    status?: StringFilter<"EventSubmission"> | string
    submittedAt?: DateTimeFilter<"EventSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"EventSubmission"> | Date | string
    evaluatedAt?: DateTimeNullableFilter<"EventSubmission"> | Date | string | null
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
  }

  export type EventSubmissionOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    projectDeckUrl?: SortOrderInput | SortOrder
    presentationPdfUrl?: SortOrderInput | SortOrder
    mvpLink?: SortOrderInput | SortOrder
    demoVideoUrl?: SortOrderInput | SortOrder
    githubRepoUrl?: SortOrderInput | SortOrder
    technologiesUsed?: SortOrderInput | SortOrder
    aiToolsIntegrated?: SortOrderInput | SortOrder
    solutionDescription?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    evaluatedAt?: SortOrderInput | SortOrder
    event?: EventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type EventSubmissionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    eventId_userId?: EventSubmissionEventIdUserIdCompoundUniqueInput
    eventId_teamId?: EventSubmissionEventIdTeamIdCompoundUniqueInput
    AND?: EventSubmissionWhereInput | EventSubmissionWhereInput[]
    OR?: EventSubmissionWhereInput[]
    NOT?: EventSubmissionWhereInput | EventSubmissionWhereInput[]
    eventId?: StringFilter<"EventSubmission"> | string
    userId?: StringFilter<"EventSubmission"> | string
    teamId?: StringNullableFilter<"EventSubmission"> | string | null
    projectDeckUrl?: StringNullableFilter<"EventSubmission"> | string | null
    presentationPdfUrl?: StringNullableFilter<"EventSubmission"> | string | null
    mvpLink?: StringNullableFilter<"EventSubmission"> | string | null
    demoVideoUrl?: StringNullableFilter<"EventSubmission"> | string | null
    githubRepoUrl?: StringNullableFilter<"EventSubmission"> | string | null
    technologiesUsed?: StringNullableFilter<"EventSubmission"> | string | null
    aiToolsIntegrated?: StringNullableFilter<"EventSubmission"> | string | null
    solutionDescription?: StringNullableFilter<"EventSubmission"> | string | null
    score?: DecimalNullableFilter<"EventSubmission"> | Decimal | DecimalJsLike | number | string | null
    rank?: IntNullableFilter<"EventSubmission"> | number | null
    feedback?: StringNullableFilter<"EventSubmission"> | string | null
    status?: StringFilter<"EventSubmission"> | string
    submittedAt?: DateTimeFilter<"EventSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"EventSubmission"> | Date | string
    evaluatedAt?: DateTimeNullableFilter<"EventSubmission"> | Date | string | null
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
  }, "id" | "eventId_userId" | "eventId_teamId">

  export type EventSubmissionOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    projectDeckUrl?: SortOrderInput | SortOrder
    presentationPdfUrl?: SortOrderInput | SortOrder
    mvpLink?: SortOrderInput | SortOrder
    demoVideoUrl?: SortOrderInput | SortOrder
    githubRepoUrl?: SortOrderInput | SortOrder
    technologiesUsed?: SortOrderInput | SortOrder
    aiToolsIntegrated?: SortOrderInput | SortOrder
    solutionDescription?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    rank?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    evaluatedAt?: SortOrderInput | SortOrder
    _count?: EventSubmissionCountOrderByAggregateInput
    _avg?: EventSubmissionAvgOrderByAggregateInput
    _max?: EventSubmissionMaxOrderByAggregateInput
    _min?: EventSubmissionMinOrderByAggregateInput
    _sum?: EventSubmissionSumOrderByAggregateInput
  }

  export type EventSubmissionScalarWhereWithAggregatesInput = {
    AND?: EventSubmissionScalarWhereWithAggregatesInput | EventSubmissionScalarWhereWithAggregatesInput[]
    OR?: EventSubmissionScalarWhereWithAggregatesInput[]
    NOT?: EventSubmissionScalarWhereWithAggregatesInput | EventSubmissionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EventSubmission"> | string
    eventId?: StringWithAggregatesFilter<"EventSubmission"> | string
    userId?: StringWithAggregatesFilter<"EventSubmission"> | string
    teamId?: StringNullableWithAggregatesFilter<"EventSubmission"> | string | null
    projectDeckUrl?: StringNullableWithAggregatesFilter<"EventSubmission"> | string | null
    presentationPdfUrl?: StringNullableWithAggregatesFilter<"EventSubmission"> | string | null
    mvpLink?: StringNullableWithAggregatesFilter<"EventSubmission"> | string | null
    demoVideoUrl?: StringNullableWithAggregatesFilter<"EventSubmission"> | string | null
    githubRepoUrl?: StringNullableWithAggregatesFilter<"EventSubmission"> | string | null
    technologiesUsed?: StringNullableWithAggregatesFilter<"EventSubmission"> | string | null
    aiToolsIntegrated?: StringNullableWithAggregatesFilter<"EventSubmission"> | string | null
    solutionDescription?: StringNullableWithAggregatesFilter<"EventSubmission"> | string | null
    score?: DecimalNullableWithAggregatesFilter<"EventSubmission"> | Decimal | DecimalJsLike | number | string | null
    rank?: IntNullableWithAggregatesFilter<"EventSubmission"> | number | null
    feedback?: StringNullableWithAggregatesFilter<"EventSubmission"> | string | null
    status?: StringWithAggregatesFilter<"EventSubmission"> | string
    submittedAt?: DateTimeWithAggregatesFilter<"EventSubmission"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EventSubmission"> | Date | string
    evaluatedAt?: DateTimeNullableWithAggregatesFilter<"EventSubmission"> | Date | string | null
  }

  export type ChallengeWhereInput = {
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    id?: StringFilter<"Challenge"> | string
    title?: StringFilter<"Challenge"> | string
    slug?: StringFilter<"Challenge"> | string
    description?: StringFilter<"Challenge"> | string
    challengeType?: StringFilter<"Challenge"> | string
    difficulty?: StringFilter<"Challenge"> | string
    durationDays?: IntFilter<"Challenge"> | number
    startDate?: DateTimeFilter<"Challenge"> | Date | string
    endDate?: DateTimeFilter<"Challenge"> | Date | string
    category?: StringNullableFilter<"Challenge"> | string | null
    tags?: JsonNullableFilter<"Challenge">
    pointsPerDay?: IntFilter<"Challenge"> | number
    bonusPoints?: JsonNullableFilter<"Challenge">
    badges?: JsonNullableFilter<"Challenge">
    hasLeaderboard?: BoolFilter<"Challenge"> | boolean
    isPublic?: BoolFilter<"Challenge"> | boolean
    maxParticipants?: IntNullableFilter<"Challenge"> | number | null
    bannerImage?: StringNullableFilter<"Challenge"> | string | null
    icon?: StringNullableFilter<"Challenge"> | string | null
    status?: StringFilter<"Challenge"> | string
    totalParticipants?: IntFilter<"Challenge"> | number
    activeParticipants?: IntFilter<"Challenge"> | number
    completionRate?: DecimalNullableFilter<"Challenge"> | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringNullableFilter<"Challenge"> | string | null
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    tasks?: ChallengeTaskListRelationFilter
    userProgress?: UserChallengeProgressListRelationFilter
    eventChallenges?: EventChallengeListRelationFilter
  }

  export type ChallengeOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    challengeType?: SortOrder
    difficulty?: SortOrder
    durationDays?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    pointsPerDay?: SortOrder
    bonusPoints?: SortOrderInput | SortOrder
    badges?: SortOrderInput | SortOrder
    hasLeaderboard?: SortOrder
    isPublic?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    bannerImage?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    status?: SortOrder
    totalParticipants?: SortOrder
    activeParticipants?: SortOrder
    completionRate?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    creator?: UserOrderByWithRelationInput
    tasks?: ChallengeTaskOrderByRelationAggregateInput
    userProgress?: UserChallengeProgressOrderByRelationAggregateInput
    eventChallenges?: EventChallengeOrderByRelationAggregateInput
  }

  export type ChallengeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    slug?: string
    AND?: ChallengeWhereInput | ChallengeWhereInput[]
    OR?: ChallengeWhereInput[]
    NOT?: ChallengeWhereInput | ChallengeWhereInput[]
    title?: StringFilter<"Challenge"> | string
    description?: StringFilter<"Challenge"> | string
    challengeType?: StringFilter<"Challenge"> | string
    difficulty?: StringFilter<"Challenge"> | string
    durationDays?: IntFilter<"Challenge"> | number
    startDate?: DateTimeFilter<"Challenge"> | Date | string
    endDate?: DateTimeFilter<"Challenge"> | Date | string
    category?: StringNullableFilter<"Challenge"> | string | null
    tags?: JsonNullableFilter<"Challenge">
    pointsPerDay?: IntFilter<"Challenge"> | number
    bonusPoints?: JsonNullableFilter<"Challenge">
    badges?: JsonNullableFilter<"Challenge">
    hasLeaderboard?: BoolFilter<"Challenge"> | boolean
    isPublic?: BoolFilter<"Challenge"> | boolean
    maxParticipants?: IntNullableFilter<"Challenge"> | number | null
    bannerImage?: StringNullableFilter<"Challenge"> | string | null
    icon?: StringNullableFilter<"Challenge"> | string | null
    status?: StringFilter<"Challenge"> | string
    totalParticipants?: IntFilter<"Challenge"> | number
    activeParticipants?: IntFilter<"Challenge"> | number
    completionRate?: DecimalNullableFilter<"Challenge"> | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringNullableFilter<"Challenge"> | string | null
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
    creator?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    tasks?: ChallengeTaskListRelationFilter
    userProgress?: UserChallengeProgressListRelationFilter
    eventChallenges?: EventChallengeListRelationFilter
  }, "id" | "slug">

  export type ChallengeOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    challengeType?: SortOrder
    difficulty?: SortOrder
    durationDays?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    category?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    pointsPerDay?: SortOrder
    bonusPoints?: SortOrderInput | SortOrder
    badges?: SortOrderInput | SortOrder
    hasLeaderboard?: SortOrder
    isPublic?: SortOrder
    maxParticipants?: SortOrderInput | SortOrder
    bannerImage?: SortOrderInput | SortOrder
    icon?: SortOrderInput | SortOrder
    status?: SortOrder
    totalParticipants?: SortOrder
    activeParticipants?: SortOrder
    completionRate?: SortOrderInput | SortOrder
    createdBy?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ChallengeCountOrderByAggregateInput
    _avg?: ChallengeAvgOrderByAggregateInput
    _max?: ChallengeMaxOrderByAggregateInput
    _min?: ChallengeMinOrderByAggregateInput
    _sum?: ChallengeSumOrderByAggregateInput
  }

  export type ChallengeScalarWhereWithAggregatesInput = {
    AND?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    OR?: ChallengeScalarWhereWithAggregatesInput[]
    NOT?: ChallengeScalarWhereWithAggregatesInput | ChallengeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Challenge"> | string
    title?: StringWithAggregatesFilter<"Challenge"> | string
    slug?: StringWithAggregatesFilter<"Challenge"> | string
    description?: StringWithAggregatesFilter<"Challenge"> | string
    challengeType?: StringWithAggregatesFilter<"Challenge"> | string
    difficulty?: StringWithAggregatesFilter<"Challenge"> | string
    durationDays?: IntWithAggregatesFilter<"Challenge"> | number
    startDate?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    category?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    tags?: JsonNullableWithAggregatesFilter<"Challenge">
    pointsPerDay?: IntWithAggregatesFilter<"Challenge"> | number
    bonusPoints?: JsonNullableWithAggregatesFilter<"Challenge">
    badges?: JsonNullableWithAggregatesFilter<"Challenge">
    hasLeaderboard?: BoolWithAggregatesFilter<"Challenge"> | boolean
    isPublic?: BoolWithAggregatesFilter<"Challenge"> | boolean
    maxParticipants?: IntNullableWithAggregatesFilter<"Challenge"> | number | null
    bannerImage?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    icon?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    status?: StringWithAggregatesFilter<"Challenge"> | string
    totalParticipants?: IntWithAggregatesFilter<"Challenge"> | number
    activeParticipants?: IntWithAggregatesFilter<"Challenge"> | number
    completionRate?: DecimalNullableWithAggregatesFilter<"Challenge"> | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringNullableWithAggregatesFilter<"Challenge"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Challenge"> | Date | string
  }

  export type ChallengeTaskWhereInput = {
    AND?: ChallengeTaskWhereInput | ChallengeTaskWhereInput[]
    OR?: ChallengeTaskWhereInput[]
    NOT?: ChallengeTaskWhereInput | ChallengeTaskWhereInput[]
    id?: StringFilter<"ChallengeTask"> | string
    challengeId?: StringFilter<"ChallengeTask"> | string
    dayNumber?: IntFilter<"ChallengeTask"> | number
    title?: StringFilter<"ChallengeTask"> | string
    description?: StringNullableFilter<"ChallengeTask"> | string | null
    taskType?: StringFilter<"ChallengeTask"> | string
    content?: JsonNullableFilter<"ChallengeTask">
    resourceLinks?: JsonNullableFilter<"ChallengeTask">
    hints?: JsonNullableFilter<"ChallengeTask">
    difficulty?: StringNullableFilter<"ChallengeTask"> | string | null
    points?: IntFilter<"ChallengeTask"> | number
    autoValidate?: BoolFilter<"ChallengeTask"> | boolean
    validationUrl?: StringNullableFilter<"ChallengeTask"> | string | null
    createdAt?: DateTimeFilter<"ChallengeTask"> | Date | string
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
    completions?: UserTaskCompletionListRelationFilter
  }

  export type ChallengeTaskOrderByWithRelationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    taskType?: SortOrder
    content?: SortOrderInput | SortOrder
    resourceLinks?: SortOrderInput | SortOrder
    hints?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    points?: SortOrder
    autoValidate?: SortOrder
    validationUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    challenge?: ChallengeOrderByWithRelationInput
    completions?: UserTaskCompletionOrderByRelationAggregateInput
  }

  export type ChallengeTaskWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    challengeId_dayNumber?: ChallengeTaskChallengeIdDayNumberCompoundUniqueInput
    AND?: ChallengeTaskWhereInput | ChallengeTaskWhereInput[]
    OR?: ChallengeTaskWhereInput[]
    NOT?: ChallengeTaskWhereInput | ChallengeTaskWhereInput[]
    challengeId?: StringFilter<"ChallengeTask"> | string
    dayNumber?: IntFilter<"ChallengeTask"> | number
    title?: StringFilter<"ChallengeTask"> | string
    description?: StringNullableFilter<"ChallengeTask"> | string | null
    taskType?: StringFilter<"ChallengeTask"> | string
    content?: JsonNullableFilter<"ChallengeTask">
    resourceLinks?: JsonNullableFilter<"ChallengeTask">
    hints?: JsonNullableFilter<"ChallengeTask">
    difficulty?: StringNullableFilter<"ChallengeTask"> | string | null
    points?: IntFilter<"ChallengeTask"> | number
    autoValidate?: BoolFilter<"ChallengeTask"> | boolean
    validationUrl?: StringNullableFilter<"ChallengeTask"> | string | null
    createdAt?: DateTimeFilter<"ChallengeTask"> | Date | string
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
    completions?: UserTaskCompletionListRelationFilter
  }, "id" | "challengeId_dayNumber">

  export type ChallengeTaskOrderByWithAggregationInput = {
    id?: SortOrder
    challengeId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    taskType?: SortOrder
    content?: SortOrderInput | SortOrder
    resourceLinks?: SortOrderInput | SortOrder
    hints?: SortOrderInput | SortOrder
    difficulty?: SortOrderInput | SortOrder
    points?: SortOrder
    autoValidate?: SortOrder
    validationUrl?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ChallengeTaskCountOrderByAggregateInput
    _avg?: ChallengeTaskAvgOrderByAggregateInput
    _max?: ChallengeTaskMaxOrderByAggregateInput
    _min?: ChallengeTaskMinOrderByAggregateInput
    _sum?: ChallengeTaskSumOrderByAggregateInput
  }

  export type ChallengeTaskScalarWhereWithAggregatesInput = {
    AND?: ChallengeTaskScalarWhereWithAggregatesInput | ChallengeTaskScalarWhereWithAggregatesInput[]
    OR?: ChallengeTaskScalarWhereWithAggregatesInput[]
    NOT?: ChallengeTaskScalarWhereWithAggregatesInput | ChallengeTaskScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ChallengeTask"> | string
    challengeId?: StringWithAggregatesFilter<"ChallengeTask"> | string
    dayNumber?: IntWithAggregatesFilter<"ChallengeTask"> | number
    title?: StringWithAggregatesFilter<"ChallengeTask"> | string
    description?: StringNullableWithAggregatesFilter<"ChallengeTask"> | string | null
    taskType?: StringWithAggregatesFilter<"ChallengeTask"> | string
    content?: JsonNullableWithAggregatesFilter<"ChallengeTask">
    resourceLinks?: JsonNullableWithAggregatesFilter<"ChallengeTask">
    hints?: JsonNullableWithAggregatesFilter<"ChallengeTask">
    difficulty?: StringNullableWithAggregatesFilter<"ChallengeTask"> | string | null
    points?: IntWithAggregatesFilter<"ChallengeTask"> | number
    autoValidate?: BoolWithAggregatesFilter<"ChallengeTask"> | boolean
    validationUrl?: StringNullableWithAggregatesFilter<"ChallengeTask"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ChallengeTask"> | Date | string
  }

  export type UserChallengeProgressWhereInput = {
    AND?: UserChallengeProgressWhereInput | UserChallengeProgressWhereInput[]
    OR?: UserChallengeProgressWhereInput[]
    NOT?: UserChallengeProgressWhereInput | UserChallengeProgressWhereInput[]
    id?: StringFilter<"UserChallengeProgress"> | string
    userId?: StringFilter<"UserChallengeProgress"> | string
    challengeId?: StringFilter<"UserChallengeProgress"> | string
    status?: StringFilter<"UserChallengeProgress"> | string
    completedDays?: IntFilter<"UserChallengeProgress"> | number
    totalDays?: IntFilter<"UserChallengeProgress"> | number
    completionPercentage?: DecimalFilter<"UserChallengeProgress"> | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFilter<"UserChallengeProgress"> | number
    longestStreak?: IntFilter<"UserChallengeProgress"> | number
    lastCompletedDate?: DateTimeNullableFilter<"UserChallengeProgress"> | Date | string | null
    totalPoints?: IntFilter<"UserChallengeProgress"> | number
    bonusPoints?: IntFilter<"UserChallengeProgress"> | number
    currentRank?: IntNullableFilter<"UserChallengeProgress"> | number | null
    startedAt?: DateTimeFilter<"UserChallengeProgress"> | Date | string
    lastActivity?: DateTimeFilter<"UserChallengeProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserChallengeProgress"> | Date | string | null
    certificateIssued?: BoolFilter<"UserChallengeProgress"> | boolean
    certificateUrl?: StringNullableFilter<"UserChallengeProgress"> | string | null
    completedTaskIds?: JsonNullableFilter<"UserChallengeProgress">
    skippedTaskIds?: JsonNullableFilter<"UserChallengeProgress">
    user?: XOR<UserRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
    taskCompletions?: UserTaskCompletionListRelationFilter
  }

  export type UserChallengeProgressOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    status?: SortOrder
    completedDays?: SortOrder
    totalDays?: SortOrder
    completionPercentage?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrderInput | SortOrder
    totalPoints?: SortOrder
    bonusPoints?: SortOrder
    currentRank?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    lastActivity?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    certificateIssued?: SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    completedTaskIds?: SortOrderInput | SortOrder
    skippedTaskIds?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    challenge?: ChallengeOrderByWithRelationInput
    taskCompletions?: UserTaskCompletionOrderByRelationAggregateInput
  }

  export type UserChallengeProgressWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_challengeId?: UserChallengeProgressUserIdChallengeIdCompoundUniqueInput
    AND?: UserChallengeProgressWhereInput | UserChallengeProgressWhereInput[]
    OR?: UserChallengeProgressWhereInput[]
    NOT?: UserChallengeProgressWhereInput | UserChallengeProgressWhereInput[]
    userId?: StringFilter<"UserChallengeProgress"> | string
    challengeId?: StringFilter<"UserChallengeProgress"> | string
    status?: StringFilter<"UserChallengeProgress"> | string
    completedDays?: IntFilter<"UserChallengeProgress"> | number
    totalDays?: IntFilter<"UserChallengeProgress"> | number
    completionPercentage?: DecimalFilter<"UserChallengeProgress"> | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFilter<"UserChallengeProgress"> | number
    longestStreak?: IntFilter<"UserChallengeProgress"> | number
    lastCompletedDate?: DateTimeNullableFilter<"UserChallengeProgress"> | Date | string | null
    totalPoints?: IntFilter<"UserChallengeProgress"> | number
    bonusPoints?: IntFilter<"UserChallengeProgress"> | number
    currentRank?: IntNullableFilter<"UserChallengeProgress"> | number | null
    startedAt?: DateTimeFilter<"UserChallengeProgress"> | Date | string
    lastActivity?: DateTimeFilter<"UserChallengeProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserChallengeProgress"> | Date | string | null
    certificateIssued?: BoolFilter<"UserChallengeProgress"> | boolean
    certificateUrl?: StringNullableFilter<"UserChallengeProgress"> | string | null
    completedTaskIds?: JsonNullableFilter<"UserChallengeProgress">
    skippedTaskIds?: JsonNullableFilter<"UserChallengeProgress">
    user?: XOR<UserRelationFilter, UserWhereInput>
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
    taskCompletions?: UserTaskCompletionListRelationFilter
  }, "id" | "userId_challengeId">

  export type UserChallengeProgressOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    status?: SortOrder
    completedDays?: SortOrder
    totalDays?: SortOrder
    completionPercentage?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrderInput | SortOrder
    totalPoints?: SortOrder
    bonusPoints?: SortOrder
    currentRank?: SortOrderInput | SortOrder
    startedAt?: SortOrder
    lastActivity?: SortOrder
    completedAt?: SortOrderInput | SortOrder
    certificateIssued?: SortOrder
    certificateUrl?: SortOrderInput | SortOrder
    completedTaskIds?: SortOrderInput | SortOrder
    skippedTaskIds?: SortOrderInput | SortOrder
    _count?: UserChallengeProgressCountOrderByAggregateInput
    _avg?: UserChallengeProgressAvgOrderByAggregateInput
    _max?: UserChallengeProgressMaxOrderByAggregateInput
    _min?: UserChallengeProgressMinOrderByAggregateInput
    _sum?: UserChallengeProgressSumOrderByAggregateInput
  }

  export type UserChallengeProgressScalarWhereWithAggregatesInput = {
    AND?: UserChallengeProgressScalarWhereWithAggregatesInput | UserChallengeProgressScalarWhereWithAggregatesInput[]
    OR?: UserChallengeProgressScalarWhereWithAggregatesInput[]
    NOT?: UserChallengeProgressScalarWhereWithAggregatesInput | UserChallengeProgressScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserChallengeProgress"> | string
    userId?: StringWithAggregatesFilter<"UserChallengeProgress"> | string
    challengeId?: StringWithAggregatesFilter<"UserChallengeProgress"> | string
    status?: StringWithAggregatesFilter<"UserChallengeProgress"> | string
    completedDays?: IntWithAggregatesFilter<"UserChallengeProgress"> | number
    totalDays?: IntWithAggregatesFilter<"UserChallengeProgress"> | number
    completionPercentage?: DecimalWithAggregatesFilter<"UserChallengeProgress"> | Decimal | DecimalJsLike | number | string
    currentStreak?: IntWithAggregatesFilter<"UserChallengeProgress"> | number
    longestStreak?: IntWithAggregatesFilter<"UserChallengeProgress"> | number
    lastCompletedDate?: DateTimeNullableWithAggregatesFilter<"UserChallengeProgress"> | Date | string | null
    totalPoints?: IntWithAggregatesFilter<"UserChallengeProgress"> | number
    bonusPoints?: IntWithAggregatesFilter<"UserChallengeProgress"> | number
    currentRank?: IntNullableWithAggregatesFilter<"UserChallengeProgress"> | number | null
    startedAt?: DateTimeWithAggregatesFilter<"UserChallengeProgress"> | Date | string
    lastActivity?: DateTimeWithAggregatesFilter<"UserChallengeProgress"> | Date | string
    completedAt?: DateTimeNullableWithAggregatesFilter<"UserChallengeProgress"> | Date | string | null
    certificateIssued?: BoolWithAggregatesFilter<"UserChallengeProgress"> | boolean
    certificateUrl?: StringNullableWithAggregatesFilter<"UserChallengeProgress"> | string | null
    completedTaskIds?: JsonNullableWithAggregatesFilter<"UserChallengeProgress">
    skippedTaskIds?: JsonNullableWithAggregatesFilter<"UserChallengeProgress">
  }

  export type UserTaskCompletionWhereInput = {
    AND?: UserTaskCompletionWhereInput | UserTaskCompletionWhereInput[]
    OR?: UserTaskCompletionWhereInput[]
    NOT?: UserTaskCompletionWhereInput | UserTaskCompletionWhereInput[]
    id?: StringFilter<"UserTaskCompletion"> | string
    userId?: StringFilter<"UserTaskCompletion"> | string
    challengeId?: StringFilter<"UserTaskCompletion"> | string
    taskId?: StringFilter<"UserTaskCompletion"> | string
    progressId?: StringFilter<"UserTaskCompletion"> | string
    completedAt?: DateTimeFilter<"UserTaskCompletion"> | Date | string
    timeTaken?: IntNullableFilter<"UserTaskCompletion"> | number | null
    submissionUrl?: StringNullableFilter<"UserTaskCompletion"> | string | null
    submissionText?: StringNullableFilter<"UserTaskCompletion"> | string | null
    submissionFiles?: JsonNullableFilter<"UserTaskCompletion">
    isVerified?: BoolFilter<"UserTaskCompletion"> | boolean
    verifiedBy?: StringNullableFilter<"UserTaskCompletion"> | string | null
    verifiedAt?: DateTimeNullableFilter<"UserTaskCompletion"> | Date | string | null
    score?: DecimalNullableFilter<"UserTaskCompletion"> | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: IntNullableFilter<"UserTaskCompletion"> | number | null
    userNotes?: StringNullableFilter<"UserTaskCompletion"> | string | null
    feedback?: StringNullableFilter<"UserTaskCompletion"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    task?: XOR<ChallengeTaskRelationFilter, ChallengeTaskWhereInput>
    progress?: XOR<UserChallengeProgressRelationFilter, UserChallengeProgressWhereInput>
  }

  export type UserTaskCompletionOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    taskId?: SortOrder
    progressId?: SortOrder
    completedAt?: SortOrder
    timeTaken?: SortOrderInput | SortOrder
    submissionUrl?: SortOrderInput | SortOrder
    submissionText?: SortOrderInput | SortOrder
    submissionFiles?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    pointsEarned?: SortOrderInput | SortOrder
    userNotes?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    user?: UserOrderByWithRelationInput
    task?: ChallengeTaskOrderByWithRelationInput
    progress?: UserChallengeProgressOrderByWithRelationInput
  }

  export type UserTaskCompletionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_taskId?: UserTaskCompletionUserIdTaskIdCompoundUniqueInput
    AND?: UserTaskCompletionWhereInput | UserTaskCompletionWhereInput[]
    OR?: UserTaskCompletionWhereInput[]
    NOT?: UserTaskCompletionWhereInput | UserTaskCompletionWhereInput[]
    userId?: StringFilter<"UserTaskCompletion"> | string
    challengeId?: StringFilter<"UserTaskCompletion"> | string
    taskId?: StringFilter<"UserTaskCompletion"> | string
    progressId?: StringFilter<"UserTaskCompletion"> | string
    completedAt?: DateTimeFilter<"UserTaskCompletion"> | Date | string
    timeTaken?: IntNullableFilter<"UserTaskCompletion"> | number | null
    submissionUrl?: StringNullableFilter<"UserTaskCompletion"> | string | null
    submissionText?: StringNullableFilter<"UserTaskCompletion"> | string | null
    submissionFiles?: JsonNullableFilter<"UserTaskCompletion">
    isVerified?: BoolFilter<"UserTaskCompletion"> | boolean
    verifiedBy?: StringNullableFilter<"UserTaskCompletion"> | string | null
    verifiedAt?: DateTimeNullableFilter<"UserTaskCompletion"> | Date | string | null
    score?: DecimalNullableFilter<"UserTaskCompletion"> | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: IntNullableFilter<"UserTaskCompletion"> | number | null
    userNotes?: StringNullableFilter<"UserTaskCompletion"> | string | null
    feedback?: StringNullableFilter<"UserTaskCompletion"> | string | null
    user?: XOR<UserRelationFilter, UserWhereInput>
    task?: XOR<ChallengeTaskRelationFilter, ChallengeTaskWhereInput>
    progress?: XOR<UserChallengeProgressRelationFilter, UserChallengeProgressWhereInput>
  }, "id" | "userId_taskId">

  export type UserTaskCompletionOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    taskId?: SortOrder
    progressId?: SortOrder
    completedAt?: SortOrder
    timeTaken?: SortOrderInput | SortOrder
    submissionUrl?: SortOrderInput | SortOrder
    submissionText?: SortOrderInput | SortOrder
    submissionFiles?: SortOrderInput | SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrderInput | SortOrder
    verifiedAt?: SortOrderInput | SortOrder
    score?: SortOrderInput | SortOrder
    pointsEarned?: SortOrderInput | SortOrder
    userNotes?: SortOrderInput | SortOrder
    feedback?: SortOrderInput | SortOrder
    _count?: UserTaskCompletionCountOrderByAggregateInput
    _avg?: UserTaskCompletionAvgOrderByAggregateInput
    _max?: UserTaskCompletionMaxOrderByAggregateInput
    _min?: UserTaskCompletionMinOrderByAggregateInput
    _sum?: UserTaskCompletionSumOrderByAggregateInput
  }

  export type UserTaskCompletionScalarWhereWithAggregatesInput = {
    AND?: UserTaskCompletionScalarWhereWithAggregatesInput | UserTaskCompletionScalarWhereWithAggregatesInput[]
    OR?: UserTaskCompletionScalarWhereWithAggregatesInput[]
    NOT?: UserTaskCompletionScalarWhereWithAggregatesInput | UserTaskCompletionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserTaskCompletion"> | string
    userId?: StringWithAggregatesFilter<"UserTaskCompletion"> | string
    challengeId?: StringWithAggregatesFilter<"UserTaskCompletion"> | string
    taskId?: StringWithAggregatesFilter<"UserTaskCompletion"> | string
    progressId?: StringWithAggregatesFilter<"UserTaskCompletion"> | string
    completedAt?: DateTimeWithAggregatesFilter<"UserTaskCompletion"> | Date | string
    timeTaken?: IntNullableWithAggregatesFilter<"UserTaskCompletion"> | number | null
    submissionUrl?: StringNullableWithAggregatesFilter<"UserTaskCompletion"> | string | null
    submissionText?: StringNullableWithAggregatesFilter<"UserTaskCompletion"> | string | null
    submissionFiles?: JsonNullableWithAggregatesFilter<"UserTaskCompletion">
    isVerified?: BoolWithAggregatesFilter<"UserTaskCompletion"> | boolean
    verifiedBy?: StringNullableWithAggregatesFilter<"UserTaskCompletion"> | string | null
    verifiedAt?: DateTimeNullableWithAggregatesFilter<"UserTaskCompletion"> | Date | string | null
    score?: DecimalNullableWithAggregatesFilter<"UserTaskCompletion"> | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: IntNullableWithAggregatesFilter<"UserTaskCompletion"> | number | null
    userNotes?: StringNullableWithAggregatesFilter<"UserTaskCompletion"> | string | null
    feedback?: StringNullableWithAggregatesFilter<"UserTaskCompletion"> | string | null
  }

  export type UserBadgeWhereInput = {
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    userId?: StringFilter<"UserBadge"> | string
    badgeType?: StringFilter<"UserBadge"> | string
    badgeName?: StringFilter<"UserBadge"> | string
    badgeDescription?: StringNullableFilter<"UserBadge"> | string | null
    badgeIcon?: StringNullableFilter<"UserBadge"> | string | null
    badgeColor?: StringNullableFilter<"UserBadge"> | string | null
    relatedChallengeId?: StringNullableFilter<"UserBadge"> | string | null
    relatedEventId?: StringNullableFilter<"UserBadge"> | string | null
    pointsAwarded?: IntFilter<"UserBadge"> | number
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserBadgeOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeType?: SortOrder
    badgeName?: SortOrder
    badgeDescription?: SortOrderInput | SortOrder
    badgeIcon?: SortOrderInput | SortOrder
    badgeColor?: SortOrderInput | SortOrder
    relatedChallengeId?: SortOrderInput | SortOrder
    relatedEventId?: SortOrderInput | SortOrder
    pointsAwarded?: SortOrder
    earnedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserBadgeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: UserBadgeWhereInput | UserBadgeWhereInput[]
    OR?: UserBadgeWhereInput[]
    NOT?: UserBadgeWhereInput | UserBadgeWhereInput[]
    userId?: StringFilter<"UserBadge"> | string
    badgeType?: StringFilter<"UserBadge"> | string
    badgeName?: StringFilter<"UserBadge"> | string
    badgeDescription?: StringNullableFilter<"UserBadge"> | string | null
    badgeIcon?: StringNullableFilter<"UserBadge"> | string | null
    badgeColor?: StringNullableFilter<"UserBadge"> | string | null
    relatedChallengeId?: StringNullableFilter<"UserBadge"> | string | null
    relatedEventId?: StringNullableFilter<"UserBadge"> | string | null
    pointsAwarded?: IntFilter<"UserBadge"> | number
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type UserBadgeOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeType?: SortOrder
    badgeName?: SortOrder
    badgeDescription?: SortOrderInput | SortOrder
    badgeIcon?: SortOrderInput | SortOrder
    badgeColor?: SortOrderInput | SortOrder
    relatedChallengeId?: SortOrderInput | SortOrder
    relatedEventId?: SortOrderInput | SortOrder
    pointsAwarded?: SortOrder
    earnedAt?: SortOrder
    _count?: UserBadgeCountOrderByAggregateInput
    _avg?: UserBadgeAvgOrderByAggregateInput
    _max?: UserBadgeMaxOrderByAggregateInput
    _min?: UserBadgeMinOrderByAggregateInput
    _sum?: UserBadgeSumOrderByAggregateInput
  }

  export type UserBadgeScalarWhereWithAggregatesInput = {
    AND?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    OR?: UserBadgeScalarWhereWithAggregatesInput[]
    NOT?: UserBadgeScalarWhereWithAggregatesInput | UserBadgeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserBadge"> | string
    userId?: StringWithAggregatesFilter<"UserBadge"> | string
    badgeType?: StringWithAggregatesFilter<"UserBadge"> | string
    badgeName?: StringWithAggregatesFilter<"UserBadge"> | string
    badgeDescription?: StringNullableWithAggregatesFilter<"UserBadge"> | string | null
    badgeIcon?: StringNullableWithAggregatesFilter<"UserBadge"> | string | null
    badgeColor?: StringNullableWithAggregatesFilter<"UserBadge"> | string | null
    relatedChallengeId?: StringNullableWithAggregatesFilter<"UserBadge"> | string | null
    relatedEventId?: StringNullableWithAggregatesFilter<"UserBadge"> | string | null
    pointsAwarded?: IntWithAggregatesFilter<"UserBadge"> | number
    earnedAt?: DateTimeWithAggregatesFilter<"UserBadge"> | Date | string
  }

  export type UserAchievementWhereInput = {
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementType?: StringFilter<"UserAchievement"> | string
    achievementName?: StringFilter<"UserAchievement"> | string
    description?: StringNullableFilter<"UserAchievement"> | string | null
    value?: IntNullableFilter<"UserAchievement"> | number | null
    target?: IntNullableFilter<"UserAchievement"> | number | null
    rarity?: StringNullableFilter<"UserAchievement"> | string | null
    earnedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type UserAchievementOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementType?: SortOrder
    achievementName?: SortOrder
    description?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    rarity?: SortOrderInput | SortOrder
    earnedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type UserAchievementWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_achievementType?: UserAchievementUserIdAchievementTypeCompoundUniqueInput
    AND?: UserAchievementWhereInput | UserAchievementWhereInput[]
    OR?: UserAchievementWhereInput[]
    NOT?: UserAchievementWhereInput | UserAchievementWhereInput[]
    userId?: StringFilter<"UserAchievement"> | string
    achievementType?: StringFilter<"UserAchievement"> | string
    achievementName?: StringFilter<"UserAchievement"> | string
    description?: StringNullableFilter<"UserAchievement"> | string | null
    value?: IntNullableFilter<"UserAchievement"> | number | null
    target?: IntNullableFilter<"UserAchievement"> | number | null
    rarity?: StringNullableFilter<"UserAchievement"> | string | null
    earnedAt?: DateTimeFilter<"UserAchievement"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_achievementType">

  export type UserAchievementOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementType?: SortOrder
    achievementName?: SortOrder
    description?: SortOrderInput | SortOrder
    value?: SortOrderInput | SortOrder
    target?: SortOrderInput | SortOrder
    rarity?: SortOrderInput | SortOrder
    earnedAt?: SortOrder
    _count?: UserAchievementCountOrderByAggregateInput
    _avg?: UserAchievementAvgOrderByAggregateInput
    _max?: UserAchievementMaxOrderByAggregateInput
    _min?: UserAchievementMinOrderByAggregateInput
    _sum?: UserAchievementSumOrderByAggregateInput
  }

  export type UserAchievementScalarWhereWithAggregatesInput = {
    AND?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    OR?: UserAchievementScalarWhereWithAggregatesInput[]
    NOT?: UserAchievementScalarWhereWithAggregatesInput | UserAchievementScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"UserAchievement"> | string
    userId?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementType?: StringWithAggregatesFilter<"UserAchievement"> | string
    achievementName?: StringWithAggregatesFilter<"UserAchievement"> | string
    description?: StringNullableWithAggregatesFilter<"UserAchievement"> | string | null
    value?: IntNullableWithAggregatesFilter<"UserAchievement"> | number | null
    target?: IntNullableWithAggregatesFilter<"UserAchievement"> | number | null
    rarity?: StringNullableWithAggregatesFilter<"UserAchievement"> | string | null
    earnedAt?: DateTimeWithAggregatesFilter<"UserAchievement"> | Date | string
  }

  export type LeaderboardWhereInput = {
    AND?: LeaderboardWhereInput | LeaderboardWhereInput[]
    OR?: LeaderboardWhereInput[]
    NOT?: LeaderboardWhereInput | LeaderboardWhereInput[]
    id?: StringFilter<"Leaderboard"> | string
    userId?: StringFilter<"Leaderboard"> | string
    leaderboardType?: StringFilter<"Leaderboard"> | string
    relatedId?: StringNullableFilter<"Leaderboard"> | string | null
    timePeriod?: StringNullableFilter<"Leaderboard"> | string | null
    score?: IntFilter<"Leaderboard"> | number
    rank?: IntNullableFilter<"Leaderboard"> | number | null
    previousRank?: IntNullableFilter<"Leaderboard"> | number | null
    totalCompletions?: IntFilter<"Leaderboard"> | number
    currentStreak?: IntFilter<"Leaderboard"> | number
    updatedAt?: DateTimeFilter<"Leaderboard"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type LeaderboardOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrder
    leaderboardType?: SortOrder
    relatedId?: SortOrderInput | SortOrder
    timePeriod?: SortOrderInput | SortOrder
    score?: SortOrder
    rank?: SortOrderInput | SortOrder
    previousRank?: SortOrderInput | SortOrder
    totalCompletions?: SortOrder
    currentStreak?: SortOrder
    updatedAt?: SortOrder
    user?: UserOrderByWithRelationInput
  }

  export type LeaderboardWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    userId_leaderboardType_relatedId_timePeriod?: LeaderboardUserIdLeaderboardTypeRelatedIdTimePeriodCompoundUniqueInput
    AND?: LeaderboardWhereInput | LeaderboardWhereInput[]
    OR?: LeaderboardWhereInput[]
    NOT?: LeaderboardWhereInput | LeaderboardWhereInput[]
    userId?: StringFilter<"Leaderboard"> | string
    leaderboardType?: StringFilter<"Leaderboard"> | string
    relatedId?: StringNullableFilter<"Leaderboard"> | string | null
    timePeriod?: StringNullableFilter<"Leaderboard"> | string | null
    score?: IntFilter<"Leaderboard"> | number
    rank?: IntNullableFilter<"Leaderboard"> | number | null
    previousRank?: IntNullableFilter<"Leaderboard"> | number | null
    totalCompletions?: IntFilter<"Leaderboard"> | number
    currentStreak?: IntFilter<"Leaderboard"> | number
    updatedAt?: DateTimeFilter<"Leaderboard"> | Date | string
    user?: XOR<UserRelationFilter, UserWhereInput>
  }, "id" | "userId_leaderboardType_relatedId_timePeriod">

  export type LeaderboardOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrder
    leaderboardType?: SortOrder
    relatedId?: SortOrderInput | SortOrder
    timePeriod?: SortOrderInput | SortOrder
    score?: SortOrder
    rank?: SortOrderInput | SortOrder
    previousRank?: SortOrderInput | SortOrder
    totalCompletions?: SortOrder
    currentStreak?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaderboardCountOrderByAggregateInput
    _avg?: LeaderboardAvgOrderByAggregateInput
    _max?: LeaderboardMaxOrderByAggregateInput
    _min?: LeaderboardMinOrderByAggregateInput
    _sum?: LeaderboardSumOrderByAggregateInput
  }

  export type LeaderboardScalarWhereWithAggregatesInput = {
    AND?: LeaderboardScalarWhereWithAggregatesInput | LeaderboardScalarWhereWithAggregatesInput[]
    OR?: LeaderboardScalarWhereWithAggregatesInput[]
    NOT?: LeaderboardScalarWhereWithAggregatesInput | LeaderboardScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Leaderboard"> | string
    userId?: StringWithAggregatesFilter<"Leaderboard"> | string
    leaderboardType?: StringWithAggregatesFilter<"Leaderboard"> | string
    relatedId?: StringNullableWithAggregatesFilter<"Leaderboard"> | string | null
    timePeriod?: StringNullableWithAggregatesFilter<"Leaderboard"> | string | null
    score?: IntWithAggregatesFilter<"Leaderboard"> | number
    rank?: IntNullableWithAggregatesFilter<"Leaderboard"> | number | null
    previousRank?: IntNullableWithAggregatesFilter<"Leaderboard"> | number | null
    totalCompletions?: IntWithAggregatesFilter<"Leaderboard"> | number
    currentStreak?: IntWithAggregatesFilter<"Leaderboard"> | number
    updatedAt?: DateTimeWithAggregatesFilter<"Leaderboard"> | Date | string
  }

  export type EventChallengeWhereInput = {
    AND?: EventChallengeWhereInput | EventChallengeWhereInput[]
    OR?: EventChallengeWhereInput[]
    NOT?: EventChallengeWhereInput | EventChallengeWhereInput[]
    eventId?: StringFilter<"EventChallenge"> | string
    challengeId?: StringFilter<"EventChallenge"> | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
  }

  export type EventChallengeOrderByWithRelationInput = {
    eventId?: SortOrder
    challengeId?: SortOrder
    event?: EventOrderByWithRelationInput
    challenge?: ChallengeOrderByWithRelationInput
  }

  export type EventChallengeWhereUniqueInput = Prisma.AtLeast<{
    eventId_challengeId?: EventChallengeEventIdChallengeIdCompoundUniqueInput
    AND?: EventChallengeWhereInput | EventChallengeWhereInput[]
    OR?: EventChallengeWhereInput[]
    NOT?: EventChallengeWhereInput | EventChallengeWhereInput[]
    eventId?: StringFilter<"EventChallenge"> | string
    challengeId?: StringFilter<"EventChallenge"> | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    challenge?: XOR<ChallengeRelationFilter, ChallengeWhereInput>
  }, "eventId_challengeId">

  export type EventChallengeOrderByWithAggregationInput = {
    eventId?: SortOrder
    challengeId?: SortOrder
    _count?: EventChallengeCountOrderByAggregateInput
    _max?: EventChallengeMaxOrderByAggregateInput
    _min?: EventChallengeMinOrderByAggregateInput
  }

  export type EventChallengeScalarWhereWithAggregatesInput = {
    AND?: EventChallengeScalarWhereWithAggregatesInput | EventChallengeScalarWhereWithAggregatesInput[]
    OR?: EventChallengeScalarWhereWithAggregatesInput[]
    NOT?: EventChallengeScalarWhereWithAggregatesInput | EventChallengeScalarWhereWithAggregatesInput[]
    eventId?: StringWithAggregatesFilter<"EventChallenge"> | string
    challengeId?: StringWithAggregatesFilter<"EventChallenge"> | string
  }

  export type RoadmapWhereInput = {
    AND?: RoadmapWhereInput | RoadmapWhereInput[]
    OR?: RoadmapWhereInput[]
    NOT?: RoadmapWhereInput | RoadmapWhereInput[]
    id?: StringFilter<"Roadmap"> | string
    title?: StringFilter<"Roadmap"> | string
    description?: StringFilter<"Roadmap"> | string
    roleTarget?: StringFilter<"Roadmap"> | string
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    phases?: RoadmapPhaseListRelationFilter
    events?: EventListRelationFilter
  }

  export type RoadmapOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    roleTarget?: SortOrder
    createdAt?: SortOrder
    phases?: RoadmapPhaseOrderByRelationAggregateInput
    events?: EventOrderByRelationAggregateInput
  }

  export type RoadmapWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadmapWhereInput | RoadmapWhereInput[]
    OR?: RoadmapWhereInput[]
    NOT?: RoadmapWhereInput | RoadmapWhereInput[]
    title?: StringFilter<"Roadmap"> | string
    description?: StringFilter<"Roadmap"> | string
    roleTarget?: StringFilter<"Roadmap"> | string
    createdAt?: DateTimeFilter<"Roadmap"> | Date | string
    phases?: RoadmapPhaseListRelationFilter
    events?: EventListRelationFilter
  }, "id">

  export type RoadmapOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    roleTarget?: SortOrder
    createdAt?: SortOrder
    _count?: RoadmapCountOrderByAggregateInput
    _max?: RoadmapMaxOrderByAggregateInput
    _min?: RoadmapMinOrderByAggregateInput
  }

  export type RoadmapScalarWhereWithAggregatesInput = {
    AND?: RoadmapScalarWhereWithAggregatesInput | RoadmapScalarWhereWithAggregatesInput[]
    OR?: RoadmapScalarWhereWithAggregatesInput[]
    NOT?: RoadmapScalarWhereWithAggregatesInput | RoadmapScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Roadmap"> | string
    title?: StringWithAggregatesFilter<"Roadmap"> | string
    description?: StringWithAggregatesFilter<"Roadmap"> | string
    roleTarget?: StringWithAggregatesFilter<"Roadmap"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Roadmap"> | Date | string
  }

  export type RoadmapPhaseWhereInput = {
    AND?: RoadmapPhaseWhereInput | RoadmapPhaseWhereInput[]
    OR?: RoadmapPhaseWhereInput[]
    NOT?: RoadmapPhaseWhereInput | RoadmapPhaseWhereInput[]
    id?: StringFilter<"RoadmapPhase"> | string
    roadmapId?: StringFilter<"RoadmapPhase"> | string
    order?: IntFilter<"RoadmapPhase"> | number
    title?: StringFilter<"RoadmapPhase"> | string
    level?: StringNullableFilter<"RoadmapPhase"> | string | null
    duration?: StringNullableFilter<"RoadmapPhase"> | string | null
    description?: StringNullableFilter<"RoadmapPhase"> | string | null
    roadmap?: XOR<RoadmapRelationFilter, RoadmapWhereInput>
    sections?: PhaseSectionListRelationFilter
    playlists?: PhasePlaylistListRelationFilter
    projects?: PhaseProjectListRelationFilter
  }

  export type RoadmapPhaseOrderByWithRelationInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    level?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    roadmap?: RoadmapOrderByWithRelationInput
    sections?: PhaseSectionOrderByRelationAggregateInput
    playlists?: PhasePlaylistOrderByRelationAggregateInput
    projects?: PhaseProjectOrderByRelationAggregateInput
  }

  export type RoadmapPhaseWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: RoadmapPhaseWhereInput | RoadmapPhaseWhereInput[]
    OR?: RoadmapPhaseWhereInput[]
    NOT?: RoadmapPhaseWhereInput | RoadmapPhaseWhereInput[]
    roadmapId?: StringFilter<"RoadmapPhase"> | string
    order?: IntFilter<"RoadmapPhase"> | number
    title?: StringFilter<"RoadmapPhase"> | string
    level?: StringNullableFilter<"RoadmapPhase"> | string | null
    duration?: StringNullableFilter<"RoadmapPhase"> | string | null
    description?: StringNullableFilter<"RoadmapPhase"> | string | null
    roadmap?: XOR<RoadmapRelationFilter, RoadmapWhereInput>
    sections?: PhaseSectionListRelationFilter
    playlists?: PhasePlaylistListRelationFilter
    projects?: PhaseProjectListRelationFilter
  }, "id">

  export type RoadmapPhaseOrderByWithAggregationInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    level?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    _count?: RoadmapPhaseCountOrderByAggregateInput
    _avg?: RoadmapPhaseAvgOrderByAggregateInput
    _max?: RoadmapPhaseMaxOrderByAggregateInput
    _min?: RoadmapPhaseMinOrderByAggregateInput
    _sum?: RoadmapPhaseSumOrderByAggregateInput
  }

  export type RoadmapPhaseScalarWhereWithAggregatesInput = {
    AND?: RoadmapPhaseScalarWhereWithAggregatesInput | RoadmapPhaseScalarWhereWithAggregatesInput[]
    OR?: RoadmapPhaseScalarWhereWithAggregatesInput[]
    NOT?: RoadmapPhaseScalarWhereWithAggregatesInput | RoadmapPhaseScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"RoadmapPhase"> | string
    roadmapId?: StringWithAggregatesFilter<"RoadmapPhase"> | string
    order?: IntWithAggregatesFilter<"RoadmapPhase"> | number
    title?: StringWithAggregatesFilter<"RoadmapPhase"> | string
    level?: StringNullableWithAggregatesFilter<"RoadmapPhase"> | string | null
    duration?: StringNullableWithAggregatesFilter<"RoadmapPhase"> | string | null
    description?: StringNullableWithAggregatesFilter<"RoadmapPhase"> | string | null
  }

  export type PhaseSectionWhereInput = {
    AND?: PhaseSectionWhereInput | PhaseSectionWhereInput[]
    OR?: PhaseSectionWhereInput[]
    NOT?: PhaseSectionWhereInput | PhaseSectionWhereInput[]
    id?: StringFilter<"PhaseSection"> | string
    phaseId?: StringFilter<"PhaseSection"> | string
    title?: StringFilter<"PhaseSection"> | string
    description?: StringNullableFilter<"PhaseSection"> | string | null
    order?: IntFilter<"PhaseSection"> | number
    phase?: XOR<RoadmapPhaseRelationFilter, RoadmapPhaseWhereInput>
    items?: SectionItemListRelationFilter
  }

  export type PhaseSectionOrderByWithRelationInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    phase?: RoadmapPhaseOrderByWithRelationInput
    items?: SectionItemOrderByRelationAggregateInput
  }

  export type PhaseSectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhaseSectionWhereInput | PhaseSectionWhereInput[]
    OR?: PhaseSectionWhereInput[]
    NOT?: PhaseSectionWhereInput | PhaseSectionWhereInput[]
    phaseId?: StringFilter<"PhaseSection"> | string
    title?: StringFilter<"PhaseSection"> | string
    description?: StringNullableFilter<"PhaseSection"> | string | null
    order?: IntFilter<"PhaseSection"> | number
    phase?: XOR<RoadmapPhaseRelationFilter, RoadmapPhaseWhereInput>
    items?: SectionItemListRelationFilter
  }, "id">

  export type PhaseSectionOrderByWithAggregationInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    order?: SortOrder
    _count?: PhaseSectionCountOrderByAggregateInput
    _avg?: PhaseSectionAvgOrderByAggregateInput
    _max?: PhaseSectionMaxOrderByAggregateInput
    _min?: PhaseSectionMinOrderByAggregateInput
    _sum?: PhaseSectionSumOrderByAggregateInput
  }

  export type PhaseSectionScalarWhereWithAggregatesInput = {
    AND?: PhaseSectionScalarWhereWithAggregatesInput | PhaseSectionScalarWhereWithAggregatesInput[]
    OR?: PhaseSectionScalarWhereWithAggregatesInput[]
    NOT?: PhaseSectionScalarWhereWithAggregatesInput | PhaseSectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhaseSection"> | string
    phaseId?: StringWithAggregatesFilter<"PhaseSection"> | string
    title?: StringWithAggregatesFilter<"PhaseSection"> | string
    description?: StringNullableWithAggregatesFilter<"PhaseSection"> | string | null
    order?: IntWithAggregatesFilter<"PhaseSection"> | number
  }

  export type SectionItemWhereInput = {
    AND?: SectionItemWhereInput | SectionItemWhereInput[]
    OR?: SectionItemWhereInput[]
    NOT?: SectionItemWhereInput | SectionItemWhereInput[]
    id?: StringFilter<"SectionItem"> | string
    sectionId?: StringFilter<"SectionItem"> | string
    title?: StringFilter<"SectionItem"> | string
    order?: IntFilter<"SectionItem"> | number
    section?: XOR<PhaseSectionRelationFilter, PhaseSectionWhereInput>
    subItems?: SubItemListRelationFilter
  }

  export type SectionItemOrderByWithRelationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    title?: SortOrder
    order?: SortOrder
    section?: PhaseSectionOrderByWithRelationInput
    subItems?: SubItemOrderByRelationAggregateInput
  }

  export type SectionItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SectionItemWhereInput | SectionItemWhereInput[]
    OR?: SectionItemWhereInput[]
    NOT?: SectionItemWhereInput | SectionItemWhereInput[]
    sectionId?: StringFilter<"SectionItem"> | string
    title?: StringFilter<"SectionItem"> | string
    order?: IntFilter<"SectionItem"> | number
    section?: XOR<PhaseSectionRelationFilter, PhaseSectionWhereInput>
    subItems?: SubItemListRelationFilter
  }, "id">

  export type SectionItemOrderByWithAggregationInput = {
    id?: SortOrder
    sectionId?: SortOrder
    title?: SortOrder
    order?: SortOrder
    _count?: SectionItemCountOrderByAggregateInput
    _avg?: SectionItemAvgOrderByAggregateInput
    _max?: SectionItemMaxOrderByAggregateInput
    _min?: SectionItemMinOrderByAggregateInput
    _sum?: SectionItemSumOrderByAggregateInput
  }

  export type SectionItemScalarWhereWithAggregatesInput = {
    AND?: SectionItemScalarWhereWithAggregatesInput | SectionItemScalarWhereWithAggregatesInput[]
    OR?: SectionItemScalarWhereWithAggregatesInput[]
    NOT?: SectionItemScalarWhereWithAggregatesInput | SectionItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SectionItem"> | string
    sectionId?: StringWithAggregatesFilter<"SectionItem"> | string
    title?: StringWithAggregatesFilter<"SectionItem"> | string
    order?: IntWithAggregatesFilter<"SectionItem"> | number
  }

  export type SubItemWhereInput = {
    AND?: SubItemWhereInput | SubItemWhereInput[]
    OR?: SubItemWhereInput[]
    NOT?: SubItemWhereInput | SubItemWhereInput[]
    id?: StringFilter<"SubItem"> | string
    itemId?: StringFilter<"SubItem"> | string
    title?: StringFilter<"SubItem"> | string
    videoUrl?: StringNullableFilter<"SubItem"> | string | null
    duration?: StringNullableFilter<"SubItem"> | string | null
    order?: IntFilter<"SubItem"> | number
    item?: XOR<SectionItemRelationFilter, SectionItemWhereInput>
  }

  export type SubItemOrderByWithRelationInput = {
    id?: SortOrder
    itemId?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    order?: SortOrder
    item?: SectionItemOrderByWithRelationInput
  }

  export type SubItemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: SubItemWhereInput | SubItemWhereInput[]
    OR?: SubItemWhereInput[]
    NOT?: SubItemWhereInput | SubItemWhereInput[]
    itemId?: StringFilter<"SubItem"> | string
    title?: StringFilter<"SubItem"> | string
    videoUrl?: StringNullableFilter<"SubItem"> | string | null
    duration?: StringNullableFilter<"SubItem"> | string | null
    order?: IntFilter<"SubItem"> | number
    item?: XOR<SectionItemRelationFilter, SectionItemWhereInput>
  }, "id">

  export type SubItemOrderByWithAggregationInput = {
    id?: SortOrder
    itemId?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrderInput | SortOrder
    duration?: SortOrderInput | SortOrder
    order?: SortOrder
    _count?: SubItemCountOrderByAggregateInput
    _avg?: SubItemAvgOrderByAggregateInput
    _max?: SubItemMaxOrderByAggregateInput
    _min?: SubItemMinOrderByAggregateInput
    _sum?: SubItemSumOrderByAggregateInput
  }

  export type SubItemScalarWhereWithAggregatesInput = {
    AND?: SubItemScalarWhereWithAggregatesInput | SubItemScalarWhereWithAggregatesInput[]
    OR?: SubItemScalarWhereWithAggregatesInput[]
    NOT?: SubItemScalarWhereWithAggregatesInput | SubItemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"SubItem"> | string
    itemId?: StringWithAggregatesFilter<"SubItem"> | string
    title?: StringWithAggregatesFilter<"SubItem"> | string
    videoUrl?: StringNullableWithAggregatesFilter<"SubItem"> | string | null
    duration?: StringNullableWithAggregatesFilter<"SubItem"> | string | null
    order?: IntWithAggregatesFilter<"SubItem"> | number
  }

  export type PhasePlaylistWhereInput = {
    AND?: PhasePlaylistWhereInput | PhasePlaylistWhereInput[]
    OR?: PhasePlaylistWhereInput[]
    NOT?: PhasePlaylistWhereInput | PhasePlaylistWhereInput[]
    id?: StringFilter<"PhasePlaylist"> | string
    phaseId?: StringFilter<"PhasePlaylist"> | string
    title?: StringFilter<"PhasePlaylist"> | string
    author?: StringNullableFilter<"PhasePlaylist"> | string | null
    videoCount?: IntFilter<"PhasePlaylist"> | number
    url?: StringFilter<"PhasePlaylist"> | string
    thumbnail?: StringNullableFilter<"PhasePlaylist"> | string | null
    phase?: XOR<RoadmapPhaseRelationFilter, RoadmapPhaseWhereInput>
  }

  export type PhasePlaylistOrderByWithRelationInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    author?: SortOrderInput | SortOrder
    videoCount?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    phase?: RoadmapPhaseOrderByWithRelationInput
  }

  export type PhasePlaylistWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhasePlaylistWhereInput | PhasePlaylistWhereInput[]
    OR?: PhasePlaylistWhereInput[]
    NOT?: PhasePlaylistWhereInput | PhasePlaylistWhereInput[]
    phaseId?: StringFilter<"PhasePlaylist"> | string
    title?: StringFilter<"PhasePlaylist"> | string
    author?: StringNullableFilter<"PhasePlaylist"> | string | null
    videoCount?: IntFilter<"PhasePlaylist"> | number
    url?: StringFilter<"PhasePlaylist"> | string
    thumbnail?: StringNullableFilter<"PhasePlaylist"> | string | null
    phase?: XOR<RoadmapPhaseRelationFilter, RoadmapPhaseWhereInput>
  }, "id">

  export type PhasePlaylistOrderByWithAggregationInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    author?: SortOrderInput | SortOrder
    videoCount?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrderInput | SortOrder
    _count?: PhasePlaylistCountOrderByAggregateInput
    _avg?: PhasePlaylistAvgOrderByAggregateInput
    _max?: PhasePlaylistMaxOrderByAggregateInput
    _min?: PhasePlaylistMinOrderByAggregateInput
    _sum?: PhasePlaylistSumOrderByAggregateInput
  }

  export type PhasePlaylistScalarWhereWithAggregatesInput = {
    AND?: PhasePlaylistScalarWhereWithAggregatesInput | PhasePlaylistScalarWhereWithAggregatesInput[]
    OR?: PhasePlaylistScalarWhereWithAggregatesInput[]
    NOT?: PhasePlaylistScalarWhereWithAggregatesInput | PhasePlaylistScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhasePlaylist"> | string
    phaseId?: StringWithAggregatesFilter<"PhasePlaylist"> | string
    title?: StringWithAggregatesFilter<"PhasePlaylist"> | string
    author?: StringNullableWithAggregatesFilter<"PhasePlaylist"> | string | null
    videoCount?: IntWithAggregatesFilter<"PhasePlaylist"> | number
    url?: StringWithAggregatesFilter<"PhasePlaylist"> | string
    thumbnail?: StringNullableWithAggregatesFilter<"PhasePlaylist"> | string | null
  }

  export type PhaseProjectWhereInput = {
    AND?: PhaseProjectWhereInput | PhaseProjectWhereInput[]
    OR?: PhaseProjectWhereInput[]
    NOT?: PhaseProjectWhereInput | PhaseProjectWhereInput[]
    id?: StringFilter<"PhaseProject"> | string
    phaseId?: StringFilter<"PhaseProject"> | string
    title?: StringFilter<"PhaseProject"> | string
    description?: StringNullableFilter<"PhaseProject"> | string | null
    tags?: JsonNullableFilter<"PhaseProject">
    phase?: XOR<RoadmapPhaseRelationFilter, RoadmapPhaseWhereInput>
  }

  export type PhaseProjectOrderByWithRelationInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    phase?: RoadmapPhaseOrderByWithRelationInput
  }

  export type PhaseProjectWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PhaseProjectWhereInput | PhaseProjectWhereInput[]
    OR?: PhaseProjectWhereInput[]
    NOT?: PhaseProjectWhereInput | PhaseProjectWhereInput[]
    phaseId?: StringFilter<"PhaseProject"> | string
    title?: StringFilter<"PhaseProject"> | string
    description?: StringNullableFilter<"PhaseProject"> | string | null
    tags?: JsonNullableFilter<"PhaseProject">
    phase?: XOR<RoadmapPhaseRelationFilter, RoadmapPhaseWhereInput>
  }, "id">

  export type PhaseProjectOrderByWithAggregationInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    tags?: SortOrderInput | SortOrder
    _count?: PhaseProjectCountOrderByAggregateInput
    _max?: PhaseProjectMaxOrderByAggregateInput
    _min?: PhaseProjectMinOrderByAggregateInput
  }

  export type PhaseProjectScalarWhereWithAggregatesInput = {
    AND?: PhaseProjectScalarWhereWithAggregatesInput | PhaseProjectScalarWhereWithAggregatesInput[]
    OR?: PhaseProjectScalarWhereWithAggregatesInput[]
    NOT?: PhaseProjectScalarWhereWithAggregatesInput | PhaseProjectScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PhaseProject"> | string
    phaseId?: StringWithAggregatesFilter<"PhaseProject"> | string
    title?: StringWithAggregatesFilter<"PhaseProject"> | string
    description?: StringNullableWithAggregatesFilter<"PhaseProject"> | string | null
    tags?: JsonNullableWithAggregatesFilter<"PhaseProject">
  }

  export type DSASheetWhereInput = {
    AND?: DSASheetWhereInput | DSASheetWhereInput[]
    OR?: DSASheetWhereInput[]
    NOT?: DSASheetWhereInput | DSASheetWhereInput[]
    id?: StringFilter<"DSASheet"> | string
    title?: StringFilter<"DSASheet"> | string
    description?: StringFilter<"DSASheet"> | string
    level?: StringFilter<"DSASheet"> | string
    createdAt?: DateTimeFilter<"DSASheet"> | Date | string
    topics?: DSATopicListRelationFilter
  }

  export type DSASheetOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    topics?: DSATopicOrderByRelationAggregateInput
  }

  export type DSASheetWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DSASheetWhereInput | DSASheetWhereInput[]
    OR?: DSASheetWhereInput[]
    NOT?: DSASheetWhereInput | DSASheetWhereInput[]
    title?: StringFilter<"DSASheet"> | string
    description?: StringFilter<"DSASheet"> | string
    level?: StringFilter<"DSASheet"> | string
    createdAt?: DateTimeFilter<"DSASheet"> | Date | string
    topics?: DSATopicListRelationFilter
  }, "id">

  export type DSASheetOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    _count?: DSASheetCountOrderByAggregateInput
    _max?: DSASheetMaxOrderByAggregateInput
    _min?: DSASheetMinOrderByAggregateInput
  }

  export type DSASheetScalarWhereWithAggregatesInput = {
    AND?: DSASheetScalarWhereWithAggregatesInput | DSASheetScalarWhereWithAggregatesInput[]
    OR?: DSASheetScalarWhereWithAggregatesInput[]
    NOT?: DSASheetScalarWhereWithAggregatesInput | DSASheetScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DSASheet"> | string
    title?: StringWithAggregatesFilter<"DSASheet"> | string
    description?: StringWithAggregatesFilter<"DSASheet"> | string
    level?: StringWithAggregatesFilter<"DSASheet"> | string
    createdAt?: DateTimeWithAggregatesFilter<"DSASheet"> | Date | string
  }

  export type DSATopicWhereInput = {
    AND?: DSATopicWhereInput | DSATopicWhereInput[]
    OR?: DSATopicWhereInput[]
    NOT?: DSATopicWhereInput | DSATopicWhereInput[]
    id?: StringFilter<"DSATopic"> | string
    title?: StringFilter<"DSATopic"> | string
    sheetId?: StringFilter<"DSATopic"> | string
    order?: IntFilter<"DSATopic"> | number
    sheet?: XOR<DSASheetRelationFilter, DSASheetWhereInput>
    problems?: DSAProblemListRelationFilter
  }

  export type DSATopicOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    sheetId?: SortOrder
    order?: SortOrder
    sheet?: DSASheetOrderByWithRelationInput
    problems?: DSAProblemOrderByRelationAggregateInput
  }

  export type DSATopicWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DSATopicWhereInput | DSATopicWhereInput[]
    OR?: DSATopicWhereInput[]
    NOT?: DSATopicWhereInput | DSATopicWhereInput[]
    title?: StringFilter<"DSATopic"> | string
    sheetId?: StringFilter<"DSATopic"> | string
    order?: IntFilter<"DSATopic"> | number
    sheet?: XOR<DSASheetRelationFilter, DSASheetWhereInput>
    problems?: DSAProblemListRelationFilter
  }, "id">

  export type DSATopicOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    sheetId?: SortOrder
    order?: SortOrder
    _count?: DSATopicCountOrderByAggregateInput
    _avg?: DSATopicAvgOrderByAggregateInput
    _max?: DSATopicMaxOrderByAggregateInput
    _min?: DSATopicMinOrderByAggregateInput
    _sum?: DSATopicSumOrderByAggregateInput
  }

  export type DSATopicScalarWhereWithAggregatesInput = {
    AND?: DSATopicScalarWhereWithAggregatesInput | DSATopicScalarWhereWithAggregatesInput[]
    OR?: DSATopicScalarWhereWithAggregatesInput[]
    NOT?: DSATopicScalarWhereWithAggregatesInput | DSATopicScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DSATopic"> | string
    title?: StringWithAggregatesFilter<"DSATopic"> | string
    sheetId?: StringWithAggregatesFilter<"DSATopic"> | string
    order?: IntWithAggregatesFilter<"DSATopic"> | number
  }

  export type DSAProblemWhereInput = {
    AND?: DSAProblemWhereInput | DSAProblemWhereInput[]
    OR?: DSAProblemWhereInput[]
    NOT?: DSAProblemWhereInput | DSAProblemWhereInput[]
    id?: StringFilter<"DSAProblem"> | string
    title?: StringFilter<"DSAProblem"> | string
    description?: StringNullableFilter<"DSAProblem"> | string | null
    difficulty?: StringFilter<"DSAProblem"> | string
    topicId?: StringFilter<"DSAProblem"> | string
    order?: IntFilter<"DSAProblem"> | number
    topic?: XOR<DSATopicRelationFilter, DSATopicWhereInput>
    solutions?: DSASolutionListRelationFilter
  }

  export type DSAProblemOrderByWithRelationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    topicId?: SortOrder
    order?: SortOrder
    topic?: DSATopicOrderByWithRelationInput
    solutions?: DSASolutionOrderByRelationAggregateInput
  }

  export type DSAProblemWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DSAProblemWhereInput | DSAProblemWhereInput[]
    OR?: DSAProblemWhereInput[]
    NOT?: DSAProblemWhereInput | DSAProblemWhereInput[]
    title?: StringFilter<"DSAProblem"> | string
    description?: StringNullableFilter<"DSAProblem"> | string | null
    difficulty?: StringFilter<"DSAProblem"> | string
    topicId?: StringFilter<"DSAProblem"> | string
    order?: IntFilter<"DSAProblem"> | number
    topic?: XOR<DSATopicRelationFilter, DSATopicWhereInput>
    solutions?: DSASolutionListRelationFilter
  }, "id">

  export type DSAProblemOrderByWithAggregationInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrderInput | SortOrder
    difficulty?: SortOrder
    topicId?: SortOrder
    order?: SortOrder
    _count?: DSAProblemCountOrderByAggregateInput
    _avg?: DSAProblemAvgOrderByAggregateInput
    _max?: DSAProblemMaxOrderByAggregateInput
    _min?: DSAProblemMinOrderByAggregateInput
    _sum?: DSAProblemSumOrderByAggregateInput
  }

  export type DSAProblemScalarWhereWithAggregatesInput = {
    AND?: DSAProblemScalarWhereWithAggregatesInput | DSAProblemScalarWhereWithAggregatesInput[]
    OR?: DSAProblemScalarWhereWithAggregatesInput[]
    NOT?: DSAProblemScalarWhereWithAggregatesInput | DSAProblemScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DSAProblem"> | string
    title?: StringWithAggregatesFilter<"DSAProblem"> | string
    description?: StringNullableWithAggregatesFilter<"DSAProblem"> | string | null
    difficulty?: StringWithAggregatesFilter<"DSAProblem"> | string
    topicId?: StringWithAggregatesFilter<"DSAProblem"> | string
    order?: IntWithAggregatesFilter<"DSAProblem"> | number
  }

  export type DSASolutionWhereInput = {
    AND?: DSASolutionWhereInput | DSASolutionWhereInput[]
    OR?: DSASolutionWhereInput[]
    NOT?: DSASolutionWhereInput | DSASolutionWhereInput[]
    id?: StringFilter<"DSASolution"> | string
    language?: StringFilter<"DSASolution"> | string
    code?: StringFilter<"DSASolution"> | string
    problemId?: StringFilter<"DSASolution"> | string
    problem?: XOR<DSAProblemRelationFilter, DSAProblemWhereInput>
  }

  export type DSASolutionOrderByWithRelationInput = {
    id?: SortOrder
    language?: SortOrder
    code?: SortOrder
    problemId?: SortOrder
    problem?: DSAProblemOrderByWithRelationInput
  }

  export type DSASolutionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: DSASolutionWhereInput | DSASolutionWhereInput[]
    OR?: DSASolutionWhereInput[]
    NOT?: DSASolutionWhereInput | DSASolutionWhereInput[]
    language?: StringFilter<"DSASolution"> | string
    code?: StringFilter<"DSASolution"> | string
    problemId?: StringFilter<"DSASolution"> | string
    problem?: XOR<DSAProblemRelationFilter, DSAProblemWhereInput>
  }, "id">

  export type DSASolutionOrderByWithAggregationInput = {
    id?: SortOrder
    language?: SortOrder
    code?: SortOrder
    problemId?: SortOrder
    _count?: DSASolutionCountOrderByAggregateInput
    _max?: DSASolutionMaxOrderByAggregateInput
    _min?: DSASolutionMinOrderByAggregateInput
  }

  export type DSASolutionScalarWhereWithAggregatesInput = {
    AND?: DSASolutionScalarWhereWithAggregatesInput | DSASolutionScalarWhereWithAggregatesInput[]
    OR?: DSASolutionScalarWhereWithAggregatesInput[]
    NOT?: DSASolutionScalarWhereWithAggregatesInput | DSASolutionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"DSASolution"> | string
    language?: StringWithAggregatesFilter<"DSASolution"> | string
    code?: StringWithAggregatesFilter<"DSASolution"> | string
    problemId?: StringWithAggregatesFilter<"DSASolution"> | string
  }

  export type CertificateWhereInput = {
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    id?: StringFilter<"Certificate"> | string
    certificateId?: StringFilter<"Certificate"> | string
    eventId?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    teamId?: StringNullableFilter<"Certificate"> | string | null
    participantName?: StringFilter<"Certificate"> | string
    position?: StringNullableFilter<"Certificate"> | string | null
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
  }

  export type CertificateOrderByWithRelationInput = {
    id?: SortOrder
    certificateId?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    participantName?: SortOrder
    position?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    event?: EventOrderByWithRelationInput
    user?: UserOrderByWithRelationInput
    team?: TeamOrderByWithRelationInput
  }

  export type CertificateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    certificateId?: string
    AND?: CertificateWhereInput | CertificateWhereInput[]
    OR?: CertificateWhereInput[]
    NOT?: CertificateWhereInput | CertificateWhereInput[]
    eventId?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    teamId?: StringNullableFilter<"Certificate"> | string | null
    participantName?: StringFilter<"Certificate"> | string
    position?: StringNullableFilter<"Certificate"> | string | null
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    user?: XOR<UserRelationFilter, UserWhereInput>
    team?: XOR<TeamNullableRelationFilter, TeamWhereInput> | null
  }, "id" | "certificateId">

  export type CertificateOrderByWithAggregationInput = {
    id?: SortOrder
    certificateId?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrderInput | SortOrder
    participantName?: SortOrder
    position?: SortOrderInput | SortOrder
    issuedAt?: SortOrder
    _count?: CertificateCountOrderByAggregateInput
    _max?: CertificateMaxOrderByAggregateInput
    _min?: CertificateMinOrderByAggregateInput
  }

  export type CertificateScalarWhereWithAggregatesInput = {
    AND?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    OR?: CertificateScalarWhereWithAggregatesInput[]
    NOT?: CertificateScalarWhereWithAggregatesInput | CertificateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Certificate"> | string
    certificateId?: StringWithAggregatesFilter<"Certificate"> | string
    eventId?: StringWithAggregatesFilter<"Certificate"> | string
    userId?: StringWithAggregatesFilter<"Certificate"> | string
    teamId?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    participantName?: StringWithAggregatesFilter<"Certificate"> | string
    position?: StringNullableWithAggregatesFilter<"Certificate"> | string | null
    issuedAt?: DateTimeWithAggregatesFilter<"Certificate"> | Date | string
  }

  export type EmailLogWhereInput = {
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    id?: StringFilter<"EmailLog"> | string
    eventId?: StringFilter<"EmailLog"> | string
    subject?: StringFilter<"EmailLog"> | string
    message?: StringFilter<"EmailLog"> | string
    recipientCount?: IntFilter<"EmailLog"> | number
    sentBy?: StringFilter<"EmailLog"> | string
    sentAt?: DateTimeFilter<"EmailLog"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }

  export type EmailLogOrderByWithRelationInput = {
    id?: SortOrder
    eventId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    recipientCount?: SortOrder
    sentBy?: SortOrder
    sentAt?: SortOrder
    event?: EventOrderByWithRelationInput
    sender?: UserOrderByWithRelationInput
  }

  export type EmailLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: EmailLogWhereInput | EmailLogWhereInput[]
    OR?: EmailLogWhereInput[]
    NOT?: EmailLogWhereInput | EmailLogWhereInput[]
    eventId?: StringFilter<"EmailLog"> | string
    subject?: StringFilter<"EmailLog"> | string
    message?: StringFilter<"EmailLog"> | string
    recipientCount?: IntFilter<"EmailLog"> | number
    sentBy?: StringFilter<"EmailLog"> | string
    sentAt?: DateTimeFilter<"EmailLog"> | Date | string
    event?: XOR<EventRelationFilter, EventWhereInput>
    sender?: XOR<UserRelationFilter, UserWhereInput>
  }, "id">

  export type EmailLogOrderByWithAggregationInput = {
    id?: SortOrder
    eventId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    recipientCount?: SortOrder
    sentBy?: SortOrder
    sentAt?: SortOrder
    _count?: EmailLogCountOrderByAggregateInput
    _avg?: EmailLogAvgOrderByAggregateInput
    _max?: EmailLogMaxOrderByAggregateInput
    _min?: EmailLogMinOrderByAggregateInput
    _sum?: EmailLogSumOrderByAggregateInput
  }

  export type EmailLogScalarWhereWithAggregatesInput = {
    AND?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    OR?: EmailLogScalarWhereWithAggregatesInput[]
    NOT?: EmailLogScalarWhereWithAggregatesInput | EmailLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmailLog"> | string
    eventId?: StringWithAggregatesFilter<"EmailLog"> | string
    subject?: StringWithAggregatesFilter<"EmailLog"> | string
    message?: StringWithAggregatesFilter<"EmailLog"> | string
    recipientCount?: IntWithAggregatesFilter<"EmailLog"> | number
    sentBy?: StringWithAggregatesFilter<"EmailLog"> | string
    sentAt?: DateTimeWithAggregatesFilter<"EmailLog"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventCategoryCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    parent?: EventCategoryCreateNestedOneWithoutChildrenInput
    children?: EventCategoryCreateNestedManyWithoutParentInput
    events?: EventCreateNestedManyWithoutCategoryInput
    eventTypes?: EventTypeCreateNestedManyWithoutCategoryInput
  }

  export type EventCategoryUncheckedCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
    children?: EventCategoryUncheckedCreateNestedManyWithoutParentInput
    events?: EventUncheckedCreateNestedManyWithoutCategoryInput
    eventTypes?: EventTypeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type EventCategoryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: EventCategoryUpdateOneWithoutChildrenNestedInput
    children?: EventCategoryUpdateManyWithoutParentNestedInput
    events?: EventUpdateManyWithoutCategoryNestedInput
    eventTypes?: EventTypeUpdateManyWithoutCategoryNestedInput
  }

  export type EventCategoryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: EventCategoryUncheckedUpdateManyWithoutParentNestedInput
    events?: EventUncheckedUpdateManyWithoutCategoryNestedInput
    eventTypes?: EventTypeUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type EventCategoryCreateManyInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
  }

  export type EventCategoryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCategoryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTypeCreateInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    defaultDurationHours?: number | null
    createdAt?: Date | string
    category: EventCategoryCreateNestedOneWithoutEventTypesInput
  }

  export type EventTypeUncheckedCreateInput = {
    id?: string
    categoryId: string
    name: string
    slug: string
    description?: string | null
    defaultDurationHours?: number | null
    createdAt?: Date | string
  }

  export type EventTypeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EventCategoryUpdateOneRequiredWithoutEventTypesNestedInput
  }

  export type EventTypeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTypeCreateManyInput = {
    id?: string
    categoryId: string
    name: string
    slug: string
    description?: string | null
    defaultDurationHours?: number | null
    createdAt?: Date | string
  }

  export type EventTypeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTypeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCreateInput = {
    id?: string
    title: string
    slug: string
    description: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    hasChallenges?: boolean
    problemCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: EventCategoryCreateNestedOneWithoutEventsInput
    creator?: UserCreateNestedOneWithoutEventsCreatedInput
    roadmap?: RoadmapCreateNestedOneWithoutEventsInput
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
    teams?: TeamCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogCreateNestedManyWithoutEventInput
    certificates?: CertificateCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: string | null
    hasChallenges?: boolean
    problemCount?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutEventInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EventCategoryUpdateOneRequiredWithoutEventsNestedInput
    creator?: UserUpdateOneWithoutEventsCreatedNestedInput
    roadmap?: RoadmapUpdateOneWithoutEventsNestedInput
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
    teams?: TeamUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUpdateManyWithoutEventNestedInput
    certificates?: CertificateUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutEventNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventCreateManyInput = {
    id?: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: string | null
    hasChallenges?: boolean
    problemCount?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamCreateInput = {
    id?: string
    teamName: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutTeamsInput
    leader: UserCreateNestedOneWithoutTeamsLeadingInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionCreateNestedManyWithoutTeamInput
    certificates?: CertificateCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateInput = {
    id?: string
    eventId: string
    teamName: string
    teamLeaderId: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutTeamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput
    leader?: UserUpdateOneRequiredWithoutTeamsLeadingNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamLeaderId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUncheckedUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamCreateManyInput = {
    id?: string
    eventId: string
    teamName: string
    teamLeaderId: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamLeaderId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateInput = {
    id?: string
    isLeader?: boolean
    status?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
    team: TeamCreateNestedOneWithoutMembersInput
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateInput = {
    id?: string
    teamId: string
    userId: string
    isLeader?: boolean
    status?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TeamMemberUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLeader?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isLeader?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberCreateManyInput = {
    id?: string
    teamId: string
    userId: string
    isLeader?: boolean
    status?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TeamMemberUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLeader?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isLeader?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamJoinRequestCreateInput = {
    id?: string
    requestType: string
    status?: string
    message?: string | null
    responseMessage?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
    team: TeamCreateNestedOneWithoutJoinRequestsInput
    user: UserCreateNestedOneWithoutTeamJoinRequestsInput
  }

  export type TeamJoinRequestUncheckedCreateInput = {
    id?: string
    teamId: string
    userId: string
    requestType: string
    status?: string
    message?: string | null
    responseMessage?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type TeamJoinRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    team?: TeamUpdateOneRequiredWithoutJoinRequestsNestedInput
    user?: UserUpdateOneRequiredWithoutTeamJoinRequestsNestedInput
  }

  export type TeamJoinRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamJoinRequestCreateManyInput = {
    id?: string
    teamId: string
    userId: string
    requestType: string
    status?: string
    message?: string | null
    responseMessage?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type TeamJoinRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamJoinRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventRegistrationCreateInput = {
    id?: string
    participationType?: string
    paymentStatus?: string
    paymentId?: string | null
    amountPaid?: Decimal | DecimalJsLike | number | string | null
    paidAt?: Date | string | null
    status?: string
    registeredAt?: Date | string
    cancelledAt?: Date | string | null
    event: EventCreateNestedOneWithoutRegistrationsInput
    user: UserCreateNestedOneWithoutEventRegistrationsInput
    team?: TeamCreateNestedOneWithoutRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    teamId?: string | null
    participationType?: string
    paymentStatus?: string
    paymentId?: string | null
    amountPaid?: Decimal | DecimalJsLike | number | string | null
    paidAt?: Date | string | null
    status?: string
    registeredAt?: Date | string
    cancelledAt?: Date | string | null
  }

  export type EventRegistrationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: EventUpdateOneRequiredWithoutRegistrationsNestedInput
    user?: UserUpdateOneRequiredWithoutEventRegistrationsNestedInput
    team?: TeamUpdateOneWithoutRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventRegistrationCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    teamId?: string | null
    participationType?: string
    paymentStatus?: string
    paymentId?: string | null
    amountPaid?: Decimal | DecimalJsLike | number | string | null
    paidAt?: Date | string | null
    status?: string
    registeredAt?: Date | string
    cancelledAt?: Date | string | null
  }

  export type EventRegistrationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventRegistrationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventSubmissionCreateInput = {
    id?: string
    projectDeckUrl?: string | null
    presentationPdfUrl?: string | null
    mvpLink?: string | null
    demoVideoUrl?: string | null
    githubRepoUrl?: string | null
    technologiesUsed?: string | null
    aiToolsIntegrated?: string | null
    solutionDescription?: string | null
    score?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    feedback?: string | null
    status?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    evaluatedAt?: Date | string | null
    event: EventCreateNestedOneWithoutSubmissionsInput
    user: UserCreateNestedOneWithoutSubmissionsInput
    team?: TeamCreateNestedOneWithoutSubmissionsInput
  }

  export type EventSubmissionUncheckedCreateInput = {
    id?: string
    eventId: string
    userId: string
    teamId?: string | null
    projectDeckUrl?: string | null
    presentationPdfUrl?: string | null
    mvpLink?: string | null
    demoVideoUrl?: string | null
    githubRepoUrl?: string | null
    technologiesUsed?: string | null
    aiToolsIntegrated?: string | null
    solutionDescription?: string | null
    score?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    feedback?: string | null
    status?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    evaluatedAt?: Date | string | null
  }

  export type EventSubmissionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: EventUpdateOneRequiredWithoutSubmissionsNestedInput
    user?: UserUpdateOneRequiredWithoutSubmissionsNestedInput
    team?: TeamUpdateOneWithoutSubmissionsNestedInput
  }

  export type EventSubmissionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventSubmissionCreateManyInput = {
    id?: string
    eventId: string
    userId: string
    teamId?: string | null
    projectDeckUrl?: string | null
    presentationPdfUrl?: string | null
    mvpLink?: string | null
    demoVideoUrl?: string | null
    githubRepoUrl?: string | null
    technologiesUsed?: string | null
    aiToolsIntegrated?: string | null
    solutionDescription?: string | null
    score?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    feedback?: string | null
    status?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    evaluatedAt?: Date | string | null
  }

  export type EventSubmissionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventSubmissionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type ChallengeCreateInput = {
    id?: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date | string
    endDate: Date | string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: number | null
    bannerImage?: string | null
    icon?: string | null
    status?: string
    totalParticipants?: number
    activeParticipants?: number
    completionRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutChallengesCreatedInput
    tasks?: ChallengeTaskCreateNestedManyWithoutChallengeInput
    userProgress?: UserChallengeProgressCreateNestedManyWithoutChallengeInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateInput = {
    id?: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date | string
    endDate: Date | string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: number | null
    bannerImage?: string | null
    icon?: string | null
    status?: string
    totalParticipants?: number
    activeParticipants?: number
    completionRate?: Decimal | DecimalJsLike | number | string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: ChallengeTaskUncheckedCreateNestedManyWithoutChallengeInput
    userProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutChallengeInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutChallengesCreatedNestedInput
    tasks?: ChallengeTaskUpdateManyWithoutChallengeNestedInput
    userProgress?: UserChallengeProgressUpdateManyWithoutChallengeNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ChallengeTaskUncheckedUpdateManyWithoutChallengeNestedInput
    userProgress?: UserChallengeProgressUncheckedUpdateManyWithoutChallengeNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeCreateManyInput = {
    id?: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date | string
    endDate: Date | string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: number | null
    bannerImage?: string | null
    icon?: string | null
    status?: string
    totalParticipants?: number
    activeParticipants?: number
    completionRate?: Decimal | DecimalJsLike | number | string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeTaskCreateInput = {
    id?: string
    dayNumber: number
    title: string
    description?: string | null
    taskType: string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    points?: number
    autoValidate?: boolean
    validationUrl?: string | null
    createdAt?: Date | string
    challenge: ChallengeCreateNestedOneWithoutTasksInput
    completions?: UserTaskCompletionCreateNestedManyWithoutTaskInput
  }

  export type ChallengeTaskUncheckedCreateInput = {
    id?: string
    challengeId: string
    dayNumber: number
    title: string
    description?: string | null
    taskType: string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    points?: number
    autoValidate?: boolean
    validationUrl?: string | null
    createdAt?: Date | string
    completions?: UserTaskCompletionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type ChallengeTaskUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    autoValidate?: BoolFieldUpdateOperationsInput | boolean
    validationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutTasksNestedInput
    completions?: UserTaskCompletionUpdateManyWithoutTaskNestedInput
  }

  export type ChallengeTaskUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    autoValidate?: BoolFieldUpdateOperationsInput | boolean
    validationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: UserTaskCompletionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ChallengeTaskCreateManyInput = {
    id?: string
    challengeId: string
    dayNumber: number
    title: string
    description?: string | null
    taskType: string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    points?: number
    autoValidate?: boolean
    validationUrl?: string | null
    createdAt?: Date | string
  }

  export type ChallengeTaskUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    autoValidate?: BoolFieldUpdateOperationsInput | boolean
    validationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeTaskUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    autoValidate?: BoolFieldUpdateOperationsInput | boolean
    validationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChallengeProgressCreateInput = {
    id?: string
    status?: string
    completedDays?: number
    totalDays: number
    completionPercentage?: Decimal | DecimalJsLike | number | string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    totalPoints?: number
    bonusPoints?: number
    currentRank?: number | null
    startedAt?: Date | string
    lastActivity?: Date | string
    completedAt?: Date | string | null
    certificateIssued?: boolean
    certificateUrl?: string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutChallengeProgressInput
    challenge: ChallengeCreateNestedOneWithoutUserProgressInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutProgressInput
  }

  export type UserChallengeProgressUncheckedCreateInput = {
    id?: string
    userId: string
    challengeId: string
    status?: string
    completedDays?: number
    totalDays: number
    completionPercentage?: Decimal | DecimalJsLike | number | string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    totalPoints?: number
    bonusPoints?: number
    currentRank?: number | null
    startedAt?: Date | string
    lastActivity?: Date | string
    completedAt?: Date | string | null
    certificateIssued?: boolean
    certificateUrl?: string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutProgressInput
  }

  export type UserChallengeProgressUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedDays?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    completionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    bonusPoints?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateIssued?: BoolFieldUpdateOperationsInput | boolean
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutChallengeProgressNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutUserProgressNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutProgressNestedInput
  }

  export type UserChallengeProgressUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedDays?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    completionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    bonusPoints?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateIssued?: BoolFieldUpdateOperationsInput | boolean
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutProgressNestedInput
  }

  export type UserChallengeProgressCreateManyInput = {
    id?: string
    userId: string
    challengeId: string
    status?: string
    completedDays?: number
    totalDays: number
    completionPercentage?: Decimal | DecimalJsLike | number | string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    totalPoints?: number
    bonusPoints?: number
    currentRank?: number | null
    startedAt?: Date | string
    lastActivity?: Date | string
    completedAt?: Date | string | null
    certificateIssued?: boolean
    certificateUrl?: string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserChallengeProgressUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedDays?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    completionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    bonusPoints?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateIssued?: BoolFieldUpdateOperationsInput | boolean
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserChallengeProgressUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedDays?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    completionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    bonusPoints?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateIssued?: BoolFieldUpdateOperationsInput | boolean
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserTaskCompletionCreateInput = {
    id?: string
    challengeId: string
    completedAt?: Date | string
    timeTaken?: number | null
    submissionUrl?: string | null
    submissionText?: string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    score?: Decimal | DecimalJsLike | number | string | null
    pointsEarned?: number | null
    userNotes?: string | null
    feedback?: string | null
    user: UserCreateNestedOneWithoutTaskCompletionsInput
    task: ChallengeTaskCreateNestedOneWithoutCompletionsInput
    progress: UserChallengeProgressCreateNestedOneWithoutTaskCompletionsInput
  }

  export type UserTaskCompletionUncheckedCreateInput = {
    id?: string
    userId: string
    challengeId: string
    taskId: string
    progressId: string
    completedAt?: Date | string
    timeTaken?: number | null
    submissionUrl?: string | null
    submissionText?: string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    score?: Decimal | DecimalJsLike | number | string | null
    pointsEarned?: number | null
    userNotes?: string | null
    feedback?: string | null
  }

  export type UserTaskCompletionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTaskCompletionsNestedInput
    task?: ChallengeTaskUpdateOneRequiredWithoutCompletionsNestedInput
    progress?: UserChallengeProgressUpdateOneRequiredWithoutTaskCompletionsNestedInput
  }

  export type UserTaskCompletionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    progressId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserTaskCompletionCreateManyInput = {
    id?: string
    userId: string
    challengeId: string
    taskId: string
    progressId: string
    completedAt?: Date | string
    timeTaken?: number | null
    submissionUrl?: string | null
    submissionText?: string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    score?: Decimal | DecimalJsLike | number | string | null
    pointsEarned?: number | null
    userNotes?: string | null
    feedback?: string | null
  }

  export type UserTaskCompletionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserTaskCompletionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    progressId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserBadgeCreateInput = {
    id?: string
    badgeType: string
    badgeName: string
    badgeDescription?: string | null
    badgeIcon?: string | null
    badgeColor?: string | null
    relatedChallengeId?: string | null
    relatedEventId?: string | null
    pointsAwarded?: number
    earnedAt?: Date | string
    user: UserCreateNestedOneWithoutBadgesInput
  }

  export type UserBadgeUncheckedCreateInput = {
    id?: string
    userId: string
    badgeType: string
    badgeName: string
    badgeDescription?: string | null
    badgeIcon?: string | null
    badgeColor?: string | null
    relatedChallengeId?: string | null
    relatedEventId?: string | null
    pointsAwarded?: number
    earnedAt?: Date | string
  }

  export type UserBadgeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeType?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    badgeIcon?: NullableStringFieldUpdateOperationsInput | string | null
    badgeColor?: NullableStringFieldUpdateOperationsInput | string | null
    relatedChallengeId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutBadgesNestedInput
  }

  export type UserBadgeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeType?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    badgeIcon?: NullableStringFieldUpdateOperationsInput | string | null
    badgeColor?: NullableStringFieldUpdateOperationsInput | string | null
    relatedChallengeId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeCreateManyInput = {
    id?: string
    userId: string
    badgeType: string
    badgeName: string
    badgeDescription?: string | null
    badgeIcon?: string | null
    badgeColor?: string | null
    relatedChallengeId?: string | null
    relatedEventId?: string | null
    pointsAwarded?: number
    earnedAt?: Date | string
  }

  export type UserBadgeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeType?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    badgeIcon?: NullableStringFieldUpdateOperationsInput | string | null
    badgeColor?: NullableStringFieldUpdateOperationsInput | string | null
    relatedChallengeId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    badgeType?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    badgeIcon?: NullableStringFieldUpdateOperationsInput | string | null
    badgeColor?: NullableStringFieldUpdateOperationsInput | string | null
    relatedChallengeId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateInput = {
    id?: string
    achievementType: string
    achievementName: string
    description?: string | null
    value?: number | null
    target?: number | null
    rarity?: string | null
    earnedAt?: Date | string
    user: UserCreateNestedOneWithoutAchievementsInput
  }

  export type UserAchievementUncheckedCreateInput = {
    id?: string
    userId: string
    achievementType: string
    achievementName: string
    description?: string | null
    value?: number | null
    target?: number | null
    rarity?: string | null
    earnedAt?: Date | string
  }

  export type UserAchievementUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutAchievementsNestedInput
  }

  export type UserAchievementUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementCreateManyInput = {
    id?: string
    userId: string
    achievementType: string
    achievementName: string
    description?: string | null
    value?: number | null
    target?: number | null
    rarity?: string | null
    earnedAt?: Date | string
  }

  export type UserAchievementUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardCreateInput = {
    id?: string
    leaderboardType: string
    relatedId?: string | null
    timePeriod?: string | null
    score?: number
    rank?: number | null
    previousRank?: number | null
    totalCompletions?: number
    currentStreak?: number
    updatedAt?: Date | string
    user: UserCreateNestedOneWithoutLeaderboardEntriesInput
  }

  export type LeaderboardUncheckedCreateInput = {
    id?: string
    userId: string
    leaderboardType: string
    relatedId?: string | null
    timePeriod?: string | null
    score?: number
    rank?: number | null
    previousRank?: number | null
    totalCompletions?: number
    currentStreak?: number
    updatedAt?: Date | string
  }

  export type LeaderboardUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaderboardType?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    timePeriod?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    totalCompletions?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput
  }

  export type LeaderboardUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    leaderboardType?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    timePeriod?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    totalCompletions?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardCreateManyInput = {
    id?: string
    userId: string
    leaderboardType: string
    relatedId?: string | null
    timePeriod?: string | null
    score?: number
    rank?: number | null
    previousRank?: number | null
    totalCompletions?: number
    currentStreak?: number
    updatedAt?: Date | string
  }

  export type LeaderboardUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaderboardType?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    timePeriod?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    totalCompletions?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    leaderboardType?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    timePeriod?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    totalCompletions?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventChallengeCreateInput = {
    event: EventCreateNestedOneWithoutEventChallengesInput
    challenge: ChallengeCreateNestedOneWithoutEventChallengesInput
  }

  export type EventChallengeUncheckedCreateInput = {
    eventId: string
    challengeId: string
  }

  export type EventChallengeUpdateInput = {
    event?: EventUpdateOneRequiredWithoutEventChallengesNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutEventChallengesNestedInput
  }

  export type EventChallengeUncheckedUpdateInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
  }

  export type EventChallengeCreateManyInput = {
    eventId: string
    challengeId: string
  }

  export type EventChallengeUpdateManyMutationInput = {

  }

  export type EventChallengeUncheckedUpdateManyInput = {
    eventId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
  }

  export type RoadmapCreateInput = {
    id?: string
    title: string
    description: string
    roleTarget: string
    createdAt?: Date | string
    phases?: RoadmapPhaseCreateNestedManyWithoutRoadmapInput
    events?: EventCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    roleTarget: string
    createdAt?: Date | string
    phases?: RoadmapPhaseUncheckedCreateNestedManyWithoutRoadmapInput
    events?: EventUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    roleTarget?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: RoadmapPhaseUpdateManyWithoutRoadmapNestedInput
    events?: EventUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    roleTarget?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: RoadmapPhaseUncheckedUpdateManyWithoutRoadmapNestedInput
    events?: EventUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapCreateManyInput = {
    id?: string
    title: string
    description: string
    roleTarget: string
    createdAt?: Date | string
  }

  export type RoadmapUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    roleTarget?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    roleTarget?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type RoadmapPhaseCreateInput = {
    id?: string
    order: number
    title: string
    level?: string | null
    duration?: string | null
    description?: string | null
    roadmap: RoadmapCreateNestedOneWithoutPhasesInput
    sections?: PhaseSectionCreateNestedManyWithoutPhaseInput
    playlists?: PhasePlaylistCreateNestedManyWithoutPhaseInput
    projects?: PhaseProjectCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseUncheckedCreateInput = {
    id?: string
    roadmapId: string
    order: number
    title: string
    level?: string | null
    duration?: string | null
    description?: string | null
    sections?: PhaseSectionUncheckedCreateNestedManyWithoutPhaseInput
    playlists?: PhasePlaylistUncheckedCreateNestedManyWithoutPhaseInput
    projects?: PhaseProjectUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadmap?: RoadmapUpdateOneRequiredWithoutPhasesNestedInput
    sections?: PhaseSectionUpdateManyWithoutPhaseNestedInput
    playlists?: PhasePlaylistUpdateManyWithoutPhaseNestedInput
    projects?: PhaseProjectUpdateManyWithoutPhaseNestedInput
  }

  export type RoadmapPhaseUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: PhaseSectionUncheckedUpdateManyWithoutPhaseNestedInput
    playlists?: PhasePlaylistUncheckedUpdateManyWithoutPhaseNestedInput
    projects?: PhaseProjectUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type RoadmapPhaseCreateManyInput = {
    id?: string
    roadmapId: string
    order: number
    title: string
    level?: string | null
    duration?: string | null
    description?: string | null
  }

  export type RoadmapPhaseUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoadmapPhaseUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhaseSectionCreateInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    phase: RoadmapPhaseCreateNestedOneWithoutSectionsInput
    items?: SectionItemCreateNestedManyWithoutSectionInput
  }

  export type PhaseSectionUncheckedCreateInput = {
    id?: string
    phaseId: string
    title: string
    description?: string | null
    order?: number
    items?: SectionItemUncheckedCreateNestedManyWithoutSectionInput
  }

  export type PhaseSectionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    phase?: RoadmapPhaseUpdateOneRequiredWithoutSectionsNestedInput
    items?: SectionItemUpdateManyWithoutSectionNestedInput
  }

  export type PhaseSectionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    items?: SectionItemUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type PhaseSectionCreateManyInput = {
    id?: string
    phaseId: string
    title: string
    description?: string | null
    order?: number
  }

  export type PhaseSectionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PhaseSectionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SectionItemCreateInput = {
    id?: string
    title: string
    order?: number
    section: PhaseSectionCreateNestedOneWithoutItemsInput
    subItems?: SubItemCreateNestedManyWithoutItemInput
  }

  export type SectionItemUncheckedCreateInput = {
    id?: string
    sectionId: string
    title: string
    order?: number
    subItems?: SubItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type SectionItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    section?: PhaseSectionUpdateOneRequiredWithoutItemsNestedInput
    subItems?: SubItemUpdateManyWithoutItemNestedInput
  }

  export type SectionItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    subItems?: SubItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type SectionItemCreateManyInput = {
    id?: string
    sectionId: string
    title: string
    order?: number
  }

  export type SectionItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SectionItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SubItemCreateInput = {
    id?: string
    title: string
    videoUrl?: string | null
    duration?: string | null
    order?: number
    item: SectionItemCreateNestedOneWithoutSubItemsInput
  }

  export type SubItemUncheckedCreateInput = {
    id?: string
    itemId: string
    title: string
    videoUrl?: string | null
    duration?: string | null
    order?: number
  }

  export type SubItemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    item?: SectionItemUpdateOneRequiredWithoutSubItemsNestedInput
  }

  export type SubItemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SubItemCreateManyInput = {
    id?: string
    itemId: string
    title: string
    videoUrl?: string | null
    duration?: string | null
    order?: number
  }

  export type SubItemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SubItemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    itemId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PhasePlaylistCreateInput = {
    id?: string
    title: string
    author?: string | null
    videoCount?: number
    url: string
    thumbnail?: string | null
    phase: RoadmapPhaseCreateNestedOneWithoutPlaylistsInput
  }

  export type PhasePlaylistUncheckedCreateInput = {
    id?: string
    phaseId: string
    title: string
    author?: string | null
    videoCount?: number
    url: string
    thumbnail?: string | null
  }

  export type PhasePlaylistUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    videoCount?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
    phase?: RoadmapPhaseUpdateOneRequiredWithoutPlaylistsNestedInput
  }

  export type PhasePlaylistUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    videoCount?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhasePlaylistCreateManyInput = {
    id?: string
    phaseId: string
    title: string
    author?: string | null
    videoCount?: number
    url: string
    thumbnail?: string | null
  }

  export type PhasePlaylistUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    videoCount?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhasePlaylistUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    videoCount?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhaseProjectCreateInput = {
    id?: string
    title: string
    description?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    phase: RoadmapPhaseCreateNestedOneWithoutProjectsInput
  }

  export type PhaseProjectUncheckedCreateInput = {
    id?: string
    phaseId: string
    title: string
    description?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PhaseProjectUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    phase?: RoadmapPhaseUpdateOneRequiredWithoutProjectsNestedInput
  }

  export type PhaseProjectUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PhaseProjectCreateManyInput = {
    id?: string
    phaseId: string
    title: string
    description?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PhaseProjectUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PhaseProjectUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type DSASheetCreateInput = {
    id?: string
    title: string
    description: string
    level: string
    createdAt?: Date | string
    topics?: DSATopicCreateNestedManyWithoutSheetInput
  }

  export type DSASheetUncheckedCreateInput = {
    id?: string
    title: string
    description: string
    level: string
    createdAt?: Date | string
    topics?: DSATopicUncheckedCreateNestedManyWithoutSheetInput
  }

  export type DSASheetUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: DSATopicUpdateManyWithoutSheetNestedInput
  }

  export type DSASheetUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    topics?: DSATopicUncheckedUpdateManyWithoutSheetNestedInput
  }

  export type DSASheetCreateManyInput = {
    id?: string
    title: string
    description: string
    level: string
    createdAt?: Date | string
  }

  export type DSASheetUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSASheetUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSATopicCreateInput = {
    id?: string
    title: string
    order?: number
    sheet: DSASheetCreateNestedOneWithoutTopicsInput
    problems?: DSAProblemCreateNestedManyWithoutTopicInput
  }

  export type DSATopicUncheckedCreateInput = {
    id?: string
    title: string
    sheetId: string
    order?: number
    problems?: DSAProblemUncheckedCreateNestedManyWithoutTopicInput
  }

  export type DSATopicUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    sheet?: DSASheetUpdateOneRequiredWithoutTopicsNestedInput
    problems?: DSAProblemUpdateManyWithoutTopicNestedInput
  }

  export type DSATopicUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sheetId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    problems?: DSAProblemUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type DSATopicCreateManyInput = {
    id?: string
    title: string
    sheetId: string
    order?: number
  }

  export type DSATopicUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type DSATopicUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sheetId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type DSAProblemCreateInput = {
    id?: string
    title: string
    description?: string | null
    difficulty: string
    order?: number
    topic: DSATopicCreateNestedOneWithoutProblemsInput
    solutions?: DSASolutionCreateNestedManyWithoutProblemInput
  }

  export type DSAProblemUncheckedCreateInput = {
    id?: string
    title: string
    description?: string | null
    difficulty: string
    topicId: string
    order?: number
    solutions?: DSASolutionUncheckedCreateNestedManyWithoutProblemInput
  }

  export type DSAProblemUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topic?: DSATopicUpdateOneRequiredWithoutProblemsNestedInput
    solutions?: DSASolutionUpdateManyWithoutProblemNestedInput
  }

  export type DSAProblemUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    solutions?: DSASolutionUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type DSAProblemCreateManyInput = {
    id?: string
    title: string
    description?: string | null
    difficulty: string
    topicId: string
    order?: number
  }

  export type DSAProblemUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type DSAProblemUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type DSASolutionCreateInput = {
    id?: string
    language: string
    code: string
    problem: DSAProblemCreateNestedOneWithoutSolutionsInput
  }

  export type DSASolutionUncheckedCreateInput = {
    id?: string
    language: string
    code: string
    problemId: string
  }

  export type DSASolutionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    problem?: DSAProblemUpdateOneRequiredWithoutSolutionsNestedInput
  }

  export type DSASolutionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    problemId?: StringFieldUpdateOperationsInput | string
  }

  export type DSASolutionCreateManyInput = {
    id?: string
    language: string
    code: string
    problemId: string
  }

  export type DSASolutionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type DSASolutionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
    problemId?: StringFieldUpdateOperationsInput | string
  }

  export type CertificateCreateInput = {
    id?: string
    certificateId: string
    participantName: string
    position?: string | null
    issuedAt?: Date | string
    event: EventCreateNestedOneWithoutCertificatesInput
    user: UserCreateNestedOneWithoutCertificatesInput
    team?: TeamCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateInput = {
    id?: string
    certificateId: string
    eventId: string
    userId: string
    teamId?: string | null
    participantName: string
    position?: string | null
    issuedAt?: Date | string
  }

  export type CertificateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutCertificatesNestedInput
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
    team?: TeamUpdateOneWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateCreateManyInput = {
    id?: string
    certificateId: string
    eventId: string
    userId: string
    teamId?: string | null
    participantName: string
    position?: string | null
    issuedAt?: Date | string
  }

  export type CertificateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateInput = {
    id?: string
    subject: string
    message: string
    recipientCount: number
    sentAt?: Date | string
    event: EventCreateNestedOneWithoutEmailLogsInput
    sender: UserCreateNestedOneWithoutEmailsSentInput
  }

  export type EmailLogUncheckedCreateInput = {
    id?: string
    eventId: string
    subject: string
    message: string
    recipientCount: number
    sentBy: string
    sentAt?: Date | string
  }

  export type EmailLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutEmailLogsNestedInput
    sender?: UserUpdateOneRequiredWithoutEmailsSentNestedInput
  }

  export type EmailLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentBy?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogCreateManyInput = {
    id?: string
    eventId: string
    subject: string
    message: string
    recipientCount: number
    sentBy: string
    sentAt?: Date | string
  }

  export type EmailLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentBy?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }
  export type JsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type EventRegistrationListRelationFilter = {
    every?: EventRegistrationWhereInput
    some?: EventRegistrationWhereInput
    none?: EventRegistrationWhereInput
  }

  export type TeamListRelationFilter = {
    every?: TeamWhereInput
    some?: TeamWhereInput
    none?: TeamWhereInput
  }

  export type TeamMemberListRelationFilter = {
    every?: TeamMemberWhereInput
    some?: TeamMemberWhereInput
    none?: TeamMemberWhereInput
  }

  export type TeamJoinRequestListRelationFilter = {
    every?: TeamJoinRequestWhereInput
    some?: TeamJoinRequestWhereInput
    none?: TeamJoinRequestWhereInput
  }

  export type EventSubmissionListRelationFilter = {
    every?: EventSubmissionWhereInput
    some?: EventSubmissionWhereInput
    none?: EventSubmissionWhereInput
  }

  export type UserChallengeProgressListRelationFilter = {
    every?: UserChallengeProgressWhereInput
    some?: UserChallengeProgressWhereInput
    none?: UserChallengeProgressWhereInput
  }

  export type UserTaskCompletionListRelationFilter = {
    every?: UserTaskCompletionWhereInput
    some?: UserTaskCompletionWhereInput
    none?: UserTaskCompletionWhereInput
  }

  export type UserBadgeListRelationFilter = {
    every?: UserBadgeWhereInput
    some?: UserBadgeWhereInput
    none?: UserBadgeWhereInput
  }

  export type UserAchievementListRelationFilter = {
    every?: UserAchievementWhereInput
    some?: UserAchievementWhereInput
    none?: UserAchievementWhereInput
  }

  export type LeaderboardListRelationFilter = {
    every?: LeaderboardWhereInput
    some?: LeaderboardWhereInput
    none?: LeaderboardWhereInput
  }

  export type EventListRelationFilter = {
    every?: EventWhereInput
    some?: EventWhereInput
    none?: EventWhereInput
  }

  export type ChallengeListRelationFilter = {
    every?: ChallengeWhereInput
    some?: ChallengeWhereInput
    none?: ChallengeWhereInput
  }

  export type CertificateListRelationFilter = {
    every?: CertificateWhereInput
    some?: CertificateWhereInput
    none?: CertificateWhereInput
  }

  export type EmailLogListRelationFilter = {
    every?: EmailLogWhereInput
    some?: EmailLogWhereInput
    none?: EmailLogWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EventRegistrationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamMemberOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TeamJoinRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventSubmissionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserChallengeProgressOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserTaskCompletionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserBadgeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserAchievementOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaderboardOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type CertificateOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmailLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    whatsapp?: SortOrder
    gender?: SortOrder
    graduation?: SortOrder
    specialization?: SortOrder
    year?: SortOrder
    regNumber?: SortOrder
    skills?: SortOrder
    domain?: SortOrder
    githubUrl?: SortOrder
    codingUrl?: SortOrder
    profilePicture?: SortOrder
    totalPoints?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActive?: SortOrder
  }

  export type UserAvgOrderByAggregateInput = {
    totalPoints?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    level?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    whatsapp?: SortOrder
    gender?: SortOrder
    graduation?: SortOrder
    specialization?: SortOrder
    year?: SortOrder
    regNumber?: SortOrder
    domain?: SortOrder
    githubUrl?: SortOrder
    codingUrl?: SortOrder
    profilePicture?: SortOrder
    totalPoints?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActive?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    fullName?: SortOrder
    whatsapp?: SortOrder
    gender?: SortOrder
    graduation?: SortOrder
    specialization?: SortOrder
    year?: SortOrder
    regNumber?: SortOrder
    domain?: SortOrder
    githubUrl?: SortOrder
    codingUrl?: SortOrder
    profilePicture?: SortOrder
    totalPoints?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    lastActive?: SortOrder
  }

  export type UserSumOrderByAggregateInput = {
    totalPoints?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    level?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }
  export type JsonNullableWithAggregatesFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, Exclude<keyof Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>,
        Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<JsonNullableWithAggregatesFilterBase<$PrismaModel>>, 'path'>>

  export type JsonNullableWithAggregatesFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedJsonNullableFilter<$PrismaModel>
    _max?: NestedJsonNullableFilter<$PrismaModel>
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type EventCategoryNullableRelationFilter = {
    is?: EventCategoryWhereInput | null
    isNot?: EventCategoryWhereInput | null
  }

  export type EventCategoryListRelationFilter = {
    every?: EventCategoryWhereInput
    some?: EventCategoryWhereInput
    none?: EventCategoryWhereInput
  }

  export type EventTypeListRelationFilter = {
    every?: EventTypeWhereInput
    some?: EventTypeWhereInput
    none?: EventTypeWhereInput
  }

  export type EventCategoryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventTypeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCategoryCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCategoryMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
  }

  export type EventCategoryMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    icon?: SortOrder
    color?: SortOrder
    parentId?: SortOrder
    createdAt?: SortOrder
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type EventCategoryRelationFilter = {
    is?: EventCategoryWhereInput
    isNot?: EventCategoryWhereInput
  }

  export type EventTypeCategoryIdSlugCompoundUniqueInput = {
    categoryId: string
    slug: string
  }

  export type EventTypeCountOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    defaultDurationHours?: SortOrder
    createdAt?: SortOrder
  }

  export type EventTypeAvgOrderByAggregateInput = {
    defaultDurationHours?: SortOrder
  }

  export type EventTypeMaxOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    defaultDurationHours?: SortOrder
    createdAt?: SortOrder
  }

  export type EventTypeMinOrderByAggregateInput = {
    id?: SortOrder
    categoryId?: SortOrder
    name?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    defaultDurationHours?: SortOrder
    createdAt?: SortOrder
  }

  export type EventTypeSumOrderByAggregateInput = {
    defaultDurationHours?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type RoadmapNullableRelationFilter = {
    is?: RoadmapWhereInput | null
    isNot?: RoadmapWhereInput | null
  }

  export type EventChallengeListRelationFilter = {
    every?: EventChallengeWhereInput
    some?: EventChallengeWhereInput
    none?: EventChallengeWhereInput
  }

  export type EventChallengeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EventCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    eventType?: SortOrder
    mode?: SortOrder
    registrationStart?: SortOrder
    registrationEnd?: SortOrder
    maxParticipants?: SortOrder
    isTeamEvent?: SortOrder
    allowIndividual?: SortOrder
    minTeamSize?: SortOrder
    maxTeamSize?: SortOrder
    teamFormationDeadline?: SortOrder
    restrictSameCollege?: SortOrder
    eventStart?: SortOrder
    eventEnd?: SortOrder
    isPaid?: SortOrder
    registrationFee?: SortOrder
    currency?: SortOrder
    hasSubmission?: SortOrder
    submissionStart?: SortOrder
    submissionDeadline?: SortOrder
    submissionTemplateUrl?: SortOrder
    rules?: SortOrder
    eligibility?: SortOrder
    rewards?: SortOrder
    prizes?: SortOrder
    venue?: SortOrder
    meetingLink?: SortOrder
    resourceLinks?: SortOrder
    bannerImage?: SortOrder
    images?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    hasRoadmap?: SortOrder
    roadmapId?: SortOrder
    hasChallenges?: SortOrder
    problemCount?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventAvgOrderByAggregateInput = {
    maxParticipants?: SortOrder
    minTeamSize?: SortOrder
    maxTeamSize?: SortOrder
    registrationFee?: SortOrder
    problemCount?: SortOrder
  }

  export type EventMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    eventType?: SortOrder
    mode?: SortOrder
    registrationStart?: SortOrder
    registrationEnd?: SortOrder
    maxParticipants?: SortOrder
    isTeamEvent?: SortOrder
    allowIndividual?: SortOrder
    minTeamSize?: SortOrder
    maxTeamSize?: SortOrder
    teamFormationDeadline?: SortOrder
    restrictSameCollege?: SortOrder
    eventStart?: SortOrder
    eventEnd?: SortOrder
    isPaid?: SortOrder
    registrationFee?: SortOrder
    currency?: SortOrder
    hasSubmission?: SortOrder
    submissionStart?: SortOrder
    submissionDeadline?: SortOrder
    submissionTemplateUrl?: SortOrder
    rules?: SortOrder
    eligibility?: SortOrder
    rewards?: SortOrder
    venue?: SortOrder
    meetingLink?: SortOrder
    bannerImage?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    hasRoadmap?: SortOrder
    roadmapId?: SortOrder
    hasChallenges?: SortOrder
    problemCount?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    categoryId?: SortOrder
    eventType?: SortOrder
    mode?: SortOrder
    registrationStart?: SortOrder
    registrationEnd?: SortOrder
    maxParticipants?: SortOrder
    isTeamEvent?: SortOrder
    allowIndividual?: SortOrder
    minTeamSize?: SortOrder
    maxTeamSize?: SortOrder
    teamFormationDeadline?: SortOrder
    restrictSameCollege?: SortOrder
    eventStart?: SortOrder
    eventEnd?: SortOrder
    isPaid?: SortOrder
    registrationFee?: SortOrder
    currency?: SortOrder
    hasSubmission?: SortOrder
    submissionStart?: SortOrder
    submissionDeadline?: SortOrder
    submissionTemplateUrl?: SortOrder
    rules?: SortOrder
    eligibility?: SortOrder
    rewards?: SortOrder
    venue?: SortOrder
    meetingLink?: SortOrder
    bannerImage?: SortOrder
    status?: SortOrder
    isFeatured?: SortOrder
    hasRoadmap?: SortOrder
    roadmapId?: SortOrder
    hasChallenges?: SortOrder
    problemCount?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EventSumOrderByAggregateInput = {
    maxParticipants?: SortOrder
    minTeamSize?: SortOrder
    maxTeamSize?: SortOrder
    registrationFee?: SortOrder
    problemCount?: SortOrder
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type EventRelationFilter = {
    is?: EventWhereInput
    isNot?: EventWhereInput
  }

  export type UserRelationFilter = {
    is?: UserWhereInput
    isNot?: UserWhereInput
  }

  export type TeamEventIdTeamNameCompoundUniqueInput = {
    eventId: string
    teamName: string
  }

  export type TeamCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    teamName?: SortOrder
    teamLeaderId?: SortOrder
    isComplete?: SortOrder
    isLocked?: SortOrder
    collegeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    teamName?: SortOrder
    teamLeaderId?: SortOrder
    isComplete?: SortOrder
    isLocked?: SortOrder
    collegeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    teamName?: SortOrder
    teamLeaderId?: SortOrder
    isComplete?: SortOrder
    isLocked?: SortOrder
    collegeName?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TeamRelationFilter = {
    is?: TeamWhereInput
    isNot?: TeamWhereInput
  }

  export type TeamMemberTeamIdUserIdCompoundUniqueInput = {
    teamId: string
    userId: string
  }

  export type TeamMemberCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    isLeader?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
  }

  export type TeamMemberMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    isLeader?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
  }

  export type TeamMemberMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    isLeader?: SortOrder
    status?: SortOrder
    joinedAt?: SortOrder
    leftAt?: SortOrder
  }

  export type TeamJoinRequestTeamIdUserIdCompoundUniqueInput = {
    teamId: string
    userId: string
  }

  export type TeamJoinRequestCountOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    requestType?: SortOrder
    status?: SortOrder
    message?: SortOrder
    responseMessage?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type TeamJoinRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    requestType?: SortOrder
    status?: SortOrder
    message?: SortOrder
    responseMessage?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type TeamJoinRequestMinOrderByAggregateInput = {
    id?: SortOrder
    teamId?: SortOrder
    userId?: SortOrder
    requestType?: SortOrder
    status?: SortOrder
    message?: SortOrder
    responseMessage?: SortOrder
    createdAt?: SortOrder
    respondedAt?: SortOrder
  }

  export type TeamNullableRelationFilter = {
    is?: TeamWhereInput | null
    isNot?: TeamWhereInput | null
  }

  export type EventRegistrationEventIdUserIdCompoundUniqueInput = {
    eventId: string
    userId: string
  }

  export type EventRegistrationCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    participationType?: SortOrder
    paymentStatus?: SortOrder
    paymentId?: SortOrder
    amountPaid?: SortOrder
    paidAt?: SortOrder
    status?: SortOrder
    registeredAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type EventRegistrationAvgOrderByAggregateInput = {
    amountPaid?: SortOrder
  }

  export type EventRegistrationMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    participationType?: SortOrder
    paymentStatus?: SortOrder
    paymentId?: SortOrder
    amountPaid?: SortOrder
    paidAt?: SortOrder
    status?: SortOrder
    registeredAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type EventRegistrationMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    participationType?: SortOrder
    paymentStatus?: SortOrder
    paymentId?: SortOrder
    amountPaid?: SortOrder
    paidAt?: SortOrder
    status?: SortOrder
    registeredAt?: SortOrder
    cancelledAt?: SortOrder
  }

  export type EventRegistrationSumOrderByAggregateInput = {
    amountPaid?: SortOrder
  }

  export type EventSubmissionEventIdUserIdCompoundUniqueInput = {
    eventId: string
    userId: string
  }

  export type EventSubmissionEventIdTeamIdCompoundUniqueInput = {
    eventId: string
    teamId: string
  }

  export type EventSubmissionCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    projectDeckUrl?: SortOrder
    presentationPdfUrl?: SortOrder
    mvpLink?: SortOrder
    demoVideoUrl?: SortOrder
    githubRepoUrl?: SortOrder
    technologiesUsed?: SortOrder
    aiToolsIntegrated?: SortOrder
    solutionDescription?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    evaluatedAt?: SortOrder
  }

  export type EventSubmissionAvgOrderByAggregateInput = {
    score?: SortOrder
    rank?: SortOrder
  }

  export type EventSubmissionMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    projectDeckUrl?: SortOrder
    presentationPdfUrl?: SortOrder
    mvpLink?: SortOrder
    demoVideoUrl?: SortOrder
    githubRepoUrl?: SortOrder
    technologiesUsed?: SortOrder
    aiToolsIntegrated?: SortOrder
    solutionDescription?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    evaluatedAt?: SortOrder
  }

  export type EventSubmissionMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    projectDeckUrl?: SortOrder
    presentationPdfUrl?: SortOrder
    mvpLink?: SortOrder
    demoVideoUrl?: SortOrder
    githubRepoUrl?: SortOrder
    technologiesUsed?: SortOrder
    aiToolsIntegrated?: SortOrder
    solutionDescription?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    feedback?: SortOrder
    status?: SortOrder
    submittedAt?: SortOrder
    updatedAt?: SortOrder
    evaluatedAt?: SortOrder
  }

  export type EventSubmissionSumOrderByAggregateInput = {
    score?: SortOrder
    rank?: SortOrder
  }

  export type ChallengeTaskListRelationFilter = {
    every?: ChallengeTaskWhereInput
    some?: ChallengeTaskWhereInput
    none?: ChallengeTaskWhereInput
  }

  export type ChallengeTaskOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ChallengeCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    challengeType?: SortOrder
    difficulty?: SortOrder
    durationDays?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    category?: SortOrder
    tags?: SortOrder
    pointsPerDay?: SortOrder
    bonusPoints?: SortOrder
    badges?: SortOrder
    hasLeaderboard?: SortOrder
    isPublic?: SortOrder
    maxParticipants?: SortOrder
    bannerImage?: SortOrder
    icon?: SortOrder
    status?: SortOrder
    totalParticipants?: SortOrder
    activeParticipants?: SortOrder
    completionRate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeAvgOrderByAggregateInput = {
    durationDays?: SortOrder
    pointsPerDay?: SortOrder
    maxParticipants?: SortOrder
    totalParticipants?: SortOrder
    activeParticipants?: SortOrder
    completionRate?: SortOrder
  }

  export type ChallengeMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    challengeType?: SortOrder
    difficulty?: SortOrder
    durationDays?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    category?: SortOrder
    pointsPerDay?: SortOrder
    hasLeaderboard?: SortOrder
    isPublic?: SortOrder
    maxParticipants?: SortOrder
    bannerImage?: SortOrder
    icon?: SortOrder
    status?: SortOrder
    totalParticipants?: SortOrder
    activeParticipants?: SortOrder
    completionRate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    slug?: SortOrder
    description?: SortOrder
    challengeType?: SortOrder
    difficulty?: SortOrder
    durationDays?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    category?: SortOrder
    pointsPerDay?: SortOrder
    hasLeaderboard?: SortOrder
    isPublic?: SortOrder
    maxParticipants?: SortOrder
    bannerImage?: SortOrder
    icon?: SortOrder
    status?: SortOrder
    totalParticipants?: SortOrder
    activeParticipants?: SortOrder
    completionRate?: SortOrder
    createdBy?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ChallengeSumOrderByAggregateInput = {
    durationDays?: SortOrder
    pointsPerDay?: SortOrder
    maxParticipants?: SortOrder
    totalParticipants?: SortOrder
    activeParticipants?: SortOrder
    completionRate?: SortOrder
  }

  export type ChallengeRelationFilter = {
    is?: ChallengeWhereInput
    isNot?: ChallengeWhereInput
  }

  export type ChallengeTaskChallengeIdDayNumberCompoundUniqueInput = {
    challengeId: string
    dayNumber: number
  }

  export type ChallengeTaskCountOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    taskType?: SortOrder
    content?: SortOrder
    resourceLinks?: SortOrder
    hints?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    autoValidate?: SortOrder
    validationUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ChallengeTaskAvgOrderByAggregateInput = {
    dayNumber?: SortOrder
    points?: SortOrder
  }

  export type ChallengeTaskMaxOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    taskType?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    autoValidate?: SortOrder
    validationUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ChallengeTaskMinOrderByAggregateInput = {
    id?: SortOrder
    challengeId?: SortOrder
    dayNumber?: SortOrder
    title?: SortOrder
    description?: SortOrder
    taskType?: SortOrder
    difficulty?: SortOrder
    points?: SortOrder
    autoValidate?: SortOrder
    validationUrl?: SortOrder
    createdAt?: SortOrder
  }

  export type ChallengeTaskSumOrderByAggregateInput = {
    dayNumber?: SortOrder
    points?: SortOrder
  }

  export type DecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type UserChallengeProgressUserIdChallengeIdCompoundUniqueInput = {
    userId: string
    challengeId: string
  }

  export type UserChallengeProgressCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    status?: SortOrder
    completedDays?: SortOrder
    totalDays?: SortOrder
    completionPercentage?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrder
    totalPoints?: SortOrder
    bonusPoints?: SortOrder
    currentRank?: SortOrder
    startedAt?: SortOrder
    lastActivity?: SortOrder
    completedAt?: SortOrder
    certificateIssued?: SortOrder
    certificateUrl?: SortOrder
    completedTaskIds?: SortOrder
    skippedTaskIds?: SortOrder
  }

  export type UserChallengeProgressAvgOrderByAggregateInput = {
    completedDays?: SortOrder
    totalDays?: SortOrder
    completionPercentage?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalPoints?: SortOrder
    bonusPoints?: SortOrder
    currentRank?: SortOrder
  }

  export type UserChallengeProgressMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    status?: SortOrder
    completedDays?: SortOrder
    totalDays?: SortOrder
    completionPercentage?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrder
    totalPoints?: SortOrder
    bonusPoints?: SortOrder
    currentRank?: SortOrder
    startedAt?: SortOrder
    lastActivity?: SortOrder
    completedAt?: SortOrder
    certificateIssued?: SortOrder
    certificateUrl?: SortOrder
  }

  export type UserChallengeProgressMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    status?: SortOrder
    completedDays?: SortOrder
    totalDays?: SortOrder
    completionPercentage?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    lastCompletedDate?: SortOrder
    totalPoints?: SortOrder
    bonusPoints?: SortOrder
    currentRank?: SortOrder
    startedAt?: SortOrder
    lastActivity?: SortOrder
    completedAt?: SortOrder
    certificateIssued?: SortOrder
    certificateUrl?: SortOrder
  }

  export type UserChallengeProgressSumOrderByAggregateInput = {
    completedDays?: SortOrder
    totalDays?: SortOrder
    completionPercentage?: SortOrder
    currentStreak?: SortOrder
    longestStreak?: SortOrder
    totalPoints?: SortOrder
    bonusPoints?: SortOrder
    currentRank?: SortOrder
  }

  export type DecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type ChallengeTaskRelationFilter = {
    is?: ChallengeTaskWhereInput
    isNot?: ChallengeTaskWhereInput
  }

  export type UserChallengeProgressRelationFilter = {
    is?: UserChallengeProgressWhereInput
    isNot?: UserChallengeProgressWhereInput
  }

  export type UserTaskCompletionUserIdTaskIdCompoundUniqueInput = {
    userId: string
    taskId: string
  }

  export type UserTaskCompletionCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    taskId?: SortOrder
    progressId?: SortOrder
    completedAt?: SortOrder
    timeTaken?: SortOrder
    submissionUrl?: SortOrder
    submissionText?: SortOrder
    submissionFiles?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    score?: SortOrder
    pointsEarned?: SortOrder
    userNotes?: SortOrder
    feedback?: SortOrder
  }

  export type UserTaskCompletionAvgOrderByAggregateInput = {
    timeTaken?: SortOrder
    score?: SortOrder
    pointsEarned?: SortOrder
  }

  export type UserTaskCompletionMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    taskId?: SortOrder
    progressId?: SortOrder
    completedAt?: SortOrder
    timeTaken?: SortOrder
    submissionUrl?: SortOrder
    submissionText?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    score?: SortOrder
    pointsEarned?: SortOrder
    userNotes?: SortOrder
    feedback?: SortOrder
  }

  export type UserTaskCompletionMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    challengeId?: SortOrder
    taskId?: SortOrder
    progressId?: SortOrder
    completedAt?: SortOrder
    timeTaken?: SortOrder
    submissionUrl?: SortOrder
    submissionText?: SortOrder
    isVerified?: SortOrder
    verifiedBy?: SortOrder
    verifiedAt?: SortOrder
    score?: SortOrder
    pointsEarned?: SortOrder
    userNotes?: SortOrder
    feedback?: SortOrder
  }

  export type UserTaskCompletionSumOrderByAggregateInput = {
    timeTaken?: SortOrder
    score?: SortOrder
    pointsEarned?: SortOrder
  }

  export type UserBadgeCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeType?: SortOrder
    badgeName?: SortOrder
    badgeDescription?: SortOrder
    badgeIcon?: SortOrder
    badgeColor?: SortOrder
    relatedChallengeId?: SortOrder
    relatedEventId?: SortOrder
    pointsAwarded?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserBadgeAvgOrderByAggregateInput = {
    pointsAwarded?: SortOrder
  }

  export type UserBadgeMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeType?: SortOrder
    badgeName?: SortOrder
    badgeDescription?: SortOrder
    badgeIcon?: SortOrder
    badgeColor?: SortOrder
    relatedChallengeId?: SortOrder
    relatedEventId?: SortOrder
    pointsAwarded?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserBadgeMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    badgeType?: SortOrder
    badgeName?: SortOrder
    badgeDescription?: SortOrder
    badgeIcon?: SortOrder
    badgeColor?: SortOrder
    relatedChallengeId?: SortOrder
    relatedEventId?: SortOrder
    pointsAwarded?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserBadgeSumOrderByAggregateInput = {
    pointsAwarded?: SortOrder
  }

  export type UserAchievementUserIdAchievementTypeCompoundUniqueInput = {
    userId: string
    achievementType: string
  }

  export type UserAchievementCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementType?: SortOrder
    achievementName?: SortOrder
    description?: SortOrder
    value?: SortOrder
    target?: SortOrder
    rarity?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserAchievementAvgOrderByAggregateInput = {
    value?: SortOrder
    target?: SortOrder
  }

  export type UserAchievementMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementType?: SortOrder
    achievementName?: SortOrder
    description?: SortOrder
    value?: SortOrder
    target?: SortOrder
    rarity?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserAchievementMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    achievementType?: SortOrder
    achievementName?: SortOrder
    description?: SortOrder
    value?: SortOrder
    target?: SortOrder
    rarity?: SortOrder
    earnedAt?: SortOrder
  }

  export type UserAchievementSumOrderByAggregateInput = {
    value?: SortOrder
    target?: SortOrder
  }

  export type LeaderboardUserIdLeaderboardTypeRelatedIdTimePeriodCompoundUniqueInput = {
    userId: string
    leaderboardType: string
    relatedId: string
    timePeriod: string
  }

  export type LeaderboardCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leaderboardType?: SortOrder
    relatedId?: SortOrder
    timePeriod?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    totalCompletions?: SortOrder
    currentStreak?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardAvgOrderByAggregateInput = {
    score?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    totalCompletions?: SortOrder
    currentStreak?: SortOrder
  }

  export type LeaderboardMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leaderboardType?: SortOrder
    relatedId?: SortOrder
    timePeriod?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    totalCompletions?: SortOrder
    currentStreak?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    leaderboardType?: SortOrder
    relatedId?: SortOrder
    timePeriod?: SortOrder
    score?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    totalCompletions?: SortOrder
    currentStreak?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaderboardSumOrderByAggregateInput = {
    score?: SortOrder
    rank?: SortOrder
    previousRank?: SortOrder
    totalCompletions?: SortOrder
    currentStreak?: SortOrder
  }

  export type EventChallengeEventIdChallengeIdCompoundUniqueInput = {
    eventId: string
    challengeId: string
  }

  export type EventChallengeCountOrderByAggregateInput = {
    eventId?: SortOrder
    challengeId?: SortOrder
  }

  export type EventChallengeMaxOrderByAggregateInput = {
    eventId?: SortOrder
    challengeId?: SortOrder
  }

  export type EventChallengeMinOrderByAggregateInput = {
    eventId?: SortOrder
    challengeId?: SortOrder
  }

  export type RoadmapPhaseListRelationFilter = {
    every?: RoadmapPhaseWhereInput
    some?: RoadmapPhaseWhereInput
    none?: RoadmapPhaseWhereInput
  }

  export type RoadmapPhaseOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    roleTarget?: SortOrder
    createdAt?: SortOrder
  }

  export type RoadmapMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    roleTarget?: SortOrder
    createdAt?: SortOrder
  }

  export type RoadmapMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    roleTarget?: SortOrder
    createdAt?: SortOrder
  }

  export type RoadmapRelationFilter = {
    is?: RoadmapWhereInput
    isNot?: RoadmapWhereInput
  }

  export type PhaseSectionListRelationFilter = {
    every?: PhaseSectionWhereInput
    some?: PhaseSectionWhereInput
    none?: PhaseSectionWhereInput
  }

  export type PhasePlaylistListRelationFilter = {
    every?: PhasePlaylistWhereInput
    some?: PhasePlaylistWhereInput
    none?: PhasePlaylistWhereInput
  }

  export type PhaseProjectListRelationFilter = {
    every?: PhaseProjectWhereInput
    some?: PhaseProjectWhereInput
    none?: PhaseProjectWhereInput
  }

  export type PhaseSectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhasePlaylistOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhaseProjectOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type RoadmapPhaseCountOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    level?: SortOrder
    duration?: SortOrder
    description?: SortOrder
  }

  export type RoadmapPhaseAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type RoadmapPhaseMaxOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    level?: SortOrder
    duration?: SortOrder
    description?: SortOrder
  }

  export type RoadmapPhaseMinOrderByAggregateInput = {
    id?: SortOrder
    roadmapId?: SortOrder
    order?: SortOrder
    title?: SortOrder
    level?: SortOrder
    duration?: SortOrder
    description?: SortOrder
  }

  export type RoadmapPhaseSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type RoadmapPhaseRelationFilter = {
    is?: RoadmapPhaseWhereInput
    isNot?: RoadmapPhaseWhereInput
  }

  export type SectionItemListRelationFilter = {
    every?: SectionItemWhereInput
    some?: SectionItemWhereInput
    none?: SectionItemWhereInput
  }

  export type SectionItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PhaseSectionCountOrderByAggregateInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
  }

  export type PhaseSectionAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PhaseSectionMaxOrderByAggregateInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
  }

  export type PhaseSectionMinOrderByAggregateInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    order?: SortOrder
  }

  export type PhaseSectionSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PhaseSectionRelationFilter = {
    is?: PhaseSectionWhereInput
    isNot?: PhaseSectionWhereInput
  }

  export type SubItemListRelationFilter = {
    every?: SubItemWhereInput
    some?: SubItemWhereInput
    none?: SubItemWhereInput
  }

  export type SubItemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type SectionItemCountOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    title?: SortOrder
    order?: SortOrder
  }

  export type SectionItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SectionItemMaxOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    title?: SortOrder
    order?: SortOrder
  }

  export type SectionItemMinOrderByAggregateInput = {
    id?: SortOrder
    sectionId?: SortOrder
    title?: SortOrder
    order?: SortOrder
  }

  export type SectionItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SectionItemRelationFilter = {
    is?: SectionItemWhereInput
    isNot?: SectionItemWhereInput
  }

  export type SubItemCountOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    duration?: SortOrder
    order?: SortOrder
  }

  export type SubItemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type SubItemMaxOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    duration?: SortOrder
    order?: SortOrder
  }

  export type SubItemMinOrderByAggregateInput = {
    id?: SortOrder
    itemId?: SortOrder
    title?: SortOrder
    videoUrl?: SortOrder
    duration?: SortOrder
    order?: SortOrder
  }

  export type SubItemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type PhasePlaylistCountOrderByAggregateInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    author?: SortOrder
    videoCount?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
  }

  export type PhasePlaylistAvgOrderByAggregateInput = {
    videoCount?: SortOrder
  }

  export type PhasePlaylistMaxOrderByAggregateInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    author?: SortOrder
    videoCount?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
  }

  export type PhasePlaylistMinOrderByAggregateInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    author?: SortOrder
    videoCount?: SortOrder
    url?: SortOrder
    thumbnail?: SortOrder
  }

  export type PhasePlaylistSumOrderByAggregateInput = {
    videoCount?: SortOrder
  }

  export type PhaseProjectCountOrderByAggregateInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
    tags?: SortOrder
  }

  export type PhaseProjectMaxOrderByAggregateInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type PhaseProjectMinOrderByAggregateInput = {
    id?: SortOrder
    phaseId?: SortOrder
    title?: SortOrder
    description?: SortOrder
  }

  export type DSATopicListRelationFilter = {
    every?: DSATopicWhereInput
    some?: DSATopicWhereInput
    none?: DSATopicWhereInput
  }

  export type DSATopicOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DSASheetCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
  }

  export type DSASheetMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
  }

  export type DSASheetMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    level?: SortOrder
    createdAt?: SortOrder
  }

  export type DSASheetRelationFilter = {
    is?: DSASheetWhereInput
    isNot?: DSASheetWhereInput
  }

  export type DSAProblemListRelationFilter = {
    every?: DSAProblemWhereInput
    some?: DSAProblemWhereInput
    none?: DSAProblemWhereInput
  }

  export type DSAProblemOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DSATopicCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    sheetId?: SortOrder
    order?: SortOrder
  }

  export type DSATopicAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DSATopicMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    sheetId?: SortOrder
    order?: SortOrder
  }

  export type DSATopicMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    sheetId?: SortOrder
    order?: SortOrder
  }

  export type DSATopicSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DSATopicRelationFilter = {
    is?: DSATopicWhereInput
    isNot?: DSATopicWhereInput
  }

  export type DSASolutionListRelationFilter = {
    every?: DSASolutionWhereInput
    some?: DSASolutionWhereInput
    none?: DSASolutionWhereInput
  }

  export type DSASolutionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DSAProblemCountOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    topicId?: SortOrder
    order?: SortOrder
  }

  export type DSAProblemAvgOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DSAProblemMaxOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    topicId?: SortOrder
    order?: SortOrder
  }

  export type DSAProblemMinOrderByAggregateInput = {
    id?: SortOrder
    title?: SortOrder
    description?: SortOrder
    difficulty?: SortOrder
    topicId?: SortOrder
    order?: SortOrder
  }

  export type DSAProblemSumOrderByAggregateInput = {
    order?: SortOrder
  }

  export type DSAProblemRelationFilter = {
    is?: DSAProblemWhereInput
    isNot?: DSAProblemWhereInput
  }

  export type DSASolutionCountOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    code?: SortOrder
    problemId?: SortOrder
  }

  export type DSASolutionMaxOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    code?: SortOrder
    problemId?: SortOrder
  }

  export type DSASolutionMinOrderByAggregateInput = {
    id?: SortOrder
    language?: SortOrder
    code?: SortOrder
    problemId?: SortOrder
  }

  export type CertificateCountOrderByAggregateInput = {
    id?: SortOrder
    certificateId?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    participantName?: SortOrder
    position?: SortOrder
    issuedAt?: SortOrder
  }

  export type CertificateMaxOrderByAggregateInput = {
    id?: SortOrder
    certificateId?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    participantName?: SortOrder
    position?: SortOrder
    issuedAt?: SortOrder
  }

  export type CertificateMinOrderByAggregateInput = {
    id?: SortOrder
    certificateId?: SortOrder
    eventId?: SortOrder
    userId?: SortOrder
    teamId?: SortOrder
    participantName?: SortOrder
    position?: SortOrder
    issuedAt?: SortOrder
  }

  export type EmailLogCountOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    recipientCount?: SortOrder
    sentBy?: SortOrder
    sentAt?: SortOrder
  }

  export type EmailLogAvgOrderByAggregateInput = {
    recipientCount?: SortOrder
  }

  export type EmailLogMaxOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    recipientCount?: SortOrder
    sentBy?: SortOrder
    sentAt?: SortOrder
  }

  export type EmailLogMinOrderByAggregateInput = {
    id?: SortOrder
    eventId?: SortOrder
    subject?: SortOrder
    message?: SortOrder
    recipientCount?: SortOrder
    sentBy?: SortOrder
    sentAt?: SortOrder
  }

  export type EmailLogSumOrderByAggregateInput = {
    recipientCount?: SortOrder
  }

  export type EventRegistrationCreateNestedManyWithoutUserInput = {
    create?: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput> | EventRegistrationCreateWithoutUserInput[] | EventRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutUserInput | EventRegistrationCreateOrConnectWithoutUserInput[]
    createMany?: EventRegistrationCreateManyUserInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutLeaderInput = {
    create?: XOR<TeamCreateWithoutLeaderInput, TeamUncheckedCreateWithoutLeaderInput> | TeamCreateWithoutLeaderInput[] | TeamUncheckedCreateWithoutLeaderInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeaderInput | TeamCreateOrConnectWithoutLeaderInput[]
    createMany?: TeamCreateManyLeaderInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamMemberCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamJoinRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamJoinRequestCreateWithoutUserInput, TeamJoinRequestUncheckedCreateWithoutUserInput> | TeamJoinRequestCreateWithoutUserInput[] | TeamJoinRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamJoinRequestCreateOrConnectWithoutUserInput | TeamJoinRequestCreateOrConnectWithoutUserInput[]
    createMany?: TeamJoinRequestCreateManyUserInputEnvelope
    connect?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
  }

  export type EventSubmissionCreateNestedManyWithoutUserInput = {
    create?: XOR<EventSubmissionCreateWithoutUserInput, EventSubmissionUncheckedCreateWithoutUserInput> | EventSubmissionCreateWithoutUserInput[] | EventSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventSubmissionCreateOrConnectWithoutUserInput | EventSubmissionCreateOrConnectWithoutUserInput[]
    createMany?: EventSubmissionCreateManyUserInputEnvelope
    connect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
  }

  export type UserChallengeProgressCreateNestedManyWithoutUserInput = {
    create?: XOR<UserChallengeProgressCreateWithoutUserInput, UserChallengeProgressUncheckedCreateWithoutUserInput> | UserChallengeProgressCreateWithoutUserInput[] | UserChallengeProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeProgressCreateOrConnectWithoutUserInput | UserChallengeProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserChallengeProgressCreateManyUserInputEnvelope
    connect?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
  }

  export type UserTaskCompletionCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTaskCompletionCreateWithoutUserInput, UserTaskCompletionUncheckedCreateWithoutUserInput> | UserTaskCompletionCreateWithoutUserInput[] | UserTaskCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTaskCompletionCreateOrConnectWithoutUserInput | UserTaskCompletionCreateOrConnectWithoutUserInput[]
    createMany?: UserTaskCompletionCreateManyUserInputEnvelope
    connect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
  }

  export type UserBadgeCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserAchievementCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type LeaderboardCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput> | LeaderboardCreateWithoutUserInput[] | LeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutUserInput | LeaderboardCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardCreateManyUserInputEnvelope
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutCreatorInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ChallengeCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ChallengeCreateWithoutCreatorInput, ChallengeUncheckedCreateWithoutCreatorInput> | ChallengeCreateWithoutCreatorInput[] | ChallengeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutCreatorInput | ChallengeCreateOrConnectWithoutCreatorInput[]
    createMany?: ChallengeCreateManyCreatorInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type EmailLogCreateNestedManyWithoutSenderInput = {
    create?: XOR<EmailLogCreateWithoutSenderInput, EmailLogUncheckedCreateWithoutSenderInput> | EmailLogCreateWithoutSenderInput[] | EmailLogUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutSenderInput | EmailLogCreateOrConnectWithoutSenderInput[]
    createMany?: EmailLogCreateManySenderInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type EventRegistrationUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput> | EventRegistrationCreateWithoutUserInput[] | EventRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutUserInput | EventRegistrationCreateOrConnectWithoutUserInput[]
    createMany?: EventRegistrationCreateManyUserInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutLeaderInput = {
    create?: XOR<TeamCreateWithoutLeaderInput, TeamUncheckedCreateWithoutLeaderInput> | TeamCreateWithoutLeaderInput[] | TeamUncheckedCreateWithoutLeaderInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeaderInput | TeamCreateOrConnectWithoutLeaderInput[]
    createMany?: TeamCreateManyLeaderInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TeamJoinRequestCreateWithoutUserInput, TeamJoinRequestUncheckedCreateWithoutUserInput> | TeamJoinRequestCreateWithoutUserInput[] | TeamJoinRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamJoinRequestCreateOrConnectWithoutUserInput | TeamJoinRequestCreateOrConnectWithoutUserInput[]
    createMany?: TeamJoinRequestCreateManyUserInputEnvelope
    connect?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
  }

  export type EventSubmissionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<EventSubmissionCreateWithoutUserInput, EventSubmissionUncheckedCreateWithoutUserInput> | EventSubmissionCreateWithoutUserInput[] | EventSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventSubmissionCreateOrConnectWithoutUserInput | EventSubmissionCreateOrConnectWithoutUserInput[]
    createMany?: EventSubmissionCreateManyUserInputEnvelope
    connect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
  }

  export type UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserChallengeProgressCreateWithoutUserInput, UserChallengeProgressUncheckedCreateWithoutUserInput> | UserChallengeProgressCreateWithoutUserInput[] | UserChallengeProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeProgressCreateOrConnectWithoutUserInput | UserChallengeProgressCreateOrConnectWithoutUserInput[]
    createMany?: UserChallengeProgressCreateManyUserInputEnvelope
    connect?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
  }

  export type UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserTaskCompletionCreateWithoutUserInput, UserTaskCompletionUncheckedCreateWithoutUserInput> | UserTaskCompletionCreateWithoutUserInput[] | UserTaskCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTaskCompletionCreateOrConnectWithoutUserInput | UserTaskCompletionCreateOrConnectWithoutUserInput[]
    createMany?: UserTaskCompletionCreateManyUserInputEnvelope
    connect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
  }

  export type UserBadgeUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
  }

  export type UserAchievementUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
  }

  export type LeaderboardUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput> | LeaderboardCreateWithoutUserInput[] | LeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutUserInput | LeaderboardCreateOrConnectWithoutUserInput[]
    createMany?: LeaderboardCreateManyUserInputEnvelope
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type ChallengeUncheckedCreateNestedManyWithoutCreatorInput = {
    create?: XOR<ChallengeCreateWithoutCreatorInput, ChallengeUncheckedCreateWithoutCreatorInput> | ChallengeCreateWithoutCreatorInput[] | ChallengeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutCreatorInput | ChallengeCreateOrConnectWithoutCreatorInput[]
    createMany?: ChallengeCreateManyCreatorInputEnvelope
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type EmailLogUncheckedCreateNestedManyWithoutSenderInput = {
    create?: XOR<EmailLogCreateWithoutSenderInput, EmailLogUncheckedCreateWithoutSenderInput> | EmailLogCreateWithoutSenderInput[] | EmailLogUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutSenderInput | EmailLogCreateOrConnectWithoutSenderInput[]
    createMany?: EmailLogCreateManySenderInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type EventRegistrationUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput> | EventRegistrationCreateWithoutUserInput[] | EventRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutUserInput | EventRegistrationCreateOrConnectWithoutUserInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutUserInput | EventRegistrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventRegistrationCreateManyUserInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutUserInput | EventRegistrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutUserInput | EventRegistrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutLeaderNestedInput = {
    create?: XOR<TeamCreateWithoutLeaderInput, TeamUncheckedCreateWithoutLeaderInput> | TeamCreateWithoutLeaderInput[] | TeamUncheckedCreateWithoutLeaderInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeaderInput | TeamCreateOrConnectWithoutLeaderInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutLeaderInput | TeamUpsertWithWhereUniqueWithoutLeaderInput[]
    createMany?: TeamCreateManyLeaderInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutLeaderInput | TeamUpdateWithWhereUniqueWithoutLeaderInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutLeaderInput | TeamUpdateManyWithWhereWithoutLeaderInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamMemberUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamJoinRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamJoinRequestCreateWithoutUserInput, TeamJoinRequestUncheckedCreateWithoutUserInput> | TeamJoinRequestCreateWithoutUserInput[] | TeamJoinRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamJoinRequestCreateOrConnectWithoutUserInput | TeamJoinRequestCreateOrConnectWithoutUserInput[]
    upsert?: TeamJoinRequestUpsertWithWhereUniqueWithoutUserInput | TeamJoinRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamJoinRequestCreateManyUserInputEnvelope
    set?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    disconnect?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    delete?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    connect?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    update?: TeamJoinRequestUpdateWithWhereUniqueWithoutUserInput | TeamJoinRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamJoinRequestUpdateManyWithWhereWithoutUserInput | TeamJoinRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamJoinRequestScalarWhereInput | TeamJoinRequestScalarWhereInput[]
  }

  export type EventSubmissionUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventSubmissionCreateWithoutUserInput, EventSubmissionUncheckedCreateWithoutUserInput> | EventSubmissionCreateWithoutUserInput[] | EventSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventSubmissionCreateOrConnectWithoutUserInput | EventSubmissionCreateOrConnectWithoutUserInput[]
    upsert?: EventSubmissionUpsertWithWhereUniqueWithoutUserInput | EventSubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventSubmissionCreateManyUserInputEnvelope
    set?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    disconnect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    delete?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    connect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    update?: EventSubmissionUpdateWithWhereUniqueWithoutUserInput | EventSubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventSubmissionUpdateManyWithWhereWithoutUserInput | EventSubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventSubmissionScalarWhereInput | EventSubmissionScalarWhereInput[]
  }

  export type UserChallengeProgressUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserChallengeProgressCreateWithoutUserInput, UserChallengeProgressUncheckedCreateWithoutUserInput> | UserChallengeProgressCreateWithoutUserInput[] | UserChallengeProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeProgressCreateOrConnectWithoutUserInput | UserChallengeProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserChallengeProgressUpsertWithWhereUniqueWithoutUserInput | UserChallengeProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserChallengeProgressCreateManyUserInputEnvelope
    set?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    disconnect?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    delete?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    connect?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    update?: UserChallengeProgressUpdateWithWhereUniqueWithoutUserInput | UserChallengeProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserChallengeProgressUpdateManyWithWhereWithoutUserInput | UserChallengeProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserChallengeProgressScalarWhereInput | UserChallengeProgressScalarWhereInput[]
  }

  export type UserTaskCompletionUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTaskCompletionCreateWithoutUserInput, UserTaskCompletionUncheckedCreateWithoutUserInput> | UserTaskCompletionCreateWithoutUserInput[] | UserTaskCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTaskCompletionCreateOrConnectWithoutUserInput | UserTaskCompletionCreateOrConnectWithoutUserInput[]
    upsert?: UserTaskCompletionUpsertWithWhereUniqueWithoutUserInput | UserTaskCompletionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTaskCompletionCreateManyUserInputEnvelope
    set?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    disconnect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    delete?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    connect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    update?: UserTaskCompletionUpdateWithWhereUniqueWithoutUserInput | UserTaskCompletionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTaskCompletionUpdateManyWithWhereWithoutUserInput | UserTaskCompletionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTaskCompletionScalarWhereInput | UserTaskCompletionScalarWhereInput[]
  }

  export type UserBadgeUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserAchievementUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type LeaderboardUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput> | LeaderboardCreateWithoutUserInput[] | LeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutUserInput | LeaderboardCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardUpsertWithWhereUniqueWithoutUserInput | LeaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardCreateManyUserInputEnvelope
    set?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    disconnect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    delete?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    update?: LeaderboardUpdateWithWhereUniqueWithoutUserInput | LeaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardUpdateManyWithWhereWithoutUserInput | LeaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
  }

  export type EventUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatorInput | EventUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatorInput | EventUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatorInput | EventUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ChallengeUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ChallengeCreateWithoutCreatorInput, ChallengeUncheckedCreateWithoutCreatorInput> | ChallengeCreateWithoutCreatorInput[] | ChallengeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutCreatorInput | ChallengeCreateOrConnectWithoutCreatorInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutCreatorInput | ChallengeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ChallengeCreateManyCreatorInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutCreatorInput | ChallengeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutCreatorInput | ChallengeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutUserInput | CertificateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutUserInput | CertificateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutUserInput | CertificateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type EmailLogUpdateManyWithoutSenderNestedInput = {
    create?: XOR<EmailLogCreateWithoutSenderInput, EmailLogUncheckedCreateWithoutSenderInput> | EmailLogCreateWithoutSenderInput[] | EmailLogUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutSenderInput | EmailLogCreateOrConnectWithoutSenderInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutSenderInput | EmailLogUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: EmailLogCreateManySenderInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutSenderInput | EmailLogUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutSenderInput | EmailLogUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type EventRegistrationUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput> | EventRegistrationCreateWithoutUserInput[] | EventRegistrationUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutUserInput | EventRegistrationCreateOrConnectWithoutUserInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutUserInput | EventRegistrationUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventRegistrationCreateManyUserInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutUserInput | EventRegistrationUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutUserInput | EventRegistrationUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutLeaderNestedInput = {
    create?: XOR<TeamCreateWithoutLeaderInput, TeamUncheckedCreateWithoutLeaderInput> | TeamCreateWithoutLeaderInput[] | TeamUncheckedCreateWithoutLeaderInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutLeaderInput | TeamCreateOrConnectWithoutLeaderInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutLeaderInput | TeamUpsertWithWhereUniqueWithoutLeaderInput[]
    createMany?: TeamCreateManyLeaderInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutLeaderInput | TeamUpdateWithWhereUniqueWithoutLeaderInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutLeaderInput | TeamUpdateManyWithWhereWithoutLeaderInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput> | TeamMemberCreateWithoutUserInput[] | TeamMemberUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutUserInput | TeamMemberCreateOrConnectWithoutUserInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutUserInput | TeamMemberUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamMemberCreateManyUserInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutUserInput | TeamMemberUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutUserInput | TeamMemberUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TeamJoinRequestCreateWithoutUserInput, TeamJoinRequestUncheckedCreateWithoutUserInput> | TeamJoinRequestCreateWithoutUserInput[] | TeamJoinRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TeamJoinRequestCreateOrConnectWithoutUserInput | TeamJoinRequestCreateOrConnectWithoutUserInput[]
    upsert?: TeamJoinRequestUpsertWithWhereUniqueWithoutUserInput | TeamJoinRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TeamJoinRequestCreateManyUserInputEnvelope
    set?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    disconnect?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    delete?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    connect?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    update?: TeamJoinRequestUpdateWithWhereUniqueWithoutUserInput | TeamJoinRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TeamJoinRequestUpdateManyWithWhereWithoutUserInput | TeamJoinRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TeamJoinRequestScalarWhereInput | TeamJoinRequestScalarWhereInput[]
  }

  export type EventSubmissionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<EventSubmissionCreateWithoutUserInput, EventSubmissionUncheckedCreateWithoutUserInput> | EventSubmissionCreateWithoutUserInput[] | EventSubmissionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: EventSubmissionCreateOrConnectWithoutUserInput | EventSubmissionCreateOrConnectWithoutUserInput[]
    upsert?: EventSubmissionUpsertWithWhereUniqueWithoutUserInput | EventSubmissionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: EventSubmissionCreateManyUserInputEnvelope
    set?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    disconnect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    delete?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    connect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    update?: EventSubmissionUpdateWithWhereUniqueWithoutUserInput | EventSubmissionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: EventSubmissionUpdateManyWithWhereWithoutUserInput | EventSubmissionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: EventSubmissionScalarWhereInput | EventSubmissionScalarWhereInput[]
  }

  export type UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserChallengeProgressCreateWithoutUserInput, UserChallengeProgressUncheckedCreateWithoutUserInput> | UserChallengeProgressCreateWithoutUserInput[] | UserChallengeProgressUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserChallengeProgressCreateOrConnectWithoutUserInput | UserChallengeProgressCreateOrConnectWithoutUserInput[]
    upsert?: UserChallengeProgressUpsertWithWhereUniqueWithoutUserInput | UserChallengeProgressUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserChallengeProgressCreateManyUserInputEnvelope
    set?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    disconnect?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    delete?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    connect?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    update?: UserChallengeProgressUpdateWithWhereUniqueWithoutUserInput | UserChallengeProgressUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserChallengeProgressUpdateManyWithWhereWithoutUserInput | UserChallengeProgressUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserChallengeProgressScalarWhereInput | UserChallengeProgressScalarWhereInput[]
  }

  export type UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserTaskCompletionCreateWithoutUserInput, UserTaskCompletionUncheckedCreateWithoutUserInput> | UserTaskCompletionCreateWithoutUserInput[] | UserTaskCompletionUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserTaskCompletionCreateOrConnectWithoutUserInput | UserTaskCompletionCreateOrConnectWithoutUserInput[]
    upsert?: UserTaskCompletionUpsertWithWhereUniqueWithoutUserInput | UserTaskCompletionUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserTaskCompletionCreateManyUserInputEnvelope
    set?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    disconnect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    delete?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    connect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    update?: UserTaskCompletionUpdateWithWhereUniqueWithoutUserInput | UserTaskCompletionUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserTaskCompletionUpdateManyWithWhereWithoutUserInput | UserTaskCompletionUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserTaskCompletionScalarWhereInput | UserTaskCompletionScalarWhereInput[]
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput> | UserBadgeCreateWithoutUserInput[] | UserBadgeUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserBadgeCreateOrConnectWithoutUserInput | UserBadgeCreateOrConnectWithoutUserInput[]
    upsert?: UserBadgeUpsertWithWhereUniqueWithoutUserInput | UserBadgeUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserBadgeCreateManyUserInputEnvelope
    set?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    disconnect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    delete?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    connect?: UserBadgeWhereUniqueInput | UserBadgeWhereUniqueInput[]
    update?: UserBadgeUpdateWithWhereUniqueWithoutUserInput | UserBadgeUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserBadgeUpdateManyWithWhereWithoutUserInput | UserBadgeUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput> | UserAchievementCreateWithoutUserInput[] | UserAchievementUncheckedCreateWithoutUserInput[]
    connectOrCreate?: UserAchievementCreateOrConnectWithoutUserInput | UserAchievementCreateOrConnectWithoutUserInput[]
    upsert?: UserAchievementUpsertWithWhereUniqueWithoutUserInput | UserAchievementUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: UserAchievementCreateManyUserInputEnvelope
    set?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    disconnect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    delete?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    connect?: UserAchievementWhereUniqueInput | UserAchievementWhereUniqueInput[]
    update?: UserAchievementUpdateWithWhereUniqueWithoutUserInput | UserAchievementUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: UserAchievementUpdateManyWithWhereWithoutUserInput | UserAchievementUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
  }

  export type LeaderboardUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput> | LeaderboardCreateWithoutUserInput[] | LeaderboardUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaderboardCreateOrConnectWithoutUserInput | LeaderboardCreateOrConnectWithoutUserInput[]
    upsert?: LeaderboardUpsertWithWhereUniqueWithoutUserInput | LeaderboardUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaderboardCreateManyUserInputEnvelope
    set?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    disconnect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    delete?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    connect?: LeaderboardWhereUniqueInput | LeaderboardWhereUniqueInput[]
    update?: LeaderboardUpdateWithWhereUniqueWithoutUserInput | LeaderboardUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaderboardUpdateManyWithWhereWithoutUserInput | LeaderboardUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput> | EventCreateWithoutCreatorInput[] | EventUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCreatorInput | EventCreateOrConnectWithoutCreatorInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCreatorInput | EventUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: EventCreateManyCreatorInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCreatorInput | EventUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCreatorInput | EventUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type ChallengeUncheckedUpdateManyWithoutCreatorNestedInput = {
    create?: XOR<ChallengeCreateWithoutCreatorInput, ChallengeUncheckedCreateWithoutCreatorInput> | ChallengeCreateWithoutCreatorInput[] | ChallengeUncheckedCreateWithoutCreatorInput[]
    connectOrCreate?: ChallengeCreateOrConnectWithoutCreatorInput | ChallengeCreateOrConnectWithoutCreatorInput[]
    upsert?: ChallengeUpsertWithWhereUniqueWithoutCreatorInput | ChallengeUpsertWithWhereUniqueWithoutCreatorInput[]
    createMany?: ChallengeCreateManyCreatorInputEnvelope
    set?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    disconnect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    delete?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    connect?: ChallengeWhereUniqueInput | ChallengeWhereUniqueInput[]
    update?: ChallengeUpdateWithWhereUniqueWithoutCreatorInput | ChallengeUpdateWithWhereUniqueWithoutCreatorInput[]
    updateMany?: ChallengeUpdateManyWithWhereWithoutCreatorInput | ChallengeUpdateManyWithWhereWithoutCreatorInput[]
    deleteMany?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput> | CertificateCreateWithoutUserInput[] | CertificateUncheckedCreateWithoutUserInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutUserInput | CertificateCreateOrConnectWithoutUserInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutUserInput | CertificateUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: CertificateCreateManyUserInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutUserInput | CertificateUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutUserInput | CertificateUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type EmailLogUncheckedUpdateManyWithoutSenderNestedInput = {
    create?: XOR<EmailLogCreateWithoutSenderInput, EmailLogUncheckedCreateWithoutSenderInput> | EmailLogCreateWithoutSenderInput[] | EmailLogUncheckedCreateWithoutSenderInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutSenderInput | EmailLogCreateOrConnectWithoutSenderInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutSenderInput | EmailLogUpsertWithWhereUniqueWithoutSenderInput[]
    createMany?: EmailLogCreateManySenderInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutSenderInput | EmailLogUpdateWithWhereUniqueWithoutSenderInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutSenderInput | EmailLogUpdateManyWithWhereWithoutSenderInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type EventCategoryCreateNestedOneWithoutChildrenInput = {
    create?: XOR<EventCategoryCreateWithoutChildrenInput, EventCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: EventCategoryCreateOrConnectWithoutChildrenInput
    connect?: EventCategoryWhereUniqueInput
  }

  export type EventCategoryCreateNestedManyWithoutParentInput = {
    create?: XOR<EventCategoryCreateWithoutParentInput, EventCategoryUncheckedCreateWithoutParentInput> | EventCategoryCreateWithoutParentInput[] | EventCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EventCategoryCreateOrConnectWithoutParentInput | EventCategoryCreateOrConnectWithoutParentInput[]
    createMany?: EventCategoryCreateManyParentInputEnvelope
    connect?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput> | EventCreateWithoutCategoryInput[] | EventUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCategoryInput | EventCreateOrConnectWithoutCategoryInput[]
    createMany?: EventCreateManyCategoryInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventTypeCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EventTypeCreateWithoutCategoryInput, EventTypeUncheckedCreateWithoutCategoryInput> | EventTypeCreateWithoutCategoryInput[] | EventTypeUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventTypeCreateOrConnectWithoutCategoryInput | EventTypeCreateOrConnectWithoutCategoryInput[]
    createMany?: EventTypeCreateManyCategoryInputEnvelope
    connect?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
  }

  export type EventCategoryUncheckedCreateNestedManyWithoutParentInput = {
    create?: XOR<EventCategoryCreateWithoutParentInput, EventCategoryUncheckedCreateWithoutParentInput> | EventCategoryCreateWithoutParentInput[] | EventCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EventCategoryCreateOrConnectWithoutParentInput | EventCategoryCreateOrConnectWithoutParentInput[]
    createMany?: EventCategoryCreateManyParentInputEnvelope
    connect?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput> | EventCreateWithoutCategoryInput[] | EventUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCategoryInput | EventCreateOrConnectWithoutCategoryInput[]
    createMany?: EventCreateManyCategoryInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type EventTypeUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<EventTypeCreateWithoutCategoryInput, EventTypeUncheckedCreateWithoutCategoryInput> | EventTypeCreateWithoutCategoryInput[] | EventTypeUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventTypeCreateOrConnectWithoutCategoryInput | EventTypeCreateOrConnectWithoutCategoryInput[]
    createMany?: EventTypeCreateManyCategoryInputEnvelope
    connect?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
  }

  export type EventCategoryUpdateOneWithoutChildrenNestedInput = {
    create?: XOR<EventCategoryCreateWithoutChildrenInput, EventCategoryUncheckedCreateWithoutChildrenInput>
    connectOrCreate?: EventCategoryCreateOrConnectWithoutChildrenInput
    upsert?: EventCategoryUpsertWithoutChildrenInput
    disconnect?: EventCategoryWhereInput | boolean
    delete?: EventCategoryWhereInput | boolean
    connect?: EventCategoryWhereUniqueInput
    update?: XOR<XOR<EventCategoryUpdateToOneWithWhereWithoutChildrenInput, EventCategoryUpdateWithoutChildrenInput>, EventCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type EventCategoryUpdateManyWithoutParentNestedInput = {
    create?: XOR<EventCategoryCreateWithoutParentInput, EventCategoryUncheckedCreateWithoutParentInput> | EventCategoryCreateWithoutParentInput[] | EventCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EventCategoryCreateOrConnectWithoutParentInput | EventCategoryCreateOrConnectWithoutParentInput[]
    upsert?: EventCategoryUpsertWithWhereUniqueWithoutParentInput | EventCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: EventCategoryCreateManyParentInputEnvelope
    set?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    disconnect?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    delete?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    connect?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    update?: EventCategoryUpdateWithWhereUniqueWithoutParentInput | EventCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: EventCategoryUpdateManyWithWhereWithoutParentInput | EventCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: EventCategoryScalarWhereInput | EventCategoryScalarWhereInput[]
  }

  export type EventUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput> | EventCreateWithoutCategoryInput[] | EventUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCategoryInput | EventCreateOrConnectWithoutCategoryInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCategoryInput | EventUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EventCreateManyCategoryInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCategoryInput | EventUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCategoryInput | EventUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventTypeUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EventTypeCreateWithoutCategoryInput, EventTypeUncheckedCreateWithoutCategoryInput> | EventTypeCreateWithoutCategoryInput[] | EventTypeUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventTypeCreateOrConnectWithoutCategoryInput | EventTypeCreateOrConnectWithoutCategoryInput[]
    upsert?: EventTypeUpsertWithWhereUniqueWithoutCategoryInput | EventTypeUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EventTypeCreateManyCategoryInputEnvelope
    set?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    disconnect?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    delete?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    connect?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    update?: EventTypeUpdateWithWhereUniqueWithoutCategoryInput | EventTypeUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EventTypeUpdateManyWithWhereWithoutCategoryInput | EventTypeUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EventTypeScalarWhereInput | EventTypeScalarWhereInput[]
  }

  export type EventCategoryUncheckedUpdateManyWithoutParentNestedInput = {
    create?: XOR<EventCategoryCreateWithoutParentInput, EventCategoryUncheckedCreateWithoutParentInput> | EventCategoryCreateWithoutParentInput[] | EventCategoryUncheckedCreateWithoutParentInput[]
    connectOrCreate?: EventCategoryCreateOrConnectWithoutParentInput | EventCategoryCreateOrConnectWithoutParentInput[]
    upsert?: EventCategoryUpsertWithWhereUniqueWithoutParentInput | EventCategoryUpsertWithWhereUniqueWithoutParentInput[]
    createMany?: EventCategoryCreateManyParentInputEnvelope
    set?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    disconnect?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    delete?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    connect?: EventCategoryWhereUniqueInput | EventCategoryWhereUniqueInput[]
    update?: EventCategoryUpdateWithWhereUniqueWithoutParentInput | EventCategoryUpdateWithWhereUniqueWithoutParentInput[]
    updateMany?: EventCategoryUpdateManyWithWhereWithoutParentInput | EventCategoryUpdateManyWithWhereWithoutParentInput[]
    deleteMany?: EventCategoryScalarWhereInput | EventCategoryScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput> | EventCreateWithoutCategoryInput[] | EventUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventCreateOrConnectWithoutCategoryInput | EventCreateOrConnectWithoutCategoryInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutCategoryInput | EventUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EventCreateManyCategoryInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutCategoryInput | EventUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EventUpdateManyWithWhereWithoutCategoryInput | EventUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type EventTypeUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<EventTypeCreateWithoutCategoryInput, EventTypeUncheckedCreateWithoutCategoryInput> | EventTypeCreateWithoutCategoryInput[] | EventTypeUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: EventTypeCreateOrConnectWithoutCategoryInput | EventTypeCreateOrConnectWithoutCategoryInput[]
    upsert?: EventTypeUpsertWithWhereUniqueWithoutCategoryInput | EventTypeUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: EventTypeCreateManyCategoryInputEnvelope
    set?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    disconnect?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    delete?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    connect?: EventTypeWhereUniqueInput | EventTypeWhereUniqueInput[]
    update?: EventTypeUpdateWithWhereUniqueWithoutCategoryInput | EventTypeUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: EventTypeUpdateManyWithWhereWithoutCategoryInput | EventTypeUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: EventTypeScalarWhereInput | EventTypeScalarWhereInput[]
  }

  export type EventCategoryCreateNestedOneWithoutEventTypesInput = {
    create?: XOR<EventCategoryCreateWithoutEventTypesInput, EventCategoryUncheckedCreateWithoutEventTypesInput>
    connectOrCreate?: EventCategoryCreateOrConnectWithoutEventTypesInput
    connect?: EventCategoryWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EventCategoryUpdateOneRequiredWithoutEventTypesNestedInput = {
    create?: XOR<EventCategoryCreateWithoutEventTypesInput, EventCategoryUncheckedCreateWithoutEventTypesInput>
    connectOrCreate?: EventCategoryCreateOrConnectWithoutEventTypesInput
    upsert?: EventCategoryUpsertWithoutEventTypesInput
    connect?: EventCategoryWhereUniqueInput
    update?: XOR<XOR<EventCategoryUpdateToOneWithWhereWithoutEventTypesInput, EventCategoryUpdateWithoutEventTypesInput>, EventCategoryUncheckedUpdateWithoutEventTypesInput>
  }

  export type EventCategoryCreateNestedOneWithoutEventsInput = {
    create?: XOR<EventCategoryCreateWithoutEventsInput, EventCategoryUncheckedCreateWithoutEventsInput>
    connectOrCreate?: EventCategoryCreateOrConnectWithoutEventsInput
    connect?: EventCategoryWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventsCreatedInput = {
    create?: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type RoadmapCreateNestedOneWithoutEventsInput = {
    create?: XOR<RoadmapCreateWithoutEventsInput, RoadmapUncheckedCreateWithoutEventsInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutEventsInput
    connect?: RoadmapWhereUniqueInput
  }

  export type EventRegistrationCreateNestedManyWithoutEventInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type TeamCreateNestedManyWithoutEventInput = {
    create?: XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput> | TeamCreateWithoutEventInput[] | TeamUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutEventInput | TeamCreateOrConnectWithoutEventInput[]
    createMany?: TeamCreateManyEventInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type EventSubmissionCreateNestedManyWithoutEventInput = {
    create?: XOR<EventSubmissionCreateWithoutEventInput, EventSubmissionUncheckedCreateWithoutEventInput> | EventSubmissionCreateWithoutEventInput[] | EventSubmissionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventSubmissionCreateOrConnectWithoutEventInput | EventSubmissionCreateOrConnectWithoutEventInput[]
    createMany?: EventSubmissionCreateManyEventInputEnvelope
    connect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
  }

  export type EventChallengeCreateNestedManyWithoutEventInput = {
    create?: XOR<EventChallengeCreateWithoutEventInput, EventChallengeUncheckedCreateWithoutEventInput> | EventChallengeCreateWithoutEventInput[] | EventChallengeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventChallengeCreateOrConnectWithoutEventInput | EventChallengeCreateOrConnectWithoutEventInput[]
    createMany?: EventChallengeCreateManyEventInputEnvelope
    connect?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
  }

  export type EmailLogCreateNestedManyWithoutEventInput = {
    create?: XOR<EmailLogCreateWithoutEventInput, EmailLogUncheckedCreateWithoutEventInput> | EmailLogCreateWithoutEventInput[] | EmailLogUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutEventInput | EmailLogCreateOrConnectWithoutEventInput[]
    createMany?: EmailLogCreateManyEventInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutEventInput = {
    create?: XOR<CertificateCreateWithoutEventInput, CertificateUncheckedCreateWithoutEventInput> | CertificateCreateWithoutEventInput[] | CertificateUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutEventInput | CertificateCreateOrConnectWithoutEventInput[]
    createMany?: CertificateCreateManyEventInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type EventRegistrationUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type TeamUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput> | TeamCreateWithoutEventInput[] | TeamUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutEventInput | TeamCreateOrConnectWithoutEventInput[]
    createMany?: TeamCreateManyEventInputEnvelope
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
  }

  export type EventSubmissionUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventSubmissionCreateWithoutEventInput, EventSubmissionUncheckedCreateWithoutEventInput> | EventSubmissionCreateWithoutEventInput[] | EventSubmissionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventSubmissionCreateOrConnectWithoutEventInput | EventSubmissionCreateOrConnectWithoutEventInput[]
    createMany?: EventSubmissionCreateManyEventInputEnvelope
    connect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
  }

  export type EventChallengeUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EventChallengeCreateWithoutEventInput, EventChallengeUncheckedCreateWithoutEventInput> | EventChallengeCreateWithoutEventInput[] | EventChallengeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventChallengeCreateOrConnectWithoutEventInput | EventChallengeCreateOrConnectWithoutEventInput[]
    createMany?: EventChallengeCreateManyEventInputEnvelope
    connect?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
  }

  export type EmailLogUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<EmailLogCreateWithoutEventInput, EmailLogUncheckedCreateWithoutEventInput> | EmailLogCreateWithoutEventInput[] | EmailLogUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutEventInput | EmailLogCreateOrConnectWithoutEventInput[]
    createMany?: EmailLogCreateManyEventInputEnvelope
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutEventInput = {
    create?: XOR<CertificateCreateWithoutEventInput, CertificateUncheckedCreateWithoutEventInput> | CertificateCreateWithoutEventInput[] | CertificateUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutEventInput | CertificateCreateOrConnectWithoutEventInput[]
    createMany?: CertificateCreateManyEventInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type NullableDecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string | null
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type EventCategoryUpdateOneRequiredWithoutEventsNestedInput = {
    create?: XOR<EventCategoryCreateWithoutEventsInput, EventCategoryUncheckedCreateWithoutEventsInput>
    connectOrCreate?: EventCategoryCreateOrConnectWithoutEventsInput
    upsert?: EventCategoryUpsertWithoutEventsInput
    connect?: EventCategoryWhereUniqueInput
    update?: XOR<XOR<EventCategoryUpdateToOneWithWhereWithoutEventsInput, EventCategoryUpdateWithoutEventsInput>, EventCategoryUncheckedUpdateWithoutEventsInput>
  }

  export type UserUpdateOneWithoutEventsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventsCreatedInput
    upsert?: UserUpsertWithoutEventsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventsCreatedInput, UserUpdateWithoutEventsCreatedInput>, UserUncheckedUpdateWithoutEventsCreatedInput>
  }

  export type RoadmapUpdateOneWithoutEventsNestedInput = {
    create?: XOR<RoadmapCreateWithoutEventsInput, RoadmapUncheckedCreateWithoutEventsInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutEventsInput
    upsert?: RoadmapUpsertWithoutEventsInput
    disconnect?: RoadmapWhereInput | boolean
    delete?: RoadmapWhereInput | boolean
    connect?: RoadmapWhereUniqueInput
    update?: XOR<XOR<RoadmapUpdateToOneWithWhereWithoutEventsInput, RoadmapUpdateWithoutEventsInput>, RoadmapUncheckedUpdateWithoutEventsInput>
  }

  export type EventRegistrationUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutEventInput | EventRegistrationUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutEventInput | EventRegistrationUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutEventInput | EventRegistrationUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type TeamUpdateManyWithoutEventNestedInput = {
    create?: XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput> | TeamCreateWithoutEventInput[] | TeamUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutEventInput | TeamCreateOrConnectWithoutEventInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutEventInput | TeamUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: TeamCreateManyEventInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutEventInput | TeamUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutEventInput | TeamUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type EventSubmissionUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventSubmissionCreateWithoutEventInput, EventSubmissionUncheckedCreateWithoutEventInput> | EventSubmissionCreateWithoutEventInput[] | EventSubmissionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventSubmissionCreateOrConnectWithoutEventInput | EventSubmissionCreateOrConnectWithoutEventInput[]
    upsert?: EventSubmissionUpsertWithWhereUniqueWithoutEventInput | EventSubmissionUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventSubmissionCreateManyEventInputEnvelope
    set?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    disconnect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    delete?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    connect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    update?: EventSubmissionUpdateWithWhereUniqueWithoutEventInput | EventSubmissionUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventSubmissionUpdateManyWithWhereWithoutEventInput | EventSubmissionUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventSubmissionScalarWhereInput | EventSubmissionScalarWhereInput[]
  }

  export type EventChallengeUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventChallengeCreateWithoutEventInput, EventChallengeUncheckedCreateWithoutEventInput> | EventChallengeCreateWithoutEventInput[] | EventChallengeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventChallengeCreateOrConnectWithoutEventInput | EventChallengeCreateOrConnectWithoutEventInput[]
    upsert?: EventChallengeUpsertWithWhereUniqueWithoutEventInput | EventChallengeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventChallengeCreateManyEventInputEnvelope
    set?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    disconnect?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    delete?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    connect?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    update?: EventChallengeUpdateWithWhereUniqueWithoutEventInput | EventChallengeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventChallengeUpdateManyWithWhereWithoutEventInput | EventChallengeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventChallengeScalarWhereInput | EventChallengeScalarWhereInput[]
  }

  export type EmailLogUpdateManyWithoutEventNestedInput = {
    create?: XOR<EmailLogCreateWithoutEventInput, EmailLogUncheckedCreateWithoutEventInput> | EmailLogCreateWithoutEventInput[] | EmailLogUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutEventInput | EmailLogCreateOrConnectWithoutEventInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutEventInput | EmailLogUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EmailLogCreateManyEventInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutEventInput | EmailLogUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutEventInput | EmailLogUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutEventNestedInput = {
    create?: XOR<CertificateCreateWithoutEventInput, CertificateUncheckedCreateWithoutEventInput> | CertificateCreateWithoutEventInput[] | CertificateUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutEventInput | CertificateCreateOrConnectWithoutEventInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutEventInput | CertificateUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: CertificateCreateManyEventInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutEventInput | CertificateUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutEventInput | CertificateUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type EventRegistrationUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput> | EventRegistrationCreateWithoutEventInput[] | EventRegistrationUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutEventInput | EventRegistrationCreateOrConnectWithoutEventInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutEventInput | EventRegistrationUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventRegistrationCreateManyEventInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutEventInput | EventRegistrationUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutEventInput | EventRegistrationUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type TeamUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput> | TeamCreateWithoutEventInput[] | TeamUncheckedCreateWithoutEventInput[]
    connectOrCreate?: TeamCreateOrConnectWithoutEventInput | TeamCreateOrConnectWithoutEventInput[]
    upsert?: TeamUpsertWithWhereUniqueWithoutEventInput | TeamUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: TeamCreateManyEventInputEnvelope
    set?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    disconnect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    delete?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    connect?: TeamWhereUniqueInput | TeamWhereUniqueInput[]
    update?: TeamUpdateWithWhereUniqueWithoutEventInput | TeamUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: TeamUpdateManyWithWhereWithoutEventInput | TeamUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: TeamScalarWhereInput | TeamScalarWhereInput[]
  }

  export type EventSubmissionUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventSubmissionCreateWithoutEventInput, EventSubmissionUncheckedCreateWithoutEventInput> | EventSubmissionCreateWithoutEventInput[] | EventSubmissionUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventSubmissionCreateOrConnectWithoutEventInput | EventSubmissionCreateOrConnectWithoutEventInput[]
    upsert?: EventSubmissionUpsertWithWhereUniqueWithoutEventInput | EventSubmissionUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventSubmissionCreateManyEventInputEnvelope
    set?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    disconnect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    delete?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    connect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    update?: EventSubmissionUpdateWithWhereUniqueWithoutEventInput | EventSubmissionUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventSubmissionUpdateManyWithWhereWithoutEventInput | EventSubmissionUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventSubmissionScalarWhereInput | EventSubmissionScalarWhereInput[]
  }

  export type EventChallengeUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EventChallengeCreateWithoutEventInput, EventChallengeUncheckedCreateWithoutEventInput> | EventChallengeCreateWithoutEventInput[] | EventChallengeUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EventChallengeCreateOrConnectWithoutEventInput | EventChallengeCreateOrConnectWithoutEventInput[]
    upsert?: EventChallengeUpsertWithWhereUniqueWithoutEventInput | EventChallengeUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EventChallengeCreateManyEventInputEnvelope
    set?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    disconnect?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    delete?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    connect?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    update?: EventChallengeUpdateWithWhereUniqueWithoutEventInput | EventChallengeUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EventChallengeUpdateManyWithWhereWithoutEventInput | EventChallengeUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EventChallengeScalarWhereInput | EventChallengeScalarWhereInput[]
  }

  export type EmailLogUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<EmailLogCreateWithoutEventInput, EmailLogUncheckedCreateWithoutEventInput> | EmailLogCreateWithoutEventInput[] | EmailLogUncheckedCreateWithoutEventInput[]
    connectOrCreate?: EmailLogCreateOrConnectWithoutEventInput | EmailLogCreateOrConnectWithoutEventInput[]
    upsert?: EmailLogUpsertWithWhereUniqueWithoutEventInput | EmailLogUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: EmailLogCreateManyEventInputEnvelope
    set?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    disconnect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    delete?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    connect?: EmailLogWhereUniqueInput | EmailLogWhereUniqueInput[]
    update?: EmailLogUpdateWithWhereUniqueWithoutEventInput | EmailLogUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: EmailLogUpdateManyWithWhereWithoutEventInput | EmailLogUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutEventNestedInput = {
    create?: XOR<CertificateCreateWithoutEventInput, CertificateUncheckedCreateWithoutEventInput> | CertificateCreateWithoutEventInput[] | CertificateUncheckedCreateWithoutEventInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutEventInput | CertificateCreateOrConnectWithoutEventInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutEventInput | CertificateUpsertWithWhereUniqueWithoutEventInput[]
    createMany?: CertificateCreateManyEventInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutEventInput | CertificateUpdateWithWhereUniqueWithoutEventInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutEventInput | CertificateUpdateManyWithWhereWithoutEventInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type EventCreateNestedOneWithoutTeamsInput = {
    create?: XOR<EventCreateWithoutTeamsInput, EventUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: EventCreateOrConnectWithoutTeamsInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamsLeadingInput = {
    create?: XOR<UserCreateWithoutTeamsLeadingInput, UserUncheckedCreateWithoutTeamsLeadingInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsLeadingInput
    connect?: UserWhereUniqueInput
  }

  export type TeamMemberCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamJoinRequestCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamJoinRequestCreateWithoutTeamInput, TeamJoinRequestUncheckedCreateWithoutTeamInput> | TeamJoinRequestCreateWithoutTeamInput[] | TeamJoinRequestUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamJoinRequestCreateOrConnectWithoutTeamInput | TeamJoinRequestCreateOrConnectWithoutTeamInput[]
    createMany?: TeamJoinRequestCreateManyTeamInputEnvelope
    connect?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
  }

  export type EventRegistrationCreateNestedManyWithoutTeamInput = {
    create?: XOR<EventRegistrationCreateWithoutTeamInput, EventRegistrationUncheckedCreateWithoutTeamInput> | EventRegistrationCreateWithoutTeamInput[] | EventRegistrationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutTeamInput | EventRegistrationCreateOrConnectWithoutTeamInput[]
    createMany?: EventRegistrationCreateManyTeamInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type EventSubmissionCreateNestedManyWithoutTeamInput = {
    create?: XOR<EventSubmissionCreateWithoutTeamInput, EventSubmissionUncheckedCreateWithoutTeamInput> | EventSubmissionCreateWithoutTeamInput[] | EventSubmissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EventSubmissionCreateOrConnectWithoutTeamInput | EventSubmissionCreateOrConnectWithoutTeamInput[]
    createMany?: EventSubmissionCreateManyTeamInputEnvelope
    connect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
  }

  export type CertificateCreateNestedManyWithoutTeamInput = {
    create?: XOR<CertificateCreateWithoutTeamInput, CertificateUncheckedCreateWithoutTeamInput> | CertificateCreateWithoutTeamInput[] | CertificateUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutTeamInput | CertificateCreateOrConnectWithoutTeamInput[]
    createMany?: CertificateCreateManyTeamInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type TeamMemberUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
  }

  export type TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<TeamJoinRequestCreateWithoutTeamInput, TeamJoinRequestUncheckedCreateWithoutTeamInput> | TeamJoinRequestCreateWithoutTeamInput[] | TeamJoinRequestUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamJoinRequestCreateOrConnectWithoutTeamInput | TeamJoinRequestCreateOrConnectWithoutTeamInput[]
    createMany?: TeamJoinRequestCreateManyTeamInputEnvelope
    connect?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
  }

  export type EventRegistrationUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<EventRegistrationCreateWithoutTeamInput, EventRegistrationUncheckedCreateWithoutTeamInput> | EventRegistrationCreateWithoutTeamInput[] | EventRegistrationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutTeamInput | EventRegistrationCreateOrConnectWithoutTeamInput[]
    createMany?: EventRegistrationCreateManyTeamInputEnvelope
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
  }

  export type EventSubmissionUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<EventSubmissionCreateWithoutTeamInput, EventSubmissionUncheckedCreateWithoutTeamInput> | EventSubmissionCreateWithoutTeamInput[] | EventSubmissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EventSubmissionCreateOrConnectWithoutTeamInput | EventSubmissionCreateOrConnectWithoutTeamInput[]
    createMany?: EventSubmissionCreateManyTeamInputEnvelope
    connect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
  }

  export type CertificateUncheckedCreateNestedManyWithoutTeamInput = {
    create?: XOR<CertificateCreateWithoutTeamInput, CertificateUncheckedCreateWithoutTeamInput> | CertificateCreateWithoutTeamInput[] | CertificateUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutTeamInput | CertificateCreateOrConnectWithoutTeamInput[]
    createMany?: CertificateCreateManyTeamInputEnvelope
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
  }

  export type EventUpdateOneRequiredWithoutTeamsNestedInput = {
    create?: XOR<EventCreateWithoutTeamsInput, EventUncheckedCreateWithoutTeamsInput>
    connectOrCreate?: EventCreateOrConnectWithoutTeamsInput
    upsert?: EventUpsertWithoutTeamsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutTeamsInput, EventUpdateWithoutTeamsInput>, EventUncheckedUpdateWithoutTeamsInput>
  }

  export type UserUpdateOneRequiredWithoutTeamsLeadingNestedInput = {
    create?: XOR<UserCreateWithoutTeamsLeadingInput, UserUncheckedCreateWithoutTeamsLeadingInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamsLeadingInput
    upsert?: UserUpsertWithoutTeamsLeadingInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamsLeadingInput, UserUpdateWithoutTeamsLeadingInput>, UserUncheckedUpdateWithoutTeamsLeadingInput>
  }

  export type TeamMemberUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamJoinRequestUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamJoinRequestCreateWithoutTeamInput, TeamJoinRequestUncheckedCreateWithoutTeamInput> | TeamJoinRequestCreateWithoutTeamInput[] | TeamJoinRequestUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamJoinRequestCreateOrConnectWithoutTeamInput | TeamJoinRequestCreateOrConnectWithoutTeamInput[]
    upsert?: TeamJoinRequestUpsertWithWhereUniqueWithoutTeamInput | TeamJoinRequestUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamJoinRequestCreateManyTeamInputEnvelope
    set?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    disconnect?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    delete?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    connect?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    update?: TeamJoinRequestUpdateWithWhereUniqueWithoutTeamInput | TeamJoinRequestUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamJoinRequestUpdateManyWithWhereWithoutTeamInput | TeamJoinRequestUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamJoinRequestScalarWhereInput | TeamJoinRequestScalarWhereInput[]
  }

  export type EventRegistrationUpdateManyWithoutTeamNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutTeamInput, EventRegistrationUncheckedCreateWithoutTeamInput> | EventRegistrationCreateWithoutTeamInput[] | EventRegistrationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutTeamInput | EventRegistrationCreateOrConnectWithoutTeamInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutTeamInput | EventRegistrationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: EventRegistrationCreateManyTeamInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutTeamInput | EventRegistrationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutTeamInput | EventRegistrationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type EventSubmissionUpdateManyWithoutTeamNestedInput = {
    create?: XOR<EventSubmissionCreateWithoutTeamInput, EventSubmissionUncheckedCreateWithoutTeamInput> | EventSubmissionCreateWithoutTeamInput[] | EventSubmissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EventSubmissionCreateOrConnectWithoutTeamInput | EventSubmissionCreateOrConnectWithoutTeamInput[]
    upsert?: EventSubmissionUpsertWithWhereUniqueWithoutTeamInput | EventSubmissionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: EventSubmissionCreateManyTeamInputEnvelope
    set?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    disconnect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    delete?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    connect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    update?: EventSubmissionUpdateWithWhereUniqueWithoutTeamInput | EventSubmissionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: EventSubmissionUpdateManyWithWhereWithoutTeamInput | EventSubmissionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: EventSubmissionScalarWhereInput | EventSubmissionScalarWhereInput[]
  }

  export type CertificateUpdateManyWithoutTeamNestedInput = {
    create?: XOR<CertificateCreateWithoutTeamInput, CertificateUncheckedCreateWithoutTeamInput> | CertificateCreateWithoutTeamInput[] | CertificateUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutTeamInput | CertificateCreateOrConnectWithoutTeamInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutTeamInput | CertificateUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: CertificateCreateManyTeamInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutTeamInput | CertificateUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutTeamInput | CertificateUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput> | TeamMemberCreateWithoutTeamInput[] | TeamMemberUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamMemberCreateOrConnectWithoutTeamInput | TeamMemberCreateOrConnectWithoutTeamInput[]
    upsert?: TeamMemberUpsertWithWhereUniqueWithoutTeamInput | TeamMemberUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamMemberCreateManyTeamInputEnvelope
    set?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    disconnect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    delete?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    connect?: TeamMemberWhereUniqueInput | TeamMemberWhereUniqueInput[]
    update?: TeamMemberUpdateWithWhereUniqueWithoutTeamInput | TeamMemberUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamMemberUpdateManyWithWhereWithoutTeamInput | TeamMemberUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
  }

  export type TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<TeamJoinRequestCreateWithoutTeamInput, TeamJoinRequestUncheckedCreateWithoutTeamInput> | TeamJoinRequestCreateWithoutTeamInput[] | TeamJoinRequestUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: TeamJoinRequestCreateOrConnectWithoutTeamInput | TeamJoinRequestCreateOrConnectWithoutTeamInput[]
    upsert?: TeamJoinRequestUpsertWithWhereUniqueWithoutTeamInput | TeamJoinRequestUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: TeamJoinRequestCreateManyTeamInputEnvelope
    set?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    disconnect?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    delete?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    connect?: TeamJoinRequestWhereUniqueInput | TeamJoinRequestWhereUniqueInput[]
    update?: TeamJoinRequestUpdateWithWhereUniqueWithoutTeamInput | TeamJoinRequestUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: TeamJoinRequestUpdateManyWithWhereWithoutTeamInput | TeamJoinRequestUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: TeamJoinRequestScalarWhereInput | TeamJoinRequestScalarWhereInput[]
  }

  export type EventRegistrationUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<EventRegistrationCreateWithoutTeamInput, EventRegistrationUncheckedCreateWithoutTeamInput> | EventRegistrationCreateWithoutTeamInput[] | EventRegistrationUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EventRegistrationCreateOrConnectWithoutTeamInput | EventRegistrationCreateOrConnectWithoutTeamInput[]
    upsert?: EventRegistrationUpsertWithWhereUniqueWithoutTeamInput | EventRegistrationUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: EventRegistrationCreateManyTeamInputEnvelope
    set?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    disconnect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    delete?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    connect?: EventRegistrationWhereUniqueInput | EventRegistrationWhereUniqueInput[]
    update?: EventRegistrationUpdateWithWhereUniqueWithoutTeamInput | EventRegistrationUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: EventRegistrationUpdateManyWithWhereWithoutTeamInput | EventRegistrationUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
  }

  export type EventSubmissionUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<EventSubmissionCreateWithoutTeamInput, EventSubmissionUncheckedCreateWithoutTeamInput> | EventSubmissionCreateWithoutTeamInput[] | EventSubmissionUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: EventSubmissionCreateOrConnectWithoutTeamInput | EventSubmissionCreateOrConnectWithoutTeamInput[]
    upsert?: EventSubmissionUpsertWithWhereUniqueWithoutTeamInput | EventSubmissionUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: EventSubmissionCreateManyTeamInputEnvelope
    set?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    disconnect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    delete?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    connect?: EventSubmissionWhereUniqueInput | EventSubmissionWhereUniqueInput[]
    update?: EventSubmissionUpdateWithWhereUniqueWithoutTeamInput | EventSubmissionUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: EventSubmissionUpdateManyWithWhereWithoutTeamInput | EventSubmissionUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: EventSubmissionScalarWhereInput | EventSubmissionScalarWhereInput[]
  }

  export type CertificateUncheckedUpdateManyWithoutTeamNestedInput = {
    create?: XOR<CertificateCreateWithoutTeamInput, CertificateUncheckedCreateWithoutTeamInput> | CertificateCreateWithoutTeamInput[] | CertificateUncheckedCreateWithoutTeamInput[]
    connectOrCreate?: CertificateCreateOrConnectWithoutTeamInput | CertificateCreateOrConnectWithoutTeamInput[]
    upsert?: CertificateUpsertWithWhereUniqueWithoutTeamInput | CertificateUpsertWithWhereUniqueWithoutTeamInput[]
    createMany?: CertificateCreateManyTeamInputEnvelope
    set?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    disconnect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    delete?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    connect?: CertificateWhereUniqueInput | CertificateWhereUniqueInput[]
    update?: CertificateUpdateWithWhereUniqueWithoutTeamInput | CertificateUpdateWithWhereUniqueWithoutTeamInput[]
    updateMany?: CertificateUpdateManyWithWhereWithoutTeamInput | CertificateUpdateManyWithWhereWithoutTeamInput[]
    deleteMany?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
  }

  export type TeamCreateNestedOneWithoutMembersInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamMembershipsInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutMembersNestedInput = {
    create?: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    connectOrCreate?: TeamCreateOrConnectWithoutMembersInput
    upsert?: TeamUpsertWithoutMembersInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutMembersInput, TeamUpdateWithoutMembersInput>, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type UserUpdateOneRequiredWithoutTeamMembershipsNestedInput = {
    create?: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamMembershipsInput
    upsert?: UserUpsertWithoutTeamMembershipsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamMembershipsInput, UserUpdateWithoutTeamMembershipsInput>, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type TeamCreateNestedOneWithoutJoinRequestsInput = {
    create?: XOR<TeamCreateWithoutJoinRequestsInput, TeamUncheckedCreateWithoutJoinRequestsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutJoinRequestsInput
    connect?: TeamWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutTeamJoinRequestsInput = {
    create?: XOR<UserCreateWithoutTeamJoinRequestsInput, UserUncheckedCreateWithoutTeamJoinRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamJoinRequestsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamUpdateOneRequiredWithoutJoinRequestsNestedInput = {
    create?: XOR<TeamCreateWithoutJoinRequestsInput, TeamUncheckedCreateWithoutJoinRequestsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutJoinRequestsInput
    upsert?: TeamUpsertWithoutJoinRequestsInput
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutJoinRequestsInput, TeamUpdateWithoutJoinRequestsInput>, TeamUncheckedUpdateWithoutJoinRequestsInput>
  }

  export type UserUpdateOneRequiredWithoutTeamJoinRequestsNestedInput = {
    create?: XOR<UserCreateWithoutTeamJoinRequestsInput, UserUncheckedCreateWithoutTeamJoinRequestsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTeamJoinRequestsInput
    upsert?: UserUpsertWithoutTeamJoinRequestsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTeamJoinRequestsInput, UserUpdateWithoutTeamJoinRequestsInput>, UserUncheckedUpdateWithoutTeamJoinRequestsInput>
  }

  export type EventCreateNestedOneWithoutRegistrationsInput = {
    create?: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: EventCreateOrConnectWithoutRegistrationsInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEventRegistrationsInput = {
    create?: XOR<UserCreateWithoutEventRegistrationsInput, UserUncheckedCreateWithoutEventRegistrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventRegistrationsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutRegistrationsInput = {
    create?: XOR<TeamCreateWithoutRegistrationsInput, TeamUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRegistrationsInput
    connect?: TeamWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutRegistrationsNestedInput = {
    create?: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: EventCreateOrConnectWithoutRegistrationsInput
    upsert?: EventUpsertWithoutRegistrationsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutRegistrationsInput, EventUpdateWithoutRegistrationsInput>, EventUncheckedUpdateWithoutRegistrationsInput>
  }

  export type UserUpdateOneRequiredWithoutEventRegistrationsNestedInput = {
    create?: XOR<UserCreateWithoutEventRegistrationsInput, UserUncheckedCreateWithoutEventRegistrationsInput>
    connectOrCreate?: UserCreateOrConnectWithoutEventRegistrationsInput
    upsert?: UserUpsertWithoutEventRegistrationsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEventRegistrationsInput, UserUpdateWithoutEventRegistrationsInput>, UserUncheckedUpdateWithoutEventRegistrationsInput>
  }

  export type TeamUpdateOneWithoutRegistrationsNestedInput = {
    create?: XOR<TeamCreateWithoutRegistrationsInput, TeamUncheckedCreateWithoutRegistrationsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutRegistrationsInput
    upsert?: TeamUpsertWithoutRegistrationsInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutRegistrationsInput, TeamUpdateWithoutRegistrationsInput>, TeamUncheckedUpdateWithoutRegistrationsInput>
  }

  export type EventCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<EventCreateWithoutSubmissionsInput, EventUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: EventCreateOrConnectWithoutSubmissionsInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutSubmissionsInput = {
    create?: XOR<TeamCreateWithoutSubmissionsInput, TeamUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSubmissionsInput
    connect?: TeamWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<EventCreateWithoutSubmissionsInput, EventUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: EventCreateOrConnectWithoutSubmissionsInput
    upsert?: EventUpsertWithoutSubmissionsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutSubmissionsInput, EventUpdateWithoutSubmissionsInput>, EventUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserUpdateOneRequiredWithoutSubmissionsNestedInput = {
    create?: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutSubmissionsInput
    upsert?: UserUpsertWithoutSubmissionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutSubmissionsInput, UserUpdateWithoutSubmissionsInput>, UserUncheckedUpdateWithoutSubmissionsInput>
  }

  export type TeamUpdateOneWithoutSubmissionsNestedInput = {
    create?: XOR<TeamCreateWithoutSubmissionsInput, TeamUncheckedCreateWithoutSubmissionsInput>
    connectOrCreate?: TeamCreateOrConnectWithoutSubmissionsInput
    upsert?: TeamUpsertWithoutSubmissionsInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutSubmissionsInput, TeamUpdateWithoutSubmissionsInput>, TeamUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserCreateNestedOneWithoutChallengesCreatedInput = {
    create?: XOR<UserCreateWithoutChallengesCreatedInput, UserUncheckedCreateWithoutChallengesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengesCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeTaskCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeTaskCreateWithoutChallengeInput, ChallengeTaskUncheckedCreateWithoutChallengeInput> | ChallengeTaskCreateWithoutChallengeInput[] | ChallengeTaskUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeTaskCreateOrConnectWithoutChallengeInput | ChallengeTaskCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeTaskCreateManyChallengeInputEnvelope
    connect?: ChallengeTaskWhereUniqueInput | ChallengeTaskWhereUniqueInput[]
  }

  export type UserChallengeProgressCreateNestedManyWithoutChallengeInput = {
    create?: XOR<UserChallengeProgressCreateWithoutChallengeInput, UserChallengeProgressUncheckedCreateWithoutChallengeInput> | UserChallengeProgressCreateWithoutChallengeInput[] | UserChallengeProgressUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeProgressCreateOrConnectWithoutChallengeInput | UserChallengeProgressCreateOrConnectWithoutChallengeInput[]
    createMany?: UserChallengeProgressCreateManyChallengeInputEnvelope
    connect?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
  }

  export type EventChallengeCreateNestedManyWithoutChallengeInput = {
    create?: XOR<EventChallengeCreateWithoutChallengeInput, EventChallengeUncheckedCreateWithoutChallengeInput> | EventChallengeCreateWithoutChallengeInput[] | EventChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: EventChallengeCreateOrConnectWithoutChallengeInput | EventChallengeCreateOrConnectWithoutChallengeInput[]
    createMany?: EventChallengeCreateManyChallengeInputEnvelope
    connect?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
  }

  export type ChallengeTaskUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<ChallengeTaskCreateWithoutChallengeInput, ChallengeTaskUncheckedCreateWithoutChallengeInput> | ChallengeTaskCreateWithoutChallengeInput[] | ChallengeTaskUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeTaskCreateOrConnectWithoutChallengeInput | ChallengeTaskCreateOrConnectWithoutChallengeInput[]
    createMany?: ChallengeTaskCreateManyChallengeInputEnvelope
    connect?: ChallengeTaskWhereUniqueInput | ChallengeTaskWhereUniqueInput[]
  }

  export type UserChallengeProgressUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<UserChallengeProgressCreateWithoutChallengeInput, UserChallengeProgressUncheckedCreateWithoutChallengeInput> | UserChallengeProgressCreateWithoutChallengeInput[] | UserChallengeProgressUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeProgressCreateOrConnectWithoutChallengeInput | UserChallengeProgressCreateOrConnectWithoutChallengeInput[]
    createMany?: UserChallengeProgressCreateManyChallengeInputEnvelope
    connect?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
  }

  export type EventChallengeUncheckedCreateNestedManyWithoutChallengeInput = {
    create?: XOR<EventChallengeCreateWithoutChallengeInput, EventChallengeUncheckedCreateWithoutChallengeInput> | EventChallengeCreateWithoutChallengeInput[] | EventChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: EventChallengeCreateOrConnectWithoutChallengeInput | EventChallengeCreateOrConnectWithoutChallengeInput[]
    createMany?: EventChallengeCreateManyChallengeInputEnvelope
    connect?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
  }

  export type UserUpdateOneWithoutChallengesCreatedNestedInput = {
    create?: XOR<UserCreateWithoutChallengesCreatedInput, UserUncheckedCreateWithoutChallengesCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengesCreatedInput
    upsert?: UserUpsertWithoutChallengesCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChallengesCreatedInput, UserUpdateWithoutChallengesCreatedInput>, UserUncheckedUpdateWithoutChallengesCreatedInput>
  }

  export type ChallengeTaskUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeTaskCreateWithoutChallengeInput, ChallengeTaskUncheckedCreateWithoutChallengeInput> | ChallengeTaskCreateWithoutChallengeInput[] | ChallengeTaskUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeTaskCreateOrConnectWithoutChallengeInput | ChallengeTaskCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeTaskUpsertWithWhereUniqueWithoutChallengeInput | ChallengeTaskUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeTaskCreateManyChallengeInputEnvelope
    set?: ChallengeTaskWhereUniqueInput | ChallengeTaskWhereUniqueInput[]
    disconnect?: ChallengeTaskWhereUniqueInput | ChallengeTaskWhereUniqueInput[]
    delete?: ChallengeTaskWhereUniqueInput | ChallengeTaskWhereUniqueInput[]
    connect?: ChallengeTaskWhereUniqueInput | ChallengeTaskWhereUniqueInput[]
    update?: ChallengeTaskUpdateWithWhereUniqueWithoutChallengeInput | ChallengeTaskUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeTaskUpdateManyWithWhereWithoutChallengeInput | ChallengeTaskUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeTaskScalarWhereInput | ChallengeTaskScalarWhereInput[]
  }

  export type UserChallengeProgressUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<UserChallengeProgressCreateWithoutChallengeInput, UserChallengeProgressUncheckedCreateWithoutChallengeInput> | UserChallengeProgressCreateWithoutChallengeInput[] | UserChallengeProgressUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeProgressCreateOrConnectWithoutChallengeInput | UserChallengeProgressCreateOrConnectWithoutChallengeInput[]
    upsert?: UserChallengeProgressUpsertWithWhereUniqueWithoutChallengeInput | UserChallengeProgressUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: UserChallengeProgressCreateManyChallengeInputEnvelope
    set?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    disconnect?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    delete?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    connect?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    update?: UserChallengeProgressUpdateWithWhereUniqueWithoutChallengeInput | UserChallengeProgressUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: UserChallengeProgressUpdateManyWithWhereWithoutChallengeInput | UserChallengeProgressUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: UserChallengeProgressScalarWhereInput | UserChallengeProgressScalarWhereInput[]
  }

  export type EventChallengeUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<EventChallengeCreateWithoutChallengeInput, EventChallengeUncheckedCreateWithoutChallengeInput> | EventChallengeCreateWithoutChallengeInput[] | EventChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: EventChallengeCreateOrConnectWithoutChallengeInput | EventChallengeCreateOrConnectWithoutChallengeInput[]
    upsert?: EventChallengeUpsertWithWhereUniqueWithoutChallengeInput | EventChallengeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: EventChallengeCreateManyChallengeInputEnvelope
    set?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    disconnect?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    delete?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    connect?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    update?: EventChallengeUpdateWithWhereUniqueWithoutChallengeInput | EventChallengeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: EventChallengeUpdateManyWithWhereWithoutChallengeInput | EventChallengeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: EventChallengeScalarWhereInput | EventChallengeScalarWhereInput[]
  }

  export type ChallengeTaskUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<ChallengeTaskCreateWithoutChallengeInput, ChallengeTaskUncheckedCreateWithoutChallengeInput> | ChallengeTaskCreateWithoutChallengeInput[] | ChallengeTaskUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: ChallengeTaskCreateOrConnectWithoutChallengeInput | ChallengeTaskCreateOrConnectWithoutChallengeInput[]
    upsert?: ChallengeTaskUpsertWithWhereUniqueWithoutChallengeInput | ChallengeTaskUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: ChallengeTaskCreateManyChallengeInputEnvelope
    set?: ChallengeTaskWhereUniqueInput | ChallengeTaskWhereUniqueInput[]
    disconnect?: ChallengeTaskWhereUniqueInput | ChallengeTaskWhereUniqueInput[]
    delete?: ChallengeTaskWhereUniqueInput | ChallengeTaskWhereUniqueInput[]
    connect?: ChallengeTaskWhereUniqueInput | ChallengeTaskWhereUniqueInput[]
    update?: ChallengeTaskUpdateWithWhereUniqueWithoutChallengeInput | ChallengeTaskUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: ChallengeTaskUpdateManyWithWhereWithoutChallengeInput | ChallengeTaskUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: ChallengeTaskScalarWhereInput | ChallengeTaskScalarWhereInput[]
  }

  export type UserChallengeProgressUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<UserChallengeProgressCreateWithoutChallengeInput, UserChallengeProgressUncheckedCreateWithoutChallengeInput> | UserChallengeProgressCreateWithoutChallengeInput[] | UserChallengeProgressUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: UserChallengeProgressCreateOrConnectWithoutChallengeInput | UserChallengeProgressCreateOrConnectWithoutChallengeInput[]
    upsert?: UserChallengeProgressUpsertWithWhereUniqueWithoutChallengeInput | UserChallengeProgressUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: UserChallengeProgressCreateManyChallengeInputEnvelope
    set?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    disconnect?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    delete?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    connect?: UserChallengeProgressWhereUniqueInput | UserChallengeProgressWhereUniqueInput[]
    update?: UserChallengeProgressUpdateWithWhereUniqueWithoutChallengeInput | UserChallengeProgressUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: UserChallengeProgressUpdateManyWithWhereWithoutChallengeInput | UserChallengeProgressUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: UserChallengeProgressScalarWhereInput | UserChallengeProgressScalarWhereInput[]
  }

  export type EventChallengeUncheckedUpdateManyWithoutChallengeNestedInput = {
    create?: XOR<EventChallengeCreateWithoutChallengeInput, EventChallengeUncheckedCreateWithoutChallengeInput> | EventChallengeCreateWithoutChallengeInput[] | EventChallengeUncheckedCreateWithoutChallengeInput[]
    connectOrCreate?: EventChallengeCreateOrConnectWithoutChallengeInput | EventChallengeCreateOrConnectWithoutChallengeInput[]
    upsert?: EventChallengeUpsertWithWhereUniqueWithoutChallengeInput | EventChallengeUpsertWithWhereUniqueWithoutChallengeInput[]
    createMany?: EventChallengeCreateManyChallengeInputEnvelope
    set?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    disconnect?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    delete?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    connect?: EventChallengeWhereUniqueInput | EventChallengeWhereUniqueInput[]
    update?: EventChallengeUpdateWithWhereUniqueWithoutChallengeInput | EventChallengeUpdateWithWhereUniqueWithoutChallengeInput[]
    updateMany?: EventChallengeUpdateManyWithWhereWithoutChallengeInput | EventChallengeUpdateManyWithWhereWithoutChallengeInput[]
    deleteMany?: EventChallengeScalarWhereInput | EventChallengeScalarWhereInput[]
  }

  export type ChallengeCreateNestedOneWithoutTasksInput = {
    create?: XOR<ChallengeCreateWithoutTasksInput, ChallengeUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutTasksInput
    connect?: ChallengeWhereUniqueInput
  }

  export type UserTaskCompletionCreateNestedManyWithoutTaskInput = {
    create?: XOR<UserTaskCompletionCreateWithoutTaskInput, UserTaskCompletionUncheckedCreateWithoutTaskInput> | UserTaskCompletionCreateWithoutTaskInput[] | UserTaskCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: UserTaskCompletionCreateOrConnectWithoutTaskInput | UserTaskCompletionCreateOrConnectWithoutTaskInput[]
    createMany?: UserTaskCompletionCreateManyTaskInputEnvelope
    connect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
  }

  export type UserTaskCompletionUncheckedCreateNestedManyWithoutTaskInput = {
    create?: XOR<UserTaskCompletionCreateWithoutTaskInput, UserTaskCompletionUncheckedCreateWithoutTaskInput> | UserTaskCompletionCreateWithoutTaskInput[] | UserTaskCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: UserTaskCompletionCreateOrConnectWithoutTaskInput | UserTaskCompletionCreateOrConnectWithoutTaskInput[]
    createMany?: UserTaskCompletionCreateManyTaskInputEnvelope
    connect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
  }

  export type ChallengeUpdateOneRequiredWithoutTasksNestedInput = {
    create?: XOR<ChallengeCreateWithoutTasksInput, ChallengeUncheckedCreateWithoutTasksInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutTasksInput
    upsert?: ChallengeUpsertWithoutTasksInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutTasksInput, ChallengeUpdateWithoutTasksInput>, ChallengeUncheckedUpdateWithoutTasksInput>
  }

  export type UserTaskCompletionUpdateManyWithoutTaskNestedInput = {
    create?: XOR<UserTaskCompletionCreateWithoutTaskInput, UserTaskCompletionUncheckedCreateWithoutTaskInput> | UserTaskCompletionCreateWithoutTaskInput[] | UserTaskCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: UserTaskCompletionCreateOrConnectWithoutTaskInput | UserTaskCompletionCreateOrConnectWithoutTaskInput[]
    upsert?: UserTaskCompletionUpsertWithWhereUniqueWithoutTaskInput | UserTaskCompletionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: UserTaskCompletionCreateManyTaskInputEnvelope
    set?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    disconnect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    delete?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    connect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    update?: UserTaskCompletionUpdateWithWhereUniqueWithoutTaskInput | UserTaskCompletionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: UserTaskCompletionUpdateManyWithWhereWithoutTaskInput | UserTaskCompletionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: UserTaskCompletionScalarWhereInput | UserTaskCompletionScalarWhereInput[]
  }

  export type UserTaskCompletionUncheckedUpdateManyWithoutTaskNestedInput = {
    create?: XOR<UserTaskCompletionCreateWithoutTaskInput, UserTaskCompletionUncheckedCreateWithoutTaskInput> | UserTaskCompletionCreateWithoutTaskInput[] | UserTaskCompletionUncheckedCreateWithoutTaskInput[]
    connectOrCreate?: UserTaskCompletionCreateOrConnectWithoutTaskInput | UserTaskCompletionCreateOrConnectWithoutTaskInput[]
    upsert?: UserTaskCompletionUpsertWithWhereUniqueWithoutTaskInput | UserTaskCompletionUpsertWithWhereUniqueWithoutTaskInput[]
    createMany?: UserTaskCompletionCreateManyTaskInputEnvelope
    set?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    disconnect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    delete?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    connect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    update?: UserTaskCompletionUpdateWithWhereUniqueWithoutTaskInput | UserTaskCompletionUpdateWithWhereUniqueWithoutTaskInput[]
    updateMany?: UserTaskCompletionUpdateManyWithWhereWithoutTaskInput | UserTaskCompletionUpdateManyWithWhereWithoutTaskInput[]
    deleteMany?: UserTaskCompletionScalarWhereInput | UserTaskCompletionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutChallengeProgressInput = {
    create?: XOR<UserCreateWithoutChallengeProgressInput, UserUncheckedCreateWithoutChallengeProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengeProgressInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeCreateNestedOneWithoutUserProgressInput = {
    create?: XOR<ChallengeCreateWithoutUserProgressInput, ChallengeUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutUserProgressInput
    connect?: ChallengeWhereUniqueInput
  }

  export type UserTaskCompletionCreateNestedManyWithoutProgressInput = {
    create?: XOR<UserTaskCompletionCreateWithoutProgressInput, UserTaskCompletionUncheckedCreateWithoutProgressInput> | UserTaskCompletionCreateWithoutProgressInput[] | UserTaskCompletionUncheckedCreateWithoutProgressInput[]
    connectOrCreate?: UserTaskCompletionCreateOrConnectWithoutProgressInput | UserTaskCompletionCreateOrConnectWithoutProgressInput[]
    createMany?: UserTaskCompletionCreateManyProgressInputEnvelope
    connect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
  }

  export type UserTaskCompletionUncheckedCreateNestedManyWithoutProgressInput = {
    create?: XOR<UserTaskCompletionCreateWithoutProgressInput, UserTaskCompletionUncheckedCreateWithoutProgressInput> | UserTaskCompletionCreateWithoutProgressInput[] | UserTaskCompletionUncheckedCreateWithoutProgressInput[]
    connectOrCreate?: UserTaskCompletionCreateOrConnectWithoutProgressInput | UserTaskCompletionCreateOrConnectWithoutProgressInput[]
    createMany?: UserTaskCompletionCreateManyProgressInputEnvelope
    connect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
  }

  export type DecimalFieldUpdateOperationsInput = {
    set?: Decimal | DecimalJsLike | number | string
    increment?: Decimal | DecimalJsLike | number | string
    decrement?: Decimal | DecimalJsLike | number | string
    multiply?: Decimal | DecimalJsLike | number | string
    divide?: Decimal | DecimalJsLike | number | string
  }

  export type UserUpdateOneRequiredWithoutChallengeProgressNestedInput = {
    create?: XOR<UserCreateWithoutChallengeProgressInput, UserUncheckedCreateWithoutChallengeProgressInput>
    connectOrCreate?: UserCreateOrConnectWithoutChallengeProgressInput
    upsert?: UserUpsertWithoutChallengeProgressInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutChallengeProgressInput, UserUpdateWithoutChallengeProgressInput>, UserUncheckedUpdateWithoutChallengeProgressInput>
  }

  export type ChallengeUpdateOneRequiredWithoutUserProgressNestedInput = {
    create?: XOR<ChallengeCreateWithoutUserProgressInput, ChallengeUncheckedCreateWithoutUserProgressInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutUserProgressInput
    upsert?: ChallengeUpsertWithoutUserProgressInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutUserProgressInput, ChallengeUpdateWithoutUserProgressInput>, ChallengeUncheckedUpdateWithoutUserProgressInput>
  }

  export type UserTaskCompletionUpdateManyWithoutProgressNestedInput = {
    create?: XOR<UserTaskCompletionCreateWithoutProgressInput, UserTaskCompletionUncheckedCreateWithoutProgressInput> | UserTaskCompletionCreateWithoutProgressInput[] | UserTaskCompletionUncheckedCreateWithoutProgressInput[]
    connectOrCreate?: UserTaskCompletionCreateOrConnectWithoutProgressInput | UserTaskCompletionCreateOrConnectWithoutProgressInput[]
    upsert?: UserTaskCompletionUpsertWithWhereUniqueWithoutProgressInput | UserTaskCompletionUpsertWithWhereUniqueWithoutProgressInput[]
    createMany?: UserTaskCompletionCreateManyProgressInputEnvelope
    set?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    disconnect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    delete?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    connect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    update?: UserTaskCompletionUpdateWithWhereUniqueWithoutProgressInput | UserTaskCompletionUpdateWithWhereUniqueWithoutProgressInput[]
    updateMany?: UserTaskCompletionUpdateManyWithWhereWithoutProgressInput | UserTaskCompletionUpdateManyWithWhereWithoutProgressInput[]
    deleteMany?: UserTaskCompletionScalarWhereInput | UserTaskCompletionScalarWhereInput[]
  }

  export type UserTaskCompletionUncheckedUpdateManyWithoutProgressNestedInput = {
    create?: XOR<UserTaskCompletionCreateWithoutProgressInput, UserTaskCompletionUncheckedCreateWithoutProgressInput> | UserTaskCompletionCreateWithoutProgressInput[] | UserTaskCompletionUncheckedCreateWithoutProgressInput[]
    connectOrCreate?: UserTaskCompletionCreateOrConnectWithoutProgressInput | UserTaskCompletionCreateOrConnectWithoutProgressInput[]
    upsert?: UserTaskCompletionUpsertWithWhereUniqueWithoutProgressInput | UserTaskCompletionUpsertWithWhereUniqueWithoutProgressInput[]
    createMany?: UserTaskCompletionCreateManyProgressInputEnvelope
    set?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    disconnect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    delete?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    connect?: UserTaskCompletionWhereUniqueInput | UserTaskCompletionWhereUniqueInput[]
    update?: UserTaskCompletionUpdateWithWhereUniqueWithoutProgressInput | UserTaskCompletionUpdateWithWhereUniqueWithoutProgressInput[]
    updateMany?: UserTaskCompletionUpdateManyWithWhereWithoutProgressInput | UserTaskCompletionUpdateManyWithWhereWithoutProgressInput[]
    deleteMany?: UserTaskCompletionScalarWhereInput | UserTaskCompletionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTaskCompletionsInput = {
    create?: XOR<UserCreateWithoutTaskCompletionsInput, UserUncheckedCreateWithoutTaskCompletionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskCompletionsInput
    connect?: UserWhereUniqueInput
  }

  export type ChallengeTaskCreateNestedOneWithoutCompletionsInput = {
    create?: XOR<ChallengeTaskCreateWithoutCompletionsInput, ChallengeTaskUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: ChallengeTaskCreateOrConnectWithoutCompletionsInput
    connect?: ChallengeTaskWhereUniqueInput
  }

  export type UserChallengeProgressCreateNestedOneWithoutTaskCompletionsInput = {
    create?: XOR<UserChallengeProgressCreateWithoutTaskCompletionsInput, UserChallengeProgressUncheckedCreateWithoutTaskCompletionsInput>
    connectOrCreate?: UserChallengeProgressCreateOrConnectWithoutTaskCompletionsInput
    connect?: UserChallengeProgressWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutTaskCompletionsNestedInput = {
    create?: XOR<UserCreateWithoutTaskCompletionsInput, UserUncheckedCreateWithoutTaskCompletionsInput>
    connectOrCreate?: UserCreateOrConnectWithoutTaskCompletionsInput
    upsert?: UserUpsertWithoutTaskCompletionsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTaskCompletionsInput, UserUpdateWithoutTaskCompletionsInput>, UserUncheckedUpdateWithoutTaskCompletionsInput>
  }

  export type ChallengeTaskUpdateOneRequiredWithoutCompletionsNestedInput = {
    create?: XOR<ChallengeTaskCreateWithoutCompletionsInput, ChallengeTaskUncheckedCreateWithoutCompletionsInput>
    connectOrCreate?: ChallengeTaskCreateOrConnectWithoutCompletionsInput
    upsert?: ChallengeTaskUpsertWithoutCompletionsInput
    connect?: ChallengeTaskWhereUniqueInput
    update?: XOR<XOR<ChallengeTaskUpdateToOneWithWhereWithoutCompletionsInput, ChallengeTaskUpdateWithoutCompletionsInput>, ChallengeTaskUncheckedUpdateWithoutCompletionsInput>
  }

  export type UserChallengeProgressUpdateOneRequiredWithoutTaskCompletionsNestedInput = {
    create?: XOR<UserChallengeProgressCreateWithoutTaskCompletionsInput, UserChallengeProgressUncheckedCreateWithoutTaskCompletionsInput>
    connectOrCreate?: UserChallengeProgressCreateOrConnectWithoutTaskCompletionsInput
    upsert?: UserChallengeProgressUpsertWithoutTaskCompletionsInput
    connect?: UserChallengeProgressWhereUniqueInput
    update?: XOR<XOR<UserChallengeProgressUpdateToOneWithWhereWithoutTaskCompletionsInput, UserChallengeProgressUpdateWithoutTaskCompletionsInput>, UserChallengeProgressUncheckedUpdateWithoutTaskCompletionsInput>
  }

  export type UserCreateNestedOneWithoutBadgesInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutBadgesNestedInput = {
    create?: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    connectOrCreate?: UserCreateOrConnectWithoutBadgesInput
    upsert?: UserUpsertWithoutBadgesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutBadgesInput, UserUpdateWithoutBadgesInput>, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserCreateNestedOneWithoutAchievementsInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutAchievementsNestedInput = {
    create?: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    connectOrCreate?: UserCreateOrConnectWithoutAchievementsInput
    upsert?: UserUpsertWithoutAchievementsInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAchievementsInput, UserUpdateWithoutAchievementsInput>, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserCreateNestedOneWithoutLeaderboardEntriesInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntriesInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneRequiredWithoutLeaderboardEntriesNestedInput = {
    create?: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaderboardEntriesInput
    upsert?: UserUpsertWithoutLeaderboardEntriesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaderboardEntriesInput, UserUpdateWithoutLeaderboardEntriesInput>, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type EventCreateNestedOneWithoutEventChallengesInput = {
    create?: XOR<EventCreateWithoutEventChallengesInput, EventUncheckedCreateWithoutEventChallengesInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventChallengesInput
    connect?: EventWhereUniqueInput
  }

  export type ChallengeCreateNestedOneWithoutEventChallengesInput = {
    create?: XOR<ChallengeCreateWithoutEventChallengesInput, ChallengeUncheckedCreateWithoutEventChallengesInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutEventChallengesInput
    connect?: ChallengeWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutEventChallengesNestedInput = {
    create?: XOR<EventCreateWithoutEventChallengesInput, EventUncheckedCreateWithoutEventChallengesInput>
    connectOrCreate?: EventCreateOrConnectWithoutEventChallengesInput
    upsert?: EventUpsertWithoutEventChallengesInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutEventChallengesInput, EventUpdateWithoutEventChallengesInput>, EventUncheckedUpdateWithoutEventChallengesInput>
  }

  export type ChallengeUpdateOneRequiredWithoutEventChallengesNestedInput = {
    create?: XOR<ChallengeCreateWithoutEventChallengesInput, ChallengeUncheckedCreateWithoutEventChallengesInput>
    connectOrCreate?: ChallengeCreateOrConnectWithoutEventChallengesInput
    upsert?: ChallengeUpsertWithoutEventChallengesInput
    connect?: ChallengeWhereUniqueInput
    update?: XOR<XOR<ChallengeUpdateToOneWithWhereWithoutEventChallengesInput, ChallengeUpdateWithoutEventChallengesInput>, ChallengeUncheckedUpdateWithoutEventChallengesInput>
  }

  export type RoadmapPhaseCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<RoadmapPhaseCreateWithoutRoadmapInput, RoadmapPhaseUncheckedCreateWithoutRoadmapInput> | RoadmapPhaseCreateWithoutRoadmapInput[] | RoadmapPhaseUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutRoadmapInput | RoadmapPhaseCreateOrConnectWithoutRoadmapInput[]
    createMany?: RoadmapPhaseCreateManyRoadmapInputEnvelope
    connect?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
  }

  export type EventCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<EventCreateWithoutRoadmapInput, EventUncheckedCreateWithoutRoadmapInput> | EventCreateWithoutRoadmapInput[] | EventUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: EventCreateOrConnectWithoutRoadmapInput | EventCreateOrConnectWithoutRoadmapInput[]
    createMany?: EventCreateManyRoadmapInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type RoadmapPhaseUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<RoadmapPhaseCreateWithoutRoadmapInput, RoadmapPhaseUncheckedCreateWithoutRoadmapInput> | RoadmapPhaseCreateWithoutRoadmapInput[] | RoadmapPhaseUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutRoadmapInput | RoadmapPhaseCreateOrConnectWithoutRoadmapInput[]
    createMany?: RoadmapPhaseCreateManyRoadmapInputEnvelope
    connect?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
  }

  export type EventUncheckedCreateNestedManyWithoutRoadmapInput = {
    create?: XOR<EventCreateWithoutRoadmapInput, EventUncheckedCreateWithoutRoadmapInput> | EventCreateWithoutRoadmapInput[] | EventUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: EventCreateOrConnectWithoutRoadmapInput | EventCreateOrConnectWithoutRoadmapInput[]
    createMany?: EventCreateManyRoadmapInputEnvelope
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
  }

  export type RoadmapPhaseUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<RoadmapPhaseCreateWithoutRoadmapInput, RoadmapPhaseUncheckedCreateWithoutRoadmapInput> | RoadmapPhaseCreateWithoutRoadmapInput[] | RoadmapPhaseUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutRoadmapInput | RoadmapPhaseCreateOrConnectWithoutRoadmapInput[]
    upsert?: RoadmapPhaseUpsertWithWhereUniqueWithoutRoadmapInput | RoadmapPhaseUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: RoadmapPhaseCreateManyRoadmapInputEnvelope
    set?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    disconnect?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    delete?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    connect?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    update?: RoadmapPhaseUpdateWithWhereUniqueWithoutRoadmapInput | RoadmapPhaseUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: RoadmapPhaseUpdateManyWithWhereWithoutRoadmapInput | RoadmapPhaseUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: RoadmapPhaseScalarWhereInput | RoadmapPhaseScalarWhereInput[]
  }

  export type EventUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<EventCreateWithoutRoadmapInput, EventUncheckedCreateWithoutRoadmapInput> | EventCreateWithoutRoadmapInput[] | EventUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: EventCreateOrConnectWithoutRoadmapInput | EventCreateOrConnectWithoutRoadmapInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutRoadmapInput | EventUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: EventCreateManyRoadmapInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutRoadmapInput | EventUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: EventUpdateManyWithWhereWithoutRoadmapInput | EventUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type RoadmapPhaseUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<RoadmapPhaseCreateWithoutRoadmapInput, RoadmapPhaseUncheckedCreateWithoutRoadmapInput> | RoadmapPhaseCreateWithoutRoadmapInput[] | RoadmapPhaseUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutRoadmapInput | RoadmapPhaseCreateOrConnectWithoutRoadmapInput[]
    upsert?: RoadmapPhaseUpsertWithWhereUniqueWithoutRoadmapInput | RoadmapPhaseUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: RoadmapPhaseCreateManyRoadmapInputEnvelope
    set?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    disconnect?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    delete?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    connect?: RoadmapPhaseWhereUniqueInput | RoadmapPhaseWhereUniqueInput[]
    update?: RoadmapPhaseUpdateWithWhereUniqueWithoutRoadmapInput | RoadmapPhaseUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: RoadmapPhaseUpdateManyWithWhereWithoutRoadmapInput | RoadmapPhaseUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: RoadmapPhaseScalarWhereInput | RoadmapPhaseScalarWhereInput[]
  }

  export type EventUncheckedUpdateManyWithoutRoadmapNestedInput = {
    create?: XOR<EventCreateWithoutRoadmapInput, EventUncheckedCreateWithoutRoadmapInput> | EventCreateWithoutRoadmapInput[] | EventUncheckedCreateWithoutRoadmapInput[]
    connectOrCreate?: EventCreateOrConnectWithoutRoadmapInput | EventCreateOrConnectWithoutRoadmapInput[]
    upsert?: EventUpsertWithWhereUniqueWithoutRoadmapInput | EventUpsertWithWhereUniqueWithoutRoadmapInput[]
    createMany?: EventCreateManyRoadmapInputEnvelope
    set?: EventWhereUniqueInput | EventWhereUniqueInput[]
    disconnect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    delete?: EventWhereUniqueInput | EventWhereUniqueInput[]
    connect?: EventWhereUniqueInput | EventWhereUniqueInput[]
    update?: EventUpdateWithWhereUniqueWithoutRoadmapInput | EventUpdateWithWhereUniqueWithoutRoadmapInput[]
    updateMany?: EventUpdateManyWithWhereWithoutRoadmapInput | EventUpdateManyWithWhereWithoutRoadmapInput[]
    deleteMany?: EventScalarWhereInput | EventScalarWhereInput[]
  }

  export type RoadmapCreateNestedOneWithoutPhasesInput = {
    create?: XOR<RoadmapCreateWithoutPhasesInput, RoadmapUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutPhasesInput
    connect?: RoadmapWhereUniqueInput
  }

  export type PhaseSectionCreateNestedManyWithoutPhaseInput = {
    create?: XOR<PhaseSectionCreateWithoutPhaseInput, PhaseSectionUncheckedCreateWithoutPhaseInput> | PhaseSectionCreateWithoutPhaseInput[] | PhaseSectionUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: PhaseSectionCreateOrConnectWithoutPhaseInput | PhaseSectionCreateOrConnectWithoutPhaseInput[]
    createMany?: PhaseSectionCreateManyPhaseInputEnvelope
    connect?: PhaseSectionWhereUniqueInput | PhaseSectionWhereUniqueInput[]
  }

  export type PhasePlaylistCreateNestedManyWithoutPhaseInput = {
    create?: XOR<PhasePlaylistCreateWithoutPhaseInput, PhasePlaylistUncheckedCreateWithoutPhaseInput> | PhasePlaylistCreateWithoutPhaseInput[] | PhasePlaylistUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: PhasePlaylistCreateOrConnectWithoutPhaseInput | PhasePlaylistCreateOrConnectWithoutPhaseInput[]
    createMany?: PhasePlaylistCreateManyPhaseInputEnvelope
    connect?: PhasePlaylistWhereUniqueInput | PhasePlaylistWhereUniqueInput[]
  }

  export type PhaseProjectCreateNestedManyWithoutPhaseInput = {
    create?: XOR<PhaseProjectCreateWithoutPhaseInput, PhaseProjectUncheckedCreateWithoutPhaseInput> | PhaseProjectCreateWithoutPhaseInput[] | PhaseProjectUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: PhaseProjectCreateOrConnectWithoutPhaseInput | PhaseProjectCreateOrConnectWithoutPhaseInput[]
    createMany?: PhaseProjectCreateManyPhaseInputEnvelope
    connect?: PhaseProjectWhereUniqueInput | PhaseProjectWhereUniqueInput[]
  }

  export type PhaseSectionUncheckedCreateNestedManyWithoutPhaseInput = {
    create?: XOR<PhaseSectionCreateWithoutPhaseInput, PhaseSectionUncheckedCreateWithoutPhaseInput> | PhaseSectionCreateWithoutPhaseInput[] | PhaseSectionUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: PhaseSectionCreateOrConnectWithoutPhaseInput | PhaseSectionCreateOrConnectWithoutPhaseInput[]
    createMany?: PhaseSectionCreateManyPhaseInputEnvelope
    connect?: PhaseSectionWhereUniqueInput | PhaseSectionWhereUniqueInput[]
  }

  export type PhasePlaylistUncheckedCreateNestedManyWithoutPhaseInput = {
    create?: XOR<PhasePlaylistCreateWithoutPhaseInput, PhasePlaylistUncheckedCreateWithoutPhaseInput> | PhasePlaylistCreateWithoutPhaseInput[] | PhasePlaylistUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: PhasePlaylistCreateOrConnectWithoutPhaseInput | PhasePlaylistCreateOrConnectWithoutPhaseInput[]
    createMany?: PhasePlaylistCreateManyPhaseInputEnvelope
    connect?: PhasePlaylistWhereUniqueInput | PhasePlaylistWhereUniqueInput[]
  }

  export type PhaseProjectUncheckedCreateNestedManyWithoutPhaseInput = {
    create?: XOR<PhaseProjectCreateWithoutPhaseInput, PhaseProjectUncheckedCreateWithoutPhaseInput> | PhaseProjectCreateWithoutPhaseInput[] | PhaseProjectUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: PhaseProjectCreateOrConnectWithoutPhaseInput | PhaseProjectCreateOrConnectWithoutPhaseInput[]
    createMany?: PhaseProjectCreateManyPhaseInputEnvelope
    connect?: PhaseProjectWhereUniqueInput | PhaseProjectWhereUniqueInput[]
  }

  export type RoadmapUpdateOneRequiredWithoutPhasesNestedInput = {
    create?: XOR<RoadmapCreateWithoutPhasesInput, RoadmapUncheckedCreateWithoutPhasesInput>
    connectOrCreate?: RoadmapCreateOrConnectWithoutPhasesInput
    upsert?: RoadmapUpsertWithoutPhasesInput
    connect?: RoadmapWhereUniqueInput
    update?: XOR<XOR<RoadmapUpdateToOneWithWhereWithoutPhasesInput, RoadmapUpdateWithoutPhasesInput>, RoadmapUncheckedUpdateWithoutPhasesInput>
  }

  export type PhaseSectionUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<PhaseSectionCreateWithoutPhaseInput, PhaseSectionUncheckedCreateWithoutPhaseInput> | PhaseSectionCreateWithoutPhaseInput[] | PhaseSectionUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: PhaseSectionCreateOrConnectWithoutPhaseInput | PhaseSectionCreateOrConnectWithoutPhaseInput[]
    upsert?: PhaseSectionUpsertWithWhereUniqueWithoutPhaseInput | PhaseSectionUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: PhaseSectionCreateManyPhaseInputEnvelope
    set?: PhaseSectionWhereUniqueInput | PhaseSectionWhereUniqueInput[]
    disconnect?: PhaseSectionWhereUniqueInput | PhaseSectionWhereUniqueInput[]
    delete?: PhaseSectionWhereUniqueInput | PhaseSectionWhereUniqueInput[]
    connect?: PhaseSectionWhereUniqueInput | PhaseSectionWhereUniqueInput[]
    update?: PhaseSectionUpdateWithWhereUniqueWithoutPhaseInput | PhaseSectionUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: PhaseSectionUpdateManyWithWhereWithoutPhaseInput | PhaseSectionUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: PhaseSectionScalarWhereInput | PhaseSectionScalarWhereInput[]
  }

  export type PhasePlaylistUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<PhasePlaylistCreateWithoutPhaseInput, PhasePlaylistUncheckedCreateWithoutPhaseInput> | PhasePlaylistCreateWithoutPhaseInput[] | PhasePlaylistUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: PhasePlaylistCreateOrConnectWithoutPhaseInput | PhasePlaylistCreateOrConnectWithoutPhaseInput[]
    upsert?: PhasePlaylistUpsertWithWhereUniqueWithoutPhaseInput | PhasePlaylistUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: PhasePlaylistCreateManyPhaseInputEnvelope
    set?: PhasePlaylistWhereUniqueInput | PhasePlaylistWhereUniqueInput[]
    disconnect?: PhasePlaylistWhereUniqueInput | PhasePlaylistWhereUniqueInput[]
    delete?: PhasePlaylistWhereUniqueInput | PhasePlaylistWhereUniqueInput[]
    connect?: PhasePlaylistWhereUniqueInput | PhasePlaylistWhereUniqueInput[]
    update?: PhasePlaylistUpdateWithWhereUniqueWithoutPhaseInput | PhasePlaylistUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: PhasePlaylistUpdateManyWithWhereWithoutPhaseInput | PhasePlaylistUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: PhasePlaylistScalarWhereInput | PhasePlaylistScalarWhereInput[]
  }

  export type PhaseProjectUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<PhaseProjectCreateWithoutPhaseInput, PhaseProjectUncheckedCreateWithoutPhaseInput> | PhaseProjectCreateWithoutPhaseInput[] | PhaseProjectUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: PhaseProjectCreateOrConnectWithoutPhaseInput | PhaseProjectCreateOrConnectWithoutPhaseInput[]
    upsert?: PhaseProjectUpsertWithWhereUniqueWithoutPhaseInput | PhaseProjectUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: PhaseProjectCreateManyPhaseInputEnvelope
    set?: PhaseProjectWhereUniqueInput | PhaseProjectWhereUniqueInput[]
    disconnect?: PhaseProjectWhereUniqueInput | PhaseProjectWhereUniqueInput[]
    delete?: PhaseProjectWhereUniqueInput | PhaseProjectWhereUniqueInput[]
    connect?: PhaseProjectWhereUniqueInput | PhaseProjectWhereUniqueInput[]
    update?: PhaseProjectUpdateWithWhereUniqueWithoutPhaseInput | PhaseProjectUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: PhaseProjectUpdateManyWithWhereWithoutPhaseInput | PhaseProjectUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: PhaseProjectScalarWhereInput | PhaseProjectScalarWhereInput[]
  }

  export type PhaseSectionUncheckedUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<PhaseSectionCreateWithoutPhaseInput, PhaseSectionUncheckedCreateWithoutPhaseInput> | PhaseSectionCreateWithoutPhaseInput[] | PhaseSectionUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: PhaseSectionCreateOrConnectWithoutPhaseInput | PhaseSectionCreateOrConnectWithoutPhaseInput[]
    upsert?: PhaseSectionUpsertWithWhereUniqueWithoutPhaseInput | PhaseSectionUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: PhaseSectionCreateManyPhaseInputEnvelope
    set?: PhaseSectionWhereUniqueInput | PhaseSectionWhereUniqueInput[]
    disconnect?: PhaseSectionWhereUniqueInput | PhaseSectionWhereUniqueInput[]
    delete?: PhaseSectionWhereUniqueInput | PhaseSectionWhereUniqueInput[]
    connect?: PhaseSectionWhereUniqueInput | PhaseSectionWhereUniqueInput[]
    update?: PhaseSectionUpdateWithWhereUniqueWithoutPhaseInput | PhaseSectionUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: PhaseSectionUpdateManyWithWhereWithoutPhaseInput | PhaseSectionUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: PhaseSectionScalarWhereInput | PhaseSectionScalarWhereInput[]
  }

  export type PhasePlaylistUncheckedUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<PhasePlaylistCreateWithoutPhaseInput, PhasePlaylistUncheckedCreateWithoutPhaseInput> | PhasePlaylistCreateWithoutPhaseInput[] | PhasePlaylistUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: PhasePlaylistCreateOrConnectWithoutPhaseInput | PhasePlaylistCreateOrConnectWithoutPhaseInput[]
    upsert?: PhasePlaylistUpsertWithWhereUniqueWithoutPhaseInput | PhasePlaylistUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: PhasePlaylistCreateManyPhaseInputEnvelope
    set?: PhasePlaylistWhereUniqueInput | PhasePlaylistWhereUniqueInput[]
    disconnect?: PhasePlaylistWhereUniqueInput | PhasePlaylistWhereUniqueInput[]
    delete?: PhasePlaylistWhereUniqueInput | PhasePlaylistWhereUniqueInput[]
    connect?: PhasePlaylistWhereUniqueInput | PhasePlaylistWhereUniqueInput[]
    update?: PhasePlaylistUpdateWithWhereUniqueWithoutPhaseInput | PhasePlaylistUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: PhasePlaylistUpdateManyWithWhereWithoutPhaseInput | PhasePlaylistUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: PhasePlaylistScalarWhereInput | PhasePlaylistScalarWhereInput[]
  }

  export type PhaseProjectUncheckedUpdateManyWithoutPhaseNestedInput = {
    create?: XOR<PhaseProjectCreateWithoutPhaseInput, PhaseProjectUncheckedCreateWithoutPhaseInput> | PhaseProjectCreateWithoutPhaseInput[] | PhaseProjectUncheckedCreateWithoutPhaseInput[]
    connectOrCreate?: PhaseProjectCreateOrConnectWithoutPhaseInput | PhaseProjectCreateOrConnectWithoutPhaseInput[]
    upsert?: PhaseProjectUpsertWithWhereUniqueWithoutPhaseInput | PhaseProjectUpsertWithWhereUniqueWithoutPhaseInput[]
    createMany?: PhaseProjectCreateManyPhaseInputEnvelope
    set?: PhaseProjectWhereUniqueInput | PhaseProjectWhereUniqueInput[]
    disconnect?: PhaseProjectWhereUniqueInput | PhaseProjectWhereUniqueInput[]
    delete?: PhaseProjectWhereUniqueInput | PhaseProjectWhereUniqueInput[]
    connect?: PhaseProjectWhereUniqueInput | PhaseProjectWhereUniqueInput[]
    update?: PhaseProjectUpdateWithWhereUniqueWithoutPhaseInput | PhaseProjectUpdateWithWhereUniqueWithoutPhaseInput[]
    updateMany?: PhaseProjectUpdateManyWithWhereWithoutPhaseInput | PhaseProjectUpdateManyWithWhereWithoutPhaseInput[]
    deleteMany?: PhaseProjectScalarWhereInput | PhaseProjectScalarWhereInput[]
  }

  export type RoadmapPhaseCreateNestedOneWithoutSectionsInput = {
    create?: XOR<RoadmapPhaseCreateWithoutSectionsInput, RoadmapPhaseUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutSectionsInput
    connect?: RoadmapPhaseWhereUniqueInput
  }

  export type SectionItemCreateNestedManyWithoutSectionInput = {
    create?: XOR<SectionItemCreateWithoutSectionInput, SectionItemUncheckedCreateWithoutSectionInput> | SectionItemCreateWithoutSectionInput[] | SectionItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SectionItemCreateOrConnectWithoutSectionInput | SectionItemCreateOrConnectWithoutSectionInput[]
    createMany?: SectionItemCreateManySectionInputEnvelope
    connect?: SectionItemWhereUniqueInput | SectionItemWhereUniqueInput[]
  }

  export type SectionItemUncheckedCreateNestedManyWithoutSectionInput = {
    create?: XOR<SectionItemCreateWithoutSectionInput, SectionItemUncheckedCreateWithoutSectionInput> | SectionItemCreateWithoutSectionInput[] | SectionItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SectionItemCreateOrConnectWithoutSectionInput | SectionItemCreateOrConnectWithoutSectionInput[]
    createMany?: SectionItemCreateManySectionInputEnvelope
    connect?: SectionItemWhereUniqueInput | SectionItemWhereUniqueInput[]
  }

  export type RoadmapPhaseUpdateOneRequiredWithoutSectionsNestedInput = {
    create?: XOR<RoadmapPhaseCreateWithoutSectionsInput, RoadmapPhaseUncheckedCreateWithoutSectionsInput>
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutSectionsInput
    upsert?: RoadmapPhaseUpsertWithoutSectionsInput
    connect?: RoadmapPhaseWhereUniqueInput
    update?: XOR<XOR<RoadmapPhaseUpdateToOneWithWhereWithoutSectionsInput, RoadmapPhaseUpdateWithoutSectionsInput>, RoadmapPhaseUncheckedUpdateWithoutSectionsInput>
  }

  export type SectionItemUpdateManyWithoutSectionNestedInput = {
    create?: XOR<SectionItemCreateWithoutSectionInput, SectionItemUncheckedCreateWithoutSectionInput> | SectionItemCreateWithoutSectionInput[] | SectionItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SectionItemCreateOrConnectWithoutSectionInput | SectionItemCreateOrConnectWithoutSectionInput[]
    upsert?: SectionItemUpsertWithWhereUniqueWithoutSectionInput | SectionItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: SectionItemCreateManySectionInputEnvelope
    set?: SectionItemWhereUniqueInput | SectionItemWhereUniqueInput[]
    disconnect?: SectionItemWhereUniqueInput | SectionItemWhereUniqueInput[]
    delete?: SectionItemWhereUniqueInput | SectionItemWhereUniqueInput[]
    connect?: SectionItemWhereUniqueInput | SectionItemWhereUniqueInput[]
    update?: SectionItemUpdateWithWhereUniqueWithoutSectionInput | SectionItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: SectionItemUpdateManyWithWhereWithoutSectionInput | SectionItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: SectionItemScalarWhereInput | SectionItemScalarWhereInput[]
  }

  export type SectionItemUncheckedUpdateManyWithoutSectionNestedInput = {
    create?: XOR<SectionItemCreateWithoutSectionInput, SectionItemUncheckedCreateWithoutSectionInput> | SectionItemCreateWithoutSectionInput[] | SectionItemUncheckedCreateWithoutSectionInput[]
    connectOrCreate?: SectionItemCreateOrConnectWithoutSectionInput | SectionItemCreateOrConnectWithoutSectionInput[]
    upsert?: SectionItemUpsertWithWhereUniqueWithoutSectionInput | SectionItemUpsertWithWhereUniqueWithoutSectionInput[]
    createMany?: SectionItemCreateManySectionInputEnvelope
    set?: SectionItemWhereUniqueInput | SectionItemWhereUniqueInput[]
    disconnect?: SectionItemWhereUniqueInput | SectionItemWhereUniqueInput[]
    delete?: SectionItemWhereUniqueInput | SectionItemWhereUniqueInput[]
    connect?: SectionItemWhereUniqueInput | SectionItemWhereUniqueInput[]
    update?: SectionItemUpdateWithWhereUniqueWithoutSectionInput | SectionItemUpdateWithWhereUniqueWithoutSectionInput[]
    updateMany?: SectionItemUpdateManyWithWhereWithoutSectionInput | SectionItemUpdateManyWithWhereWithoutSectionInput[]
    deleteMany?: SectionItemScalarWhereInput | SectionItemScalarWhereInput[]
  }

  export type PhaseSectionCreateNestedOneWithoutItemsInput = {
    create?: XOR<PhaseSectionCreateWithoutItemsInput, PhaseSectionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PhaseSectionCreateOrConnectWithoutItemsInput
    connect?: PhaseSectionWhereUniqueInput
  }

  export type SubItemCreateNestedManyWithoutItemInput = {
    create?: XOR<SubItemCreateWithoutItemInput, SubItemUncheckedCreateWithoutItemInput> | SubItemCreateWithoutItemInput[] | SubItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SubItemCreateOrConnectWithoutItemInput | SubItemCreateOrConnectWithoutItemInput[]
    createMany?: SubItemCreateManyItemInputEnvelope
    connect?: SubItemWhereUniqueInput | SubItemWhereUniqueInput[]
  }

  export type SubItemUncheckedCreateNestedManyWithoutItemInput = {
    create?: XOR<SubItemCreateWithoutItemInput, SubItemUncheckedCreateWithoutItemInput> | SubItemCreateWithoutItemInput[] | SubItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SubItemCreateOrConnectWithoutItemInput | SubItemCreateOrConnectWithoutItemInput[]
    createMany?: SubItemCreateManyItemInputEnvelope
    connect?: SubItemWhereUniqueInput | SubItemWhereUniqueInput[]
  }

  export type PhaseSectionUpdateOneRequiredWithoutItemsNestedInput = {
    create?: XOR<PhaseSectionCreateWithoutItemsInput, PhaseSectionUncheckedCreateWithoutItemsInput>
    connectOrCreate?: PhaseSectionCreateOrConnectWithoutItemsInput
    upsert?: PhaseSectionUpsertWithoutItemsInput
    connect?: PhaseSectionWhereUniqueInput
    update?: XOR<XOR<PhaseSectionUpdateToOneWithWhereWithoutItemsInput, PhaseSectionUpdateWithoutItemsInput>, PhaseSectionUncheckedUpdateWithoutItemsInput>
  }

  export type SubItemUpdateManyWithoutItemNestedInput = {
    create?: XOR<SubItemCreateWithoutItemInput, SubItemUncheckedCreateWithoutItemInput> | SubItemCreateWithoutItemInput[] | SubItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SubItemCreateOrConnectWithoutItemInput | SubItemCreateOrConnectWithoutItemInput[]
    upsert?: SubItemUpsertWithWhereUniqueWithoutItemInput | SubItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SubItemCreateManyItemInputEnvelope
    set?: SubItemWhereUniqueInput | SubItemWhereUniqueInput[]
    disconnect?: SubItemWhereUniqueInput | SubItemWhereUniqueInput[]
    delete?: SubItemWhereUniqueInput | SubItemWhereUniqueInput[]
    connect?: SubItemWhereUniqueInput | SubItemWhereUniqueInput[]
    update?: SubItemUpdateWithWhereUniqueWithoutItemInput | SubItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SubItemUpdateManyWithWhereWithoutItemInput | SubItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SubItemScalarWhereInput | SubItemScalarWhereInput[]
  }

  export type SubItemUncheckedUpdateManyWithoutItemNestedInput = {
    create?: XOR<SubItemCreateWithoutItemInput, SubItemUncheckedCreateWithoutItemInput> | SubItemCreateWithoutItemInput[] | SubItemUncheckedCreateWithoutItemInput[]
    connectOrCreate?: SubItemCreateOrConnectWithoutItemInput | SubItemCreateOrConnectWithoutItemInput[]
    upsert?: SubItemUpsertWithWhereUniqueWithoutItemInput | SubItemUpsertWithWhereUniqueWithoutItemInput[]
    createMany?: SubItemCreateManyItemInputEnvelope
    set?: SubItemWhereUniqueInput | SubItemWhereUniqueInput[]
    disconnect?: SubItemWhereUniqueInput | SubItemWhereUniqueInput[]
    delete?: SubItemWhereUniqueInput | SubItemWhereUniqueInput[]
    connect?: SubItemWhereUniqueInput | SubItemWhereUniqueInput[]
    update?: SubItemUpdateWithWhereUniqueWithoutItemInput | SubItemUpdateWithWhereUniqueWithoutItemInput[]
    updateMany?: SubItemUpdateManyWithWhereWithoutItemInput | SubItemUpdateManyWithWhereWithoutItemInput[]
    deleteMany?: SubItemScalarWhereInput | SubItemScalarWhereInput[]
  }

  export type SectionItemCreateNestedOneWithoutSubItemsInput = {
    create?: XOR<SectionItemCreateWithoutSubItemsInput, SectionItemUncheckedCreateWithoutSubItemsInput>
    connectOrCreate?: SectionItemCreateOrConnectWithoutSubItemsInput
    connect?: SectionItemWhereUniqueInput
  }

  export type SectionItemUpdateOneRequiredWithoutSubItemsNestedInput = {
    create?: XOR<SectionItemCreateWithoutSubItemsInput, SectionItemUncheckedCreateWithoutSubItemsInput>
    connectOrCreate?: SectionItemCreateOrConnectWithoutSubItemsInput
    upsert?: SectionItemUpsertWithoutSubItemsInput
    connect?: SectionItemWhereUniqueInput
    update?: XOR<XOR<SectionItemUpdateToOneWithWhereWithoutSubItemsInput, SectionItemUpdateWithoutSubItemsInput>, SectionItemUncheckedUpdateWithoutSubItemsInput>
  }

  export type RoadmapPhaseCreateNestedOneWithoutPlaylistsInput = {
    create?: XOR<RoadmapPhaseCreateWithoutPlaylistsInput, RoadmapPhaseUncheckedCreateWithoutPlaylistsInput>
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutPlaylistsInput
    connect?: RoadmapPhaseWhereUniqueInput
  }

  export type RoadmapPhaseUpdateOneRequiredWithoutPlaylistsNestedInput = {
    create?: XOR<RoadmapPhaseCreateWithoutPlaylistsInput, RoadmapPhaseUncheckedCreateWithoutPlaylistsInput>
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutPlaylistsInput
    upsert?: RoadmapPhaseUpsertWithoutPlaylistsInput
    connect?: RoadmapPhaseWhereUniqueInput
    update?: XOR<XOR<RoadmapPhaseUpdateToOneWithWhereWithoutPlaylistsInput, RoadmapPhaseUpdateWithoutPlaylistsInput>, RoadmapPhaseUncheckedUpdateWithoutPlaylistsInput>
  }

  export type RoadmapPhaseCreateNestedOneWithoutProjectsInput = {
    create?: XOR<RoadmapPhaseCreateWithoutProjectsInput, RoadmapPhaseUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutProjectsInput
    connect?: RoadmapPhaseWhereUniqueInput
  }

  export type RoadmapPhaseUpdateOneRequiredWithoutProjectsNestedInput = {
    create?: XOR<RoadmapPhaseCreateWithoutProjectsInput, RoadmapPhaseUncheckedCreateWithoutProjectsInput>
    connectOrCreate?: RoadmapPhaseCreateOrConnectWithoutProjectsInput
    upsert?: RoadmapPhaseUpsertWithoutProjectsInput
    connect?: RoadmapPhaseWhereUniqueInput
    update?: XOR<XOR<RoadmapPhaseUpdateToOneWithWhereWithoutProjectsInput, RoadmapPhaseUpdateWithoutProjectsInput>, RoadmapPhaseUncheckedUpdateWithoutProjectsInput>
  }

  export type DSATopicCreateNestedManyWithoutSheetInput = {
    create?: XOR<DSATopicCreateWithoutSheetInput, DSATopicUncheckedCreateWithoutSheetInput> | DSATopicCreateWithoutSheetInput[] | DSATopicUncheckedCreateWithoutSheetInput[]
    connectOrCreate?: DSATopicCreateOrConnectWithoutSheetInput | DSATopicCreateOrConnectWithoutSheetInput[]
    createMany?: DSATopicCreateManySheetInputEnvelope
    connect?: DSATopicWhereUniqueInput | DSATopicWhereUniqueInput[]
  }

  export type DSATopicUncheckedCreateNestedManyWithoutSheetInput = {
    create?: XOR<DSATopicCreateWithoutSheetInput, DSATopicUncheckedCreateWithoutSheetInput> | DSATopicCreateWithoutSheetInput[] | DSATopicUncheckedCreateWithoutSheetInput[]
    connectOrCreate?: DSATopicCreateOrConnectWithoutSheetInput | DSATopicCreateOrConnectWithoutSheetInput[]
    createMany?: DSATopicCreateManySheetInputEnvelope
    connect?: DSATopicWhereUniqueInput | DSATopicWhereUniqueInput[]
  }

  export type DSATopicUpdateManyWithoutSheetNestedInput = {
    create?: XOR<DSATopicCreateWithoutSheetInput, DSATopicUncheckedCreateWithoutSheetInput> | DSATopicCreateWithoutSheetInput[] | DSATopicUncheckedCreateWithoutSheetInput[]
    connectOrCreate?: DSATopicCreateOrConnectWithoutSheetInput | DSATopicCreateOrConnectWithoutSheetInput[]
    upsert?: DSATopicUpsertWithWhereUniqueWithoutSheetInput | DSATopicUpsertWithWhereUniqueWithoutSheetInput[]
    createMany?: DSATopicCreateManySheetInputEnvelope
    set?: DSATopicWhereUniqueInput | DSATopicWhereUniqueInput[]
    disconnect?: DSATopicWhereUniqueInput | DSATopicWhereUniqueInput[]
    delete?: DSATopicWhereUniqueInput | DSATopicWhereUniqueInput[]
    connect?: DSATopicWhereUniqueInput | DSATopicWhereUniqueInput[]
    update?: DSATopicUpdateWithWhereUniqueWithoutSheetInput | DSATopicUpdateWithWhereUniqueWithoutSheetInput[]
    updateMany?: DSATopicUpdateManyWithWhereWithoutSheetInput | DSATopicUpdateManyWithWhereWithoutSheetInput[]
    deleteMany?: DSATopicScalarWhereInput | DSATopicScalarWhereInput[]
  }

  export type DSATopicUncheckedUpdateManyWithoutSheetNestedInput = {
    create?: XOR<DSATopicCreateWithoutSheetInput, DSATopicUncheckedCreateWithoutSheetInput> | DSATopicCreateWithoutSheetInput[] | DSATopicUncheckedCreateWithoutSheetInput[]
    connectOrCreate?: DSATopicCreateOrConnectWithoutSheetInput | DSATopicCreateOrConnectWithoutSheetInput[]
    upsert?: DSATopicUpsertWithWhereUniqueWithoutSheetInput | DSATopicUpsertWithWhereUniqueWithoutSheetInput[]
    createMany?: DSATopicCreateManySheetInputEnvelope
    set?: DSATopicWhereUniqueInput | DSATopicWhereUniqueInput[]
    disconnect?: DSATopicWhereUniqueInput | DSATopicWhereUniqueInput[]
    delete?: DSATopicWhereUniqueInput | DSATopicWhereUniqueInput[]
    connect?: DSATopicWhereUniqueInput | DSATopicWhereUniqueInput[]
    update?: DSATopicUpdateWithWhereUniqueWithoutSheetInput | DSATopicUpdateWithWhereUniqueWithoutSheetInput[]
    updateMany?: DSATopicUpdateManyWithWhereWithoutSheetInput | DSATopicUpdateManyWithWhereWithoutSheetInput[]
    deleteMany?: DSATopicScalarWhereInput | DSATopicScalarWhereInput[]
  }

  export type DSASheetCreateNestedOneWithoutTopicsInput = {
    create?: XOR<DSASheetCreateWithoutTopicsInput, DSASheetUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: DSASheetCreateOrConnectWithoutTopicsInput
    connect?: DSASheetWhereUniqueInput
  }

  export type DSAProblemCreateNestedManyWithoutTopicInput = {
    create?: XOR<DSAProblemCreateWithoutTopicInput, DSAProblemUncheckedCreateWithoutTopicInput> | DSAProblemCreateWithoutTopicInput[] | DSAProblemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: DSAProblemCreateOrConnectWithoutTopicInput | DSAProblemCreateOrConnectWithoutTopicInput[]
    createMany?: DSAProblemCreateManyTopicInputEnvelope
    connect?: DSAProblemWhereUniqueInput | DSAProblemWhereUniqueInput[]
  }

  export type DSAProblemUncheckedCreateNestedManyWithoutTopicInput = {
    create?: XOR<DSAProblemCreateWithoutTopicInput, DSAProblemUncheckedCreateWithoutTopicInput> | DSAProblemCreateWithoutTopicInput[] | DSAProblemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: DSAProblemCreateOrConnectWithoutTopicInput | DSAProblemCreateOrConnectWithoutTopicInput[]
    createMany?: DSAProblemCreateManyTopicInputEnvelope
    connect?: DSAProblemWhereUniqueInput | DSAProblemWhereUniqueInput[]
  }

  export type DSASheetUpdateOneRequiredWithoutTopicsNestedInput = {
    create?: XOR<DSASheetCreateWithoutTopicsInput, DSASheetUncheckedCreateWithoutTopicsInput>
    connectOrCreate?: DSASheetCreateOrConnectWithoutTopicsInput
    upsert?: DSASheetUpsertWithoutTopicsInput
    connect?: DSASheetWhereUniqueInput
    update?: XOR<XOR<DSASheetUpdateToOneWithWhereWithoutTopicsInput, DSASheetUpdateWithoutTopicsInput>, DSASheetUncheckedUpdateWithoutTopicsInput>
  }

  export type DSAProblemUpdateManyWithoutTopicNestedInput = {
    create?: XOR<DSAProblemCreateWithoutTopicInput, DSAProblemUncheckedCreateWithoutTopicInput> | DSAProblemCreateWithoutTopicInput[] | DSAProblemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: DSAProblemCreateOrConnectWithoutTopicInput | DSAProblemCreateOrConnectWithoutTopicInput[]
    upsert?: DSAProblemUpsertWithWhereUniqueWithoutTopicInput | DSAProblemUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: DSAProblemCreateManyTopicInputEnvelope
    set?: DSAProblemWhereUniqueInput | DSAProblemWhereUniqueInput[]
    disconnect?: DSAProblemWhereUniqueInput | DSAProblemWhereUniqueInput[]
    delete?: DSAProblemWhereUniqueInput | DSAProblemWhereUniqueInput[]
    connect?: DSAProblemWhereUniqueInput | DSAProblemWhereUniqueInput[]
    update?: DSAProblemUpdateWithWhereUniqueWithoutTopicInput | DSAProblemUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: DSAProblemUpdateManyWithWhereWithoutTopicInput | DSAProblemUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: DSAProblemScalarWhereInput | DSAProblemScalarWhereInput[]
  }

  export type DSAProblemUncheckedUpdateManyWithoutTopicNestedInput = {
    create?: XOR<DSAProblemCreateWithoutTopicInput, DSAProblemUncheckedCreateWithoutTopicInput> | DSAProblemCreateWithoutTopicInput[] | DSAProblemUncheckedCreateWithoutTopicInput[]
    connectOrCreate?: DSAProblemCreateOrConnectWithoutTopicInput | DSAProblemCreateOrConnectWithoutTopicInput[]
    upsert?: DSAProblemUpsertWithWhereUniqueWithoutTopicInput | DSAProblemUpsertWithWhereUniqueWithoutTopicInput[]
    createMany?: DSAProblemCreateManyTopicInputEnvelope
    set?: DSAProblemWhereUniqueInput | DSAProblemWhereUniqueInput[]
    disconnect?: DSAProblemWhereUniqueInput | DSAProblemWhereUniqueInput[]
    delete?: DSAProblemWhereUniqueInput | DSAProblemWhereUniqueInput[]
    connect?: DSAProblemWhereUniqueInput | DSAProblemWhereUniqueInput[]
    update?: DSAProblemUpdateWithWhereUniqueWithoutTopicInput | DSAProblemUpdateWithWhereUniqueWithoutTopicInput[]
    updateMany?: DSAProblemUpdateManyWithWhereWithoutTopicInput | DSAProblemUpdateManyWithWhereWithoutTopicInput[]
    deleteMany?: DSAProblemScalarWhereInput | DSAProblemScalarWhereInput[]
  }

  export type DSATopicCreateNestedOneWithoutProblemsInput = {
    create?: XOR<DSATopicCreateWithoutProblemsInput, DSATopicUncheckedCreateWithoutProblemsInput>
    connectOrCreate?: DSATopicCreateOrConnectWithoutProblemsInput
    connect?: DSATopicWhereUniqueInput
  }

  export type DSASolutionCreateNestedManyWithoutProblemInput = {
    create?: XOR<DSASolutionCreateWithoutProblemInput, DSASolutionUncheckedCreateWithoutProblemInput> | DSASolutionCreateWithoutProblemInput[] | DSASolutionUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: DSASolutionCreateOrConnectWithoutProblemInput | DSASolutionCreateOrConnectWithoutProblemInput[]
    createMany?: DSASolutionCreateManyProblemInputEnvelope
    connect?: DSASolutionWhereUniqueInput | DSASolutionWhereUniqueInput[]
  }

  export type DSASolutionUncheckedCreateNestedManyWithoutProblemInput = {
    create?: XOR<DSASolutionCreateWithoutProblemInput, DSASolutionUncheckedCreateWithoutProblemInput> | DSASolutionCreateWithoutProblemInput[] | DSASolutionUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: DSASolutionCreateOrConnectWithoutProblemInput | DSASolutionCreateOrConnectWithoutProblemInput[]
    createMany?: DSASolutionCreateManyProblemInputEnvelope
    connect?: DSASolutionWhereUniqueInput | DSASolutionWhereUniqueInput[]
  }

  export type DSATopicUpdateOneRequiredWithoutProblemsNestedInput = {
    create?: XOR<DSATopicCreateWithoutProblemsInput, DSATopicUncheckedCreateWithoutProblemsInput>
    connectOrCreate?: DSATopicCreateOrConnectWithoutProblemsInput
    upsert?: DSATopicUpsertWithoutProblemsInput
    connect?: DSATopicWhereUniqueInput
    update?: XOR<XOR<DSATopicUpdateToOneWithWhereWithoutProblemsInput, DSATopicUpdateWithoutProblemsInput>, DSATopicUncheckedUpdateWithoutProblemsInput>
  }

  export type DSASolutionUpdateManyWithoutProblemNestedInput = {
    create?: XOR<DSASolutionCreateWithoutProblemInput, DSASolutionUncheckedCreateWithoutProblemInput> | DSASolutionCreateWithoutProblemInput[] | DSASolutionUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: DSASolutionCreateOrConnectWithoutProblemInput | DSASolutionCreateOrConnectWithoutProblemInput[]
    upsert?: DSASolutionUpsertWithWhereUniqueWithoutProblemInput | DSASolutionUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: DSASolutionCreateManyProblemInputEnvelope
    set?: DSASolutionWhereUniqueInput | DSASolutionWhereUniqueInput[]
    disconnect?: DSASolutionWhereUniqueInput | DSASolutionWhereUniqueInput[]
    delete?: DSASolutionWhereUniqueInput | DSASolutionWhereUniqueInput[]
    connect?: DSASolutionWhereUniqueInput | DSASolutionWhereUniqueInput[]
    update?: DSASolutionUpdateWithWhereUniqueWithoutProblemInput | DSASolutionUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: DSASolutionUpdateManyWithWhereWithoutProblemInput | DSASolutionUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: DSASolutionScalarWhereInput | DSASolutionScalarWhereInput[]
  }

  export type DSASolutionUncheckedUpdateManyWithoutProblemNestedInput = {
    create?: XOR<DSASolutionCreateWithoutProblemInput, DSASolutionUncheckedCreateWithoutProblemInput> | DSASolutionCreateWithoutProblemInput[] | DSASolutionUncheckedCreateWithoutProblemInput[]
    connectOrCreate?: DSASolutionCreateOrConnectWithoutProblemInput | DSASolutionCreateOrConnectWithoutProblemInput[]
    upsert?: DSASolutionUpsertWithWhereUniqueWithoutProblemInput | DSASolutionUpsertWithWhereUniqueWithoutProblemInput[]
    createMany?: DSASolutionCreateManyProblemInputEnvelope
    set?: DSASolutionWhereUniqueInput | DSASolutionWhereUniqueInput[]
    disconnect?: DSASolutionWhereUniqueInput | DSASolutionWhereUniqueInput[]
    delete?: DSASolutionWhereUniqueInput | DSASolutionWhereUniqueInput[]
    connect?: DSASolutionWhereUniqueInput | DSASolutionWhereUniqueInput[]
    update?: DSASolutionUpdateWithWhereUniqueWithoutProblemInput | DSASolutionUpdateWithWhereUniqueWithoutProblemInput[]
    updateMany?: DSASolutionUpdateManyWithWhereWithoutProblemInput | DSASolutionUpdateManyWithWhereWithoutProblemInput[]
    deleteMany?: DSASolutionScalarWhereInput | DSASolutionScalarWhereInput[]
  }

  export type DSAProblemCreateNestedOneWithoutSolutionsInput = {
    create?: XOR<DSAProblemCreateWithoutSolutionsInput, DSAProblemUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: DSAProblemCreateOrConnectWithoutSolutionsInput
    connect?: DSAProblemWhereUniqueInput
  }

  export type DSAProblemUpdateOneRequiredWithoutSolutionsNestedInput = {
    create?: XOR<DSAProblemCreateWithoutSolutionsInput, DSAProblemUncheckedCreateWithoutSolutionsInput>
    connectOrCreate?: DSAProblemCreateOrConnectWithoutSolutionsInput
    upsert?: DSAProblemUpsertWithoutSolutionsInput
    connect?: DSAProblemWhereUniqueInput
    update?: XOR<XOR<DSAProblemUpdateToOneWithWhereWithoutSolutionsInput, DSAProblemUpdateWithoutSolutionsInput>, DSAProblemUncheckedUpdateWithoutSolutionsInput>
  }

  export type EventCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<EventCreateWithoutCertificatesInput, EventUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: EventCreateOrConnectWithoutCertificatesInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificatesInput
    connect?: UserWhereUniqueInput
  }

  export type TeamCreateNestedOneWithoutCertificatesInput = {
    create?: XOR<TeamCreateWithoutCertificatesInput, TeamUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutCertificatesInput
    connect?: TeamWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<EventCreateWithoutCertificatesInput, EventUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: EventCreateOrConnectWithoutCertificatesInput
    upsert?: EventUpsertWithoutCertificatesInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutCertificatesInput, EventUpdateWithoutCertificatesInput>, EventUncheckedUpdateWithoutCertificatesInput>
  }

  export type UserUpdateOneRequiredWithoutCertificatesNestedInput = {
    create?: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: UserCreateOrConnectWithoutCertificatesInput
    upsert?: UserUpsertWithoutCertificatesInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutCertificatesInput, UserUpdateWithoutCertificatesInput>, UserUncheckedUpdateWithoutCertificatesInput>
  }

  export type TeamUpdateOneWithoutCertificatesNestedInput = {
    create?: XOR<TeamCreateWithoutCertificatesInput, TeamUncheckedCreateWithoutCertificatesInput>
    connectOrCreate?: TeamCreateOrConnectWithoutCertificatesInput
    upsert?: TeamUpsertWithoutCertificatesInput
    disconnect?: TeamWhereInput | boolean
    delete?: TeamWhereInput | boolean
    connect?: TeamWhereUniqueInput
    update?: XOR<XOR<TeamUpdateToOneWithWhereWithoutCertificatesInput, TeamUpdateWithoutCertificatesInput>, TeamUncheckedUpdateWithoutCertificatesInput>
  }

  export type EventCreateNestedOneWithoutEmailLogsInput = {
    create?: XOR<EventCreateWithoutEmailLogsInput, EventUncheckedCreateWithoutEmailLogsInput>
    connectOrCreate?: EventCreateOrConnectWithoutEmailLogsInput
    connect?: EventWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmailsSentInput = {
    create?: XOR<UserCreateWithoutEmailsSentInput, UserUncheckedCreateWithoutEmailsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailsSentInput
    connect?: UserWhereUniqueInput
  }

  export type EventUpdateOneRequiredWithoutEmailLogsNestedInput = {
    create?: XOR<EventCreateWithoutEmailLogsInput, EventUncheckedCreateWithoutEmailLogsInput>
    connectOrCreate?: EventCreateOrConnectWithoutEmailLogsInput
    upsert?: EventUpsertWithoutEmailLogsInput
    connect?: EventWhereUniqueInput
    update?: XOR<XOR<EventUpdateToOneWithWhereWithoutEmailLogsInput, EventUpdateWithoutEmailLogsInput>, EventUncheckedUpdateWithoutEmailLogsInput>
  }

  export type UserUpdateOneRequiredWithoutEmailsSentNestedInput = {
    create?: XOR<UserCreateWithoutEmailsSentInput, UserUncheckedCreateWithoutEmailsSentInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmailsSentInput
    upsert?: UserUpsertWithoutEmailsSentInput
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmailsSentInput, UserUpdateWithoutEmailsSentInput>, UserUncheckedUpdateWithoutEmailsSentInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[]
    notIn?: string[]
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | null
    notIn?: string[] | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }
  export type NestedJsonNullableFilter<$PrismaModel = never> = 
    | PatchUndefined<
        Either<Required<NestedJsonNullableFilterBase<$PrismaModel>>, Exclude<keyof Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>,
        Required<NestedJsonNullableFilterBase<$PrismaModel>>
      >
    | OptionalFlat<Omit<Required<NestedJsonNullableFilterBase<$PrismaModel>>, 'path'>>

  export type NestedJsonNullableFilterBase<$PrismaModel = never> = {
    equals?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
    path?: string
    string_contains?: string | StringFieldRefInput<$PrismaModel>
    string_starts_with?: string | StringFieldRefInput<$PrismaModel>
    string_ends_with?: string | StringFieldRefInput<$PrismaModel>
    array_contains?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_starts_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    array_ends_with?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | null
    lt?: InputJsonValue
    lte?: InputJsonValue
    gt?: InputJsonValue
    gte?: InputJsonValue
    not?: InputJsonValue | JsonFieldRefInput<$PrismaModel> | JsonNullValueFilter
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[]
    notIn?: number[]
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[]
    notIn?: Date[] | string[]
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | null
    notIn?: Date[] | string[] | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | null
    notIn?: number[] | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDecimalNullableFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDecimalNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel> | null
    in?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[] | null
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalNullableWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedDecimalNullableFilter<$PrismaModel>
    _sum?: NestedDecimalNullableFilter<$PrismaModel>
    _min?: NestedDecimalNullableFilter<$PrismaModel>
    _max?: NestedDecimalNullableFilter<$PrismaModel>
  }

  export type NestedDecimalFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
  }

  export type NestedDecimalWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    in?: Decimal[] | DecimalJsLike[] | number[] | string[]
    notIn?: Decimal[] | DecimalJsLike[] | number[] | string[]
    lt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    lte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gt?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    gte?: Decimal | DecimalJsLike | number | string | DecimalFieldRefInput<$PrismaModel>
    not?: NestedDecimalWithAggregatesFilter<$PrismaModel> | Decimal | DecimalJsLike | number | string
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedDecimalFilter<$PrismaModel>
    _sum?: NestedDecimalFilter<$PrismaModel>
    _min?: NestedDecimalFilter<$PrismaModel>
    _max?: NestedDecimalFilter<$PrismaModel>
  }

  export type EventRegistrationCreateWithoutUserInput = {
    id?: string
    participationType?: string
    paymentStatus?: string
    paymentId?: string | null
    amountPaid?: Decimal | DecimalJsLike | number | string | null
    paidAt?: Date | string | null
    status?: string
    registeredAt?: Date | string
    cancelledAt?: Date | string | null
    event: EventCreateNestedOneWithoutRegistrationsInput
    team?: TeamCreateNestedOneWithoutRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    teamId?: string | null
    participationType?: string
    paymentStatus?: string
    paymentId?: string | null
    amountPaid?: Decimal | DecimalJsLike | number | string | null
    paidAt?: Date | string | null
    status?: string
    registeredAt?: Date | string
    cancelledAt?: Date | string | null
  }

  export type EventRegistrationCreateOrConnectWithoutUserInput = {
    where: EventRegistrationWhereUniqueInput
    create: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput>
  }

  export type EventRegistrationCreateManyUserInputEnvelope = {
    data: EventRegistrationCreateManyUserInput | EventRegistrationCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutLeaderInput = {
    id?: string
    teamName: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutTeamsInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionCreateNestedManyWithoutTeamInput
    certificates?: CertificateCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutLeaderInput = {
    id?: string
    eventId: string
    teamName: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutTeamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutLeaderInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutLeaderInput, TeamUncheckedCreateWithoutLeaderInput>
  }

  export type TeamCreateManyLeaderInputEnvelope = {
    data: TeamCreateManyLeaderInput | TeamCreateManyLeaderInput[]
    skipDuplicates?: boolean
  }

  export type TeamMemberCreateWithoutUserInput = {
    id?: string
    isLeader?: boolean
    status?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
    team: TeamCreateNestedOneWithoutMembersInput
  }

  export type TeamMemberUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    isLeader?: boolean
    status?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TeamMemberCreateOrConnectWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberCreateManyUserInputEnvelope = {
    data: TeamMemberCreateManyUserInput | TeamMemberCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TeamJoinRequestCreateWithoutUserInput = {
    id?: string
    requestType: string
    status?: string
    message?: string | null
    responseMessage?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
    team: TeamCreateNestedOneWithoutJoinRequestsInput
  }

  export type TeamJoinRequestUncheckedCreateWithoutUserInput = {
    id?: string
    teamId: string
    requestType: string
    status?: string
    message?: string | null
    responseMessage?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type TeamJoinRequestCreateOrConnectWithoutUserInput = {
    where: TeamJoinRequestWhereUniqueInput
    create: XOR<TeamJoinRequestCreateWithoutUserInput, TeamJoinRequestUncheckedCreateWithoutUserInput>
  }

  export type TeamJoinRequestCreateManyUserInputEnvelope = {
    data: TeamJoinRequestCreateManyUserInput | TeamJoinRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventSubmissionCreateWithoutUserInput = {
    id?: string
    projectDeckUrl?: string | null
    presentationPdfUrl?: string | null
    mvpLink?: string | null
    demoVideoUrl?: string | null
    githubRepoUrl?: string | null
    technologiesUsed?: string | null
    aiToolsIntegrated?: string | null
    solutionDescription?: string | null
    score?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    feedback?: string | null
    status?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    evaluatedAt?: Date | string | null
    event: EventCreateNestedOneWithoutSubmissionsInput
    team?: TeamCreateNestedOneWithoutSubmissionsInput
  }

  export type EventSubmissionUncheckedCreateWithoutUserInput = {
    id?: string
    eventId: string
    teamId?: string | null
    projectDeckUrl?: string | null
    presentationPdfUrl?: string | null
    mvpLink?: string | null
    demoVideoUrl?: string | null
    githubRepoUrl?: string | null
    technologiesUsed?: string | null
    aiToolsIntegrated?: string | null
    solutionDescription?: string | null
    score?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    feedback?: string | null
    status?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    evaluatedAt?: Date | string | null
  }

  export type EventSubmissionCreateOrConnectWithoutUserInput = {
    where: EventSubmissionWhereUniqueInput
    create: XOR<EventSubmissionCreateWithoutUserInput, EventSubmissionUncheckedCreateWithoutUserInput>
  }

  export type EventSubmissionCreateManyUserInputEnvelope = {
    data: EventSubmissionCreateManyUserInput | EventSubmissionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserChallengeProgressCreateWithoutUserInput = {
    id?: string
    status?: string
    completedDays?: number
    totalDays: number
    completionPercentage?: Decimal | DecimalJsLike | number | string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    totalPoints?: number
    bonusPoints?: number
    currentRank?: number | null
    startedAt?: Date | string
    lastActivity?: Date | string
    completedAt?: Date | string | null
    certificateIssued?: boolean
    certificateUrl?: string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    challenge: ChallengeCreateNestedOneWithoutUserProgressInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutProgressInput
  }

  export type UserChallengeProgressUncheckedCreateWithoutUserInput = {
    id?: string
    challengeId: string
    status?: string
    completedDays?: number
    totalDays: number
    completionPercentage?: Decimal | DecimalJsLike | number | string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    totalPoints?: number
    bonusPoints?: number
    currentRank?: number | null
    startedAt?: Date | string
    lastActivity?: Date | string
    completedAt?: Date | string | null
    certificateIssued?: boolean
    certificateUrl?: string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutProgressInput
  }

  export type UserChallengeProgressCreateOrConnectWithoutUserInput = {
    where: UserChallengeProgressWhereUniqueInput
    create: XOR<UserChallengeProgressCreateWithoutUserInput, UserChallengeProgressUncheckedCreateWithoutUserInput>
  }

  export type UserChallengeProgressCreateManyUserInputEnvelope = {
    data: UserChallengeProgressCreateManyUserInput | UserChallengeProgressCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserTaskCompletionCreateWithoutUserInput = {
    id?: string
    challengeId: string
    completedAt?: Date | string
    timeTaken?: number | null
    submissionUrl?: string | null
    submissionText?: string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    score?: Decimal | DecimalJsLike | number | string | null
    pointsEarned?: number | null
    userNotes?: string | null
    feedback?: string | null
    task: ChallengeTaskCreateNestedOneWithoutCompletionsInput
    progress: UserChallengeProgressCreateNestedOneWithoutTaskCompletionsInput
  }

  export type UserTaskCompletionUncheckedCreateWithoutUserInput = {
    id?: string
    challengeId: string
    taskId: string
    progressId: string
    completedAt?: Date | string
    timeTaken?: number | null
    submissionUrl?: string | null
    submissionText?: string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    score?: Decimal | DecimalJsLike | number | string | null
    pointsEarned?: number | null
    userNotes?: string | null
    feedback?: string | null
  }

  export type UserTaskCompletionCreateOrConnectWithoutUserInput = {
    where: UserTaskCompletionWhereUniqueInput
    create: XOR<UserTaskCompletionCreateWithoutUserInput, UserTaskCompletionUncheckedCreateWithoutUserInput>
  }

  export type UserTaskCompletionCreateManyUserInputEnvelope = {
    data: UserTaskCompletionCreateManyUserInput | UserTaskCompletionCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserBadgeCreateWithoutUserInput = {
    id?: string
    badgeType: string
    badgeName: string
    badgeDescription?: string | null
    badgeIcon?: string | null
    badgeColor?: string | null
    relatedChallengeId?: string | null
    relatedEventId?: string | null
    pointsAwarded?: number
    earnedAt?: Date | string
  }

  export type UserBadgeUncheckedCreateWithoutUserInput = {
    id?: string
    badgeType: string
    badgeName: string
    badgeDescription?: string | null
    badgeIcon?: string | null
    badgeColor?: string | null
    relatedChallengeId?: string | null
    relatedEventId?: string | null
    pointsAwarded?: number
    earnedAt?: Date | string
  }

  export type UserBadgeCreateOrConnectWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeCreateManyUserInputEnvelope = {
    data: UserBadgeCreateManyUserInput | UserBadgeCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type UserAchievementCreateWithoutUserInput = {
    id?: string
    achievementType: string
    achievementName: string
    description?: string | null
    value?: number | null
    target?: number | null
    rarity?: string | null
    earnedAt?: Date | string
  }

  export type UserAchievementUncheckedCreateWithoutUserInput = {
    id?: string
    achievementType: string
    achievementName: string
    description?: string | null
    value?: number | null
    target?: number | null
    rarity?: string | null
    earnedAt?: Date | string
  }

  export type UserAchievementCreateOrConnectWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementCreateManyUserInputEnvelope = {
    data: UserAchievementCreateManyUserInput | UserAchievementCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type LeaderboardCreateWithoutUserInput = {
    id?: string
    leaderboardType: string
    relatedId?: string | null
    timePeriod?: string | null
    score?: number
    rank?: number | null
    previousRank?: number | null
    totalCompletions?: number
    currentStreak?: number
    updatedAt?: Date | string
  }

  export type LeaderboardUncheckedCreateWithoutUserInput = {
    id?: string
    leaderboardType: string
    relatedId?: string | null
    timePeriod?: string | null
    score?: number
    rank?: number | null
    previousRank?: number | null
    totalCompletions?: number
    currentStreak?: number
    updatedAt?: Date | string
  }

  export type LeaderboardCreateOrConnectWithoutUserInput = {
    where: LeaderboardWhereUniqueInput
    create: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardCreateManyUserInputEnvelope = {
    data: LeaderboardCreateManyUserInput | LeaderboardCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutCreatorInput = {
    id?: string
    title: string
    slug: string
    description: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    hasChallenges?: boolean
    problemCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: EventCategoryCreateNestedOneWithoutEventsInput
    roadmap?: RoadmapCreateNestedOneWithoutEventsInput
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
    teams?: TeamCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogCreateNestedManyWithoutEventInput
    certificates?: CertificateCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: string | null
    hasChallenges?: boolean
    problemCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutEventInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCreatorInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput>
  }

  export type EventCreateManyCreatorInputEnvelope = {
    data: EventCreateManyCreatorInput | EventCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeCreateWithoutCreatorInput = {
    id?: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date | string
    endDate: Date | string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: number | null
    bannerImage?: string | null
    icon?: string | null
    status?: string
    totalParticipants?: number
    activeParticipants?: number
    completionRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: ChallengeTaskCreateNestedManyWithoutChallengeInput
    userProgress?: UserChallengeProgressCreateNestedManyWithoutChallengeInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutCreatorInput = {
    id?: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date | string
    endDate: Date | string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: number | null
    bannerImage?: string | null
    icon?: string | null
    status?: string
    totalParticipants?: number
    activeParticipants?: number
    completionRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: ChallengeTaskUncheckedCreateNestedManyWithoutChallengeInput
    userProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutChallengeInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutCreatorInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutCreatorInput, ChallengeUncheckedCreateWithoutCreatorInput>
  }

  export type ChallengeCreateManyCreatorInputEnvelope = {
    data: ChallengeCreateManyCreatorInput | ChallengeCreateManyCreatorInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutUserInput = {
    id?: string
    certificateId: string
    participantName: string
    position?: string | null
    issuedAt?: Date | string
    event: EventCreateNestedOneWithoutCertificatesInput
    team?: TeamCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutUserInput = {
    id?: string
    certificateId: string
    eventId: string
    teamId?: string | null
    participantName: string
    position?: string | null
    issuedAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutUserInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput>
  }

  export type CertificateCreateManyUserInputEnvelope = {
    data: CertificateCreateManyUserInput | CertificateCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmailLogCreateWithoutSenderInput = {
    id?: string
    subject: string
    message: string
    recipientCount: number
    sentAt?: Date | string
    event: EventCreateNestedOneWithoutEmailLogsInput
  }

  export type EmailLogUncheckedCreateWithoutSenderInput = {
    id?: string
    eventId: string
    subject: string
    message: string
    recipientCount: number
    sentAt?: Date | string
  }

  export type EmailLogCreateOrConnectWithoutSenderInput = {
    where: EmailLogWhereUniqueInput
    create: XOR<EmailLogCreateWithoutSenderInput, EmailLogUncheckedCreateWithoutSenderInput>
  }

  export type EmailLogCreateManySenderInputEnvelope = {
    data: EmailLogCreateManySenderInput | EmailLogCreateManySenderInput[]
    skipDuplicates?: boolean
  }

  export type EventRegistrationUpsertWithWhereUniqueWithoutUserInput = {
    where: EventRegistrationWhereUniqueInput
    update: XOR<EventRegistrationUpdateWithoutUserInput, EventRegistrationUncheckedUpdateWithoutUserInput>
    create: XOR<EventRegistrationCreateWithoutUserInput, EventRegistrationUncheckedCreateWithoutUserInput>
  }

  export type EventRegistrationUpdateWithWhereUniqueWithoutUserInput = {
    where: EventRegistrationWhereUniqueInput
    data: XOR<EventRegistrationUpdateWithoutUserInput, EventRegistrationUncheckedUpdateWithoutUserInput>
  }

  export type EventRegistrationUpdateManyWithWhereWithoutUserInput = {
    where: EventRegistrationScalarWhereInput
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyWithoutUserInput>
  }

  export type EventRegistrationScalarWhereInput = {
    AND?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
    OR?: EventRegistrationScalarWhereInput[]
    NOT?: EventRegistrationScalarWhereInput | EventRegistrationScalarWhereInput[]
    id?: StringFilter<"EventRegistration"> | string
    eventId?: StringFilter<"EventRegistration"> | string
    userId?: StringFilter<"EventRegistration"> | string
    teamId?: StringNullableFilter<"EventRegistration"> | string | null
    participationType?: StringFilter<"EventRegistration"> | string
    paymentStatus?: StringFilter<"EventRegistration"> | string
    paymentId?: StringNullableFilter<"EventRegistration"> | string | null
    amountPaid?: DecimalNullableFilter<"EventRegistration"> | Decimal | DecimalJsLike | number | string | null
    paidAt?: DateTimeNullableFilter<"EventRegistration"> | Date | string | null
    status?: StringFilter<"EventRegistration"> | string
    registeredAt?: DateTimeFilter<"EventRegistration"> | Date | string
    cancelledAt?: DateTimeNullableFilter<"EventRegistration"> | Date | string | null
  }

  export type TeamUpsertWithWhereUniqueWithoutLeaderInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutLeaderInput, TeamUncheckedUpdateWithoutLeaderInput>
    create: XOR<TeamCreateWithoutLeaderInput, TeamUncheckedCreateWithoutLeaderInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutLeaderInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutLeaderInput, TeamUncheckedUpdateWithoutLeaderInput>
  }

  export type TeamUpdateManyWithWhereWithoutLeaderInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutLeaderInput>
  }

  export type TeamScalarWhereInput = {
    AND?: TeamScalarWhereInput | TeamScalarWhereInput[]
    OR?: TeamScalarWhereInput[]
    NOT?: TeamScalarWhereInput | TeamScalarWhereInput[]
    id?: StringFilter<"Team"> | string
    eventId?: StringFilter<"Team"> | string
    teamName?: StringFilter<"Team"> | string
    teamLeaderId?: StringFilter<"Team"> | string
    isComplete?: BoolFilter<"Team"> | boolean
    isLocked?: BoolFilter<"Team"> | boolean
    collegeName?: StringNullableFilter<"Team"> | string | null
    createdAt?: DateTimeFilter<"Team"> | Date | string
    updatedAt?: DateTimeFilter<"Team"> | Date | string
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
    create: XOR<TeamMemberCreateWithoutUserInput, TeamMemberUncheckedCreateWithoutUserInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutUserInput, TeamMemberUncheckedUpdateWithoutUserInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutUserInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamMemberScalarWhereInput = {
    AND?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    OR?: TeamMemberScalarWhereInput[]
    NOT?: TeamMemberScalarWhereInput | TeamMemberScalarWhereInput[]
    id?: StringFilter<"TeamMember"> | string
    teamId?: StringFilter<"TeamMember"> | string
    userId?: StringFilter<"TeamMember"> | string
    isLeader?: BoolFilter<"TeamMember"> | boolean
    status?: StringFilter<"TeamMember"> | string
    joinedAt?: DateTimeFilter<"TeamMember"> | Date | string
    leftAt?: DateTimeNullableFilter<"TeamMember"> | Date | string | null
  }

  export type TeamJoinRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: TeamJoinRequestWhereUniqueInput
    update: XOR<TeamJoinRequestUpdateWithoutUserInput, TeamJoinRequestUncheckedUpdateWithoutUserInput>
    create: XOR<TeamJoinRequestCreateWithoutUserInput, TeamJoinRequestUncheckedCreateWithoutUserInput>
  }

  export type TeamJoinRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: TeamJoinRequestWhereUniqueInput
    data: XOR<TeamJoinRequestUpdateWithoutUserInput, TeamJoinRequestUncheckedUpdateWithoutUserInput>
  }

  export type TeamJoinRequestUpdateManyWithWhereWithoutUserInput = {
    where: TeamJoinRequestScalarWhereInput
    data: XOR<TeamJoinRequestUpdateManyMutationInput, TeamJoinRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type TeamJoinRequestScalarWhereInput = {
    AND?: TeamJoinRequestScalarWhereInput | TeamJoinRequestScalarWhereInput[]
    OR?: TeamJoinRequestScalarWhereInput[]
    NOT?: TeamJoinRequestScalarWhereInput | TeamJoinRequestScalarWhereInput[]
    id?: StringFilter<"TeamJoinRequest"> | string
    teamId?: StringFilter<"TeamJoinRequest"> | string
    userId?: StringFilter<"TeamJoinRequest"> | string
    requestType?: StringFilter<"TeamJoinRequest"> | string
    status?: StringFilter<"TeamJoinRequest"> | string
    message?: StringNullableFilter<"TeamJoinRequest"> | string | null
    responseMessage?: StringNullableFilter<"TeamJoinRequest"> | string | null
    createdAt?: DateTimeFilter<"TeamJoinRequest"> | Date | string
    respondedAt?: DateTimeNullableFilter<"TeamJoinRequest"> | Date | string | null
  }

  export type EventSubmissionUpsertWithWhereUniqueWithoutUserInput = {
    where: EventSubmissionWhereUniqueInput
    update: XOR<EventSubmissionUpdateWithoutUserInput, EventSubmissionUncheckedUpdateWithoutUserInput>
    create: XOR<EventSubmissionCreateWithoutUserInput, EventSubmissionUncheckedCreateWithoutUserInput>
  }

  export type EventSubmissionUpdateWithWhereUniqueWithoutUserInput = {
    where: EventSubmissionWhereUniqueInput
    data: XOR<EventSubmissionUpdateWithoutUserInput, EventSubmissionUncheckedUpdateWithoutUserInput>
  }

  export type EventSubmissionUpdateManyWithWhereWithoutUserInput = {
    where: EventSubmissionScalarWhereInput
    data: XOR<EventSubmissionUpdateManyMutationInput, EventSubmissionUncheckedUpdateManyWithoutUserInput>
  }

  export type EventSubmissionScalarWhereInput = {
    AND?: EventSubmissionScalarWhereInput | EventSubmissionScalarWhereInput[]
    OR?: EventSubmissionScalarWhereInput[]
    NOT?: EventSubmissionScalarWhereInput | EventSubmissionScalarWhereInput[]
    id?: StringFilter<"EventSubmission"> | string
    eventId?: StringFilter<"EventSubmission"> | string
    userId?: StringFilter<"EventSubmission"> | string
    teamId?: StringNullableFilter<"EventSubmission"> | string | null
    projectDeckUrl?: StringNullableFilter<"EventSubmission"> | string | null
    presentationPdfUrl?: StringNullableFilter<"EventSubmission"> | string | null
    mvpLink?: StringNullableFilter<"EventSubmission"> | string | null
    demoVideoUrl?: StringNullableFilter<"EventSubmission"> | string | null
    githubRepoUrl?: StringNullableFilter<"EventSubmission"> | string | null
    technologiesUsed?: StringNullableFilter<"EventSubmission"> | string | null
    aiToolsIntegrated?: StringNullableFilter<"EventSubmission"> | string | null
    solutionDescription?: StringNullableFilter<"EventSubmission"> | string | null
    score?: DecimalNullableFilter<"EventSubmission"> | Decimal | DecimalJsLike | number | string | null
    rank?: IntNullableFilter<"EventSubmission"> | number | null
    feedback?: StringNullableFilter<"EventSubmission"> | string | null
    status?: StringFilter<"EventSubmission"> | string
    submittedAt?: DateTimeFilter<"EventSubmission"> | Date | string
    updatedAt?: DateTimeFilter<"EventSubmission"> | Date | string
    evaluatedAt?: DateTimeNullableFilter<"EventSubmission"> | Date | string | null
  }

  export type UserChallengeProgressUpsertWithWhereUniqueWithoutUserInput = {
    where: UserChallengeProgressWhereUniqueInput
    update: XOR<UserChallengeProgressUpdateWithoutUserInput, UserChallengeProgressUncheckedUpdateWithoutUserInput>
    create: XOR<UserChallengeProgressCreateWithoutUserInput, UserChallengeProgressUncheckedCreateWithoutUserInput>
  }

  export type UserChallengeProgressUpdateWithWhereUniqueWithoutUserInput = {
    where: UserChallengeProgressWhereUniqueInput
    data: XOR<UserChallengeProgressUpdateWithoutUserInput, UserChallengeProgressUncheckedUpdateWithoutUserInput>
  }

  export type UserChallengeProgressUpdateManyWithWhereWithoutUserInput = {
    where: UserChallengeProgressScalarWhereInput
    data: XOR<UserChallengeProgressUpdateManyMutationInput, UserChallengeProgressUncheckedUpdateManyWithoutUserInput>
  }

  export type UserChallengeProgressScalarWhereInput = {
    AND?: UserChallengeProgressScalarWhereInput | UserChallengeProgressScalarWhereInput[]
    OR?: UserChallengeProgressScalarWhereInput[]
    NOT?: UserChallengeProgressScalarWhereInput | UserChallengeProgressScalarWhereInput[]
    id?: StringFilter<"UserChallengeProgress"> | string
    userId?: StringFilter<"UserChallengeProgress"> | string
    challengeId?: StringFilter<"UserChallengeProgress"> | string
    status?: StringFilter<"UserChallengeProgress"> | string
    completedDays?: IntFilter<"UserChallengeProgress"> | number
    totalDays?: IntFilter<"UserChallengeProgress"> | number
    completionPercentage?: DecimalFilter<"UserChallengeProgress"> | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFilter<"UserChallengeProgress"> | number
    longestStreak?: IntFilter<"UserChallengeProgress"> | number
    lastCompletedDate?: DateTimeNullableFilter<"UserChallengeProgress"> | Date | string | null
    totalPoints?: IntFilter<"UserChallengeProgress"> | number
    bonusPoints?: IntFilter<"UserChallengeProgress"> | number
    currentRank?: IntNullableFilter<"UserChallengeProgress"> | number | null
    startedAt?: DateTimeFilter<"UserChallengeProgress"> | Date | string
    lastActivity?: DateTimeFilter<"UserChallengeProgress"> | Date | string
    completedAt?: DateTimeNullableFilter<"UserChallengeProgress"> | Date | string | null
    certificateIssued?: BoolFilter<"UserChallengeProgress"> | boolean
    certificateUrl?: StringNullableFilter<"UserChallengeProgress"> | string | null
    completedTaskIds?: JsonNullableFilter<"UserChallengeProgress">
    skippedTaskIds?: JsonNullableFilter<"UserChallengeProgress">
  }

  export type UserTaskCompletionUpsertWithWhereUniqueWithoutUserInput = {
    where: UserTaskCompletionWhereUniqueInput
    update: XOR<UserTaskCompletionUpdateWithoutUserInput, UserTaskCompletionUncheckedUpdateWithoutUserInput>
    create: XOR<UserTaskCompletionCreateWithoutUserInput, UserTaskCompletionUncheckedCreateWithoutUserInput>
  }

  export type UserTaskCompletionUpdateWithWhereUniqueWithoutUserInput = {
    where: UserTaskCompletionWhereUniqueInput
    data: XOR<UserTaskCompletionUpdateWithoutUserInput, UserTaskCompletionUncheckedUpdateWithoutUserInput>
  }

  export type UserTaskCompletionUpdateManyWithWhereWithoutUserInput = {
    where: UserTaskCompletionScalarWhereInput
    data: XOR<UserTaskCompletionUpdateManyMutationInput, UserTaskCompletionUncheckedUpdateManyWithoutUserInput>
  }

  export type UserTaskCompletionScalarWhereInput = {
    AND?: UserTaskCompletionScalarWhereInput | UserTaskCompletionScalarWhereInput[]
    OR?: UserTaskCompletionScalarWhereInput[]
    NOT?: UserTaskCompletionScalarWhereInput | UserTaskCompletionScalarWhereInput[]
    id?: StringFilter<"UserTaskCompletion"> | string
    userId?: StringFilter<"UserTaskCompletion"> | string
    challengeId?: StringFilter<"UserTaskCompletion"> | string
    taskId?: StringFilter<"UserTaskCompletion"> | string
    progressId?: StringFilter<"UserTaskCompletion"> | string
    completedAt?: DateTimeFilter<"UserTaskCompletion"> | Date | string
    timeTaken?: IntNullableFilter<"UserTaskCompletion"> | number | null
    submissionUrl?: StringNullableFilter<"UserTaskCompletion"> | string | null
    submissionText?: StringNullableFilter<"UserTaskCompletion"> | string | null
    submissionFiles?: JsonNullableFilter<"UserTaskCompletion">
    isVerified?: BoolFilter<"UserTaskCompletion"> | boolean
    verifiedBy?: StringNullableFilter<"UserTaskCompletion"> | string | null
    verifiedAt?: DateTimeNullableFilter<"UserTaskCompletion"> | Date | string | null
    score?: DecimalNullableFilter<"UserTaskCompletion"> | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: IntNullableFilter<"UserTaskCompletion"> | number | null
    userNotes?: StringNullableFilter<"UserTaskCompletion"> | string | null
    feedback?: StringNullableFilter<"UserTaskCompletion"> | string | null
  }

  export type UserBadgeUpsertWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    update: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
    create: XOR<UserBadgeCreateWithoutUserInput, UserBadgeUncheckedCreateWithoutUserInput>
  }

  export type UserBadgeUpdateWithWhereUniqueWithoutUserInput = {
    where: UserBadgeWhereUniqueInput
    data: XOR<UserBadgeUpdateWithoutUserInput, UserBadgeUncheckedUpdateWithoutUserInput>
  }

  export type UserBadgeUpdateManyWithWhereWithoutUserInput = {
    where: UserBadgeScalarWhereInput
    data: XOR<UserBadgeUpdateManyMutationInput, UserBadgeUncheckedUpdateManyWithoutUserInput>
  }

  export type UserBadgeScalarWhereInput = {
    AND?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    OR?: UserBadgeScalarWhereInput[]
    NOT?: UserBadgeScalarWhereInput | UserBadgeScalarWhereInput[]
    id?: StringFilter<"UserBadge"> | string
    userId?: StringFilter<"UserBadge"> | string
    badgeType?: StringFilter<"UserBadge"> | string
    badgeName?: StringFilter<"UserBadge"> | string
    badgeDescription?: StringNullableFilter<"UserBadge"> | string | null
    badgeIcon?: StringNullableFilter<"UserBadge"> | string | null
    badgeColor?: StringNullableFilter<"UserBadge"> | string | null
    relatedChallengeId?: StringNullableFilter<"UserBadge"> | string | null
    relatedEventId?: StringNullableFilter<"UserBadge"> | string | null
    pointsAwarded?: IntFilter<"UserBadge"> | number
    earnedAt?: DateTimeFilter<"UserBadge"> | Date | string
  }

  export type UserAchievementUpsertWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    update: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
    create: XOR<UserAchievementCreateWithoutUserInput, UserAchievementUncheckedCreateWithoutUserInput>
  }

  export type UserAchievementUpdateWithWhereUniqueWithoutUserInput = {
    where: UserAchievementWhereUniqueInput
    data: XOR<UserAchievementUpdateWithoutUserInput, UserAchievementUncheckedUpdateWithoutUserInput>
  }

  export type UserAchievementUpdateManyWithWhereWithoutUserInput = {
    where: UserAchievementScalarWhereInput
    data: XOR<UserAchievementUpdateManyMutationInput, UserAchievementUncheckedUpdateManyWithoutUserInput>
  }

  export type UserAchievementScalarWhereInput = {
    AND?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    OR?: UserAchievementScalarWhereInput[]
    NOT?: UserAchievementScalarWhereInput | UserAchievementScalarWhereInput[]
    id?: StringFilter<"UserAchievement"> | string
    userId?: StringFilter<"UserAchievement"> | string
    achievementType?: StringFilter<"UserAchievement"> | string
    achievementName?: StringFilter<"UserAchievement"> | string
    description?: StringNullableFilter<"UserAchievement"> | string | null
    value?: IntNullableFilter<"UserAchievement"> | number | null
    target?: IntNullableFilter<"UserAchievement"> | number | null
    rarity?: StringNullableFilter<"UserAchievement"> | string | null
    earnedAt?: DateTimeFilter<"UserAchievement"> | Date | string
  }

  export type LeaderboardUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaderboardWhereUniqueInput
    update: XOR<LeaderboardUpdateWithoutUserInput, LeaderboardUncheckedUpdateWithoutUserInput>
    create: XOR<LeaderboardCreateWithoutUserInput, LeaderboardUncheckedCreateWithoutUserInput>
  }

  export type LeaderboardUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaderboardWhereUniqueInput
    data: XOR<LeaderboardUpdateWithoutUserInput, LeaderboardUncheckedUpdateWithoutUserInput>
  }

  export type LeaderboardUpdateManyWithWhereWithoutUserInput = {
    where: LeaderboardScalarWhereInput
    data: XOR<LeaderboardUpdateManyMutationInput, LeaderboardUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaderboardScalarWhereInput = {
    AND?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
    OR?: LeaderboardScalarWhereInput[]
    NOT?: LeaderboardScalarWhereInput | LeaderboardScalarWhereInput[]
    id?: StringFilter<"Leaderboard"> | string
    userId?: StringFilter<"Leaderboard"> | string
    leaderboardType?: StringFilter<"Leaderboard"> | string
    relatedId?: StringNullableFilter<"Leaderboard"> | string | null
    timePeriod?: StringNullableFilter<"Leaderboard"> | string | null
    score?: IntFilter<"Leaderboard"> | number
    rank?: IntNullableFilter<"Leaderboard"> | number | null
    previousRank?: IntNullableFilter<"Leaderboard"> | number | null
    totalCompletions?: IntFilter<"Leaderboard"> | number
    currentStreak?: IntFilter<"Leaderboard"> | number
    updatedAt?: DateTimeFilter<"Leaderboard"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutCreatorInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCreatorInput, EventUncheckedUpdateWithoutCreatorInput>
    create: XOR<EventCreateWithoutCreatorInput, EventUncheckedCreateWithoutCreatorInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCreatorInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCreatorInput, EventUncheckedUpdateWithoutCreatorInput>
  }

  export type EventUpdateManyWithWhereWithoutCreatorInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutCreatorInput>
  }

  export type EventScalarWhereInput = {
    AND?: EventScalarWhereInput | EventScalarWhereInput[]
    OR?: EventScalarWhereInput[]
    NOT?: EventScalarWhereInput | EventScalarWhereInput[]
    id?: StringFilter<"Event"> | string
    title?: StringFilter<"Event"> | string
    slug?: StringFilter<"Event"> | string
    description?: StringFilter<"Event"> | string
    categoryId?: StringFilter<"Event"> | string
    eventType?: StringFilter<"Event"> | string
    mode?: StringFilter<"Event"> | string
    registrationStart?: DateTimeFilter<"Event"> | Date | string
    registrationEnd?: DateTimeFilter<"Event"> | Date | string
    maxParticipants?: IntNullableFilter<"Event"> | number | null
    isTeamEvent?: BoolFilter<"Event"> | boolean
    allowIndividual?: BoolFilter<"Event"> | boolean
    minTeamSize?: IntFilter<"Event"> | number
    maxTeamSize?: IntFilter<"Event"> | number
    teamFormationDeadline?: DateTimeNullableFilter<"Event"> | Date | string | null
    restrictSameCollege?: BoolFilter<"Event"> | boolean
    eventStart?: DateTimeFilter<"Event"> | Date | string
    eventEnd?: DateTimeFilter<"Event"> | Date | string
    isPaid?: BoolFilter<"Event"> | boolean
    registrationFee?: DecimalNullableFilter<"Event"> | Decimal | DecimalJsLike | number | string | null
    currency?: StringFilter<"Event"> | string
    hasSubmission?: BoolFilter<"Event"> | boolean
    submissionStart?: DateTimeNullableFilter<"Event"> | Date | string | null
    submissionDeadline?: DateTimeNullableFilter<"Event"> | Date | string | null
    submissionTemplateUrl?: StringNullableFilter<"Event"> | string | null
    rules?: StringNullableFilter<"Event"> | string | null
    eligibility?: StringNullableFilter<"Event"> | string | null
    rewards?: StringNullableFilter<"Event"> | string | null
    prizes?: JsonNullableFilter<"Event">
    venue?: StringNullableFilter<"Event"> | string | null
    meetingLink?: StringNullableFilter<"Event"> | string | null
    resourceLinks?: JsonNullableFilter<"Event">
    bannerImage?: StringNullableFilter<"Event"> | string | null
    images?: JsonNullableFilter<"Event">
    status?: StringFilter<"Event"> | string
    isFeatured?: BoolFilter<"Event"> | boolean
    hasRoadmap?: BoolFilter<"Event"> | boolean
    roadmapId?: StringNullableFilter<"Event"> | string | null
    hasChallenges?: BoolFilter<"Event"> | boolean
    problemCount?: IntFilter<"Event"> | number
    createdBy?: StringNullableFilter<"Event"> | string | null
    createdAt?: DateTimeFilter<"Event"> | Date | string
    updatedAt?: DateTimeFilter<"Event"> | Date | string
  }

  export type ChallengeUpsertWithWhereUniqueWithoutCreatorInput = {
    where: ChallengeWhereUniqueInput
    update: XOR<ChallengeUpdateWithoutCreatorInput, ChallengeUncheckedUpdateWithoutCreatorInput>
    create: XOR<ChallengeCreateWithoutCreatorInput, ChallengeUncheckedCreateWithoutCreatorInput>
  }

  export type ChallengeUpdateWithWhereUniqueWithoutCreatorInput = {
    where: ChallengeWhereUniqueInput
    data: XOR<ChallengeUpdateWithoutCreatorInput, ChallengeUncheckedUpdateWithoutCreatorInput>
  }

  export type ChallengeUpdateManyWithWhereWithoutCreatorInput = {
    where: ChallengeScalarWhereInput
    data: XOR<ChallengeUpdateManyMutationInput, ChallengeUncheckedUpdateManyWithoutCreatorInput>
  }

  export type ChallengeScalarWhereInput = {
    AND?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
    OR?: ChallengeScalarWhereInput[]
    NOT?: ChallengeScalarWhereInput | ChallengeScalarWhereInput[]
    id?: StringFilter<"Challenge"> | string
    title?: StringFilter<"Challenge"> | string
    slug?: StringFilter<"Challenge"> | string
    description?: StringFilter<"Challenge"> | string
    challengeType?: StringFilter<"Challenge"> | string
    difficulty?: StringFilter<"Challenge"> | string
    durationDays?: IntFilter<"Challenge"> | number
    startDate?: DateTimeFilter<"Challenge"> | Date | string
    endDate?: DateTimeFilter<"Challenge"> | Date | string
    category?: StringNullableFilter<"Challenge"> | string | null
    tags?: JsonNullableFilter<"Challenge">
    pointsPerDay?: IntFilter<"Challenge"> | number
    bonusPoints?: JsonNullableFilter<"Challenge">
    badges?: JsonNullableFilter<"Challenge">
    hasLeaderboard?: BoolFilter<"Challenge"> | boolean
    isPublic?: BoolFilter<"Challenge"> | boolean
    maxParticipants?: IntNullableFilter<"Challenge"> | number | null
    bannerImage?: StringNullableFilter<"Challenge"> | string | null
    icon?: StringNullableFilter<"Challenge"> | string | null
    status?: StringFilter<"Challenge"> | string
    totalParticipants?: IntFilter<"Challenge"> | number
    activeParticipants?: IntFilter<"Challenge"> | number
    completionRate?: DecimalNullableFilter<"Challenge"> | Decimal | DecimalJsLike | number | string | null
    createdBy?: StringNullableFilter<"Challenge"> | string | null
    createdAt?: DateTimeFilter<"Challenge"> | Date | string
    updatedAt?: DateTimeFilter<"Challenge"> | Date | string
  }

  export type CertificateUpsertWithWhereUniqueWithoutUserInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutUserInput, CertificateUncheckedUpdateWithoutUserInput>
    create: XOR<CertificateCreateWithoutUserInput, CertificateUncheckedCreateWithoutUserInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutUserInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutUserInput, CertificateUncheckedUpdateWithoutUserInput>
  }

  export type CertificateUpdateManyWithWhereWithoutUserInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutUserInput>
  }

  export type CertificateScalarWhereInput = {
    AND?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    OR?: CertificateScalarWhereInput[]
    NOT?: CertificateScalarWhereInput | CertificateScalarWhereInput[]
    id?: StringFilter<"Certificate"> | string
    certificateId?: StringFilter<"Certificate"> | string
    eventId?: StringFilter<"Certificate"> | string
    userId?: StringFilter<"Certificate"> | string
    teamId?: StringNullableFilter<"Certificate"> | string | null
    participantName?: StringFilter<"Certificate"> | string
    position?: StringNullableFilter<"Certificate"> | string | null
    issuedAt?: DateTimeFilter<"Certificate"> | Date | string
  }

  export type EmailLogUpsertWithWhereUniqueWithoutSenderInput = {
    where: EmailLogWhereUniqueInput
    update: XOR<EmailLogUpdateWithoutSenderInput, EmailLogUncheckedUpdateWithoutSenderInput>
    create: XOR<EmailLogCreateWithoutSenderInput, EmailLogUncheckedCreateWithoutSenderInput>
  }

  export type EmailLogUpdateWithWhereUniqueWithoutSenderInput = {
    where: EmailLogWhereUniqueInput
    data: XOR<EmailLogUpdateWithoutSenderInput, EmailLogUncheckedUpdateWithoutSenderInput>
  }

  export type EmailLogUpdateManyWithWhereWithoutSenderInput = {
    where: EmailLogScalarWhereInput
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyWithoutSenderInput>
  }

  export type EmailLogScalarWhereInput = {
    AND?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
    OR?: EmailLogScalarWhereInput[]
    NOT?: EmailLogScalarWhereInput | EmailLogScalarWhereInput[]
    id?: StringFilter<"EmailLog"> | string
    eventId?: StringFilter<"EmailLog"> | string
    subject?: StringFilter<"EmailLog"> | string
    message?: StringFilter<"EmailLog"> | string
    recipientCount?: IntFilter<"EmailLog"> | number
    sentBy?: StringFilter<"EmailLog"> | string
    sentAt?: DateTimeFilter<"EmailLog"> | Date | string
  }

  export type EventCategoryCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    parent?: EventCategoryCreateNestedOneWithoutChildrenInput
    events?: EventCreateNestedManyWithoutCategoryInput
    eventTypes?: EventTypeCreateNestedManyWithoutCategoryInput
  }

  export type EventCategoryUncheckedCreateWithoutChildrenInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutCategoryInput
    eventTypes?: EventTypeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type EventCategoryCreateOrConnectWithoutChildrenInput = {
    where: EventCategoryWhereUniqueInput
    create: XOR<EventCategoryCreateWithoutChildrenInput, EventCategoryUncheckedCreateWithoutChildrenInput>
  }

  export type EventCategoryCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    children?: EventCategoryCreateNestedManyWithoutParentInput
    events?: EventCreateNestedManyWithoutCategoryInput
    eventTypes?: EventTypeCreateNestedManyWithoutCategoryInput
  }

  export type EventCategoryUncheckedCreateWithoutParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    children?: EventCategoryUncheckedCreateNestedManyWithoutParentInput
    events?: EventUncheckedCreateNestedManyWithoutCategoryInput
    eventTypes?: EventTypeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type EventCategoryCreateOrConnectWithoutParentInput = {
    where: EventCategoryWhereUniqueInput
    create: XOR<EventCategoryCreateWithoutParentInput, EventCategoryUncheckedCreateWithoutParentInput>
  }

  export type EventCategoryCreateManyParentInputEnvelope = {
    data: EventCategoryCreateManyParentInput | EventCategoryCreateManyParentInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    description: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    hasChallenges?: boolean
    problemCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutEventsCreatedInput
    roadmap?: RoadmapCreateNestedOneWithoutEventsInput
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
    teams?: TeamCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogCreateNestedManyWithoutEventInput
    certificates?: CertificateCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutCategoryInput = {
    id?: string
    title: string
    slug: string
    description: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: string | null
    hasChallenges?: boolean
    problemCount?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutEventInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCategoryInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput>
  }

  export type EventCreateManyCategoryInputEnvelope = {
    data: EventCreateManyCategoryInput | EventCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type EventTypeCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    defaultDurationHours?: number | null
    createdAt?: Date | string
  }

  export type EventTypeUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    defaultDurationHours?: number | null
    createdAt?: Date | string
  }

  export type EventTypeCreateOrConnectWithoutCategoryInput = {
    where: EventTypeWhereUniqueInput
    create: XOR<EventTypeCreateWithoutCategoryInput, EventTypeUncheckedCreateWithoutCategoryInput>
  }

  export type EventTypeCreateManyCategoryInputEnvelope = {
    data: EventTypeCreateManyCategoryInput | EventTypeCreateManyCategoryInput[]
    skipDuplicates?: boolean
  }

  export type EventCategoryUpsertWithoutChildrenInput = {
    update: XOR<EventCategoryUpdateWithoutChildrenInput, EventCategoryUncheckedUpdateWithoutChildrenInput>
    create: XOR<EventCategoryCreateWithoutChildrenInput, EventCategoryUncheckedCreateWithoutChildrenInput>
    where?: EventCategoryWhereInput
  }

  export type EventCategoryUpdateToOneWithWhereWithoutChildrenInput = {
    where?: EventCategoryWhereInput
    data: XOR<EventCategoryUpdateWithoutChildrenInput, EventCategoryUncheckedUpdateWithoutChildrenInput>
  }

  export type EventCategoryUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: EventCategoryUpdateOneWithoutChildrenNestedInput
    events?: EventUpdateManyWithoutCategoryNestedInput
    eventTypes?: EventTypeUpdateManyWithoutCategoryNestedInput
  }

  export type EventCategoryUncheckedUpdateWithoutChildrenInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutCategoryNestedInput
    eventTypes?: EventTypeUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type EventCategoryUpsertWithWhereUniqueWithoutParentInput = {
    where: EventCategoryWhereUniqueInput
    update: XOR<EventCategoryUpdateWithoutParentInput, EventCategoryUncheckedUpdateWithoutParentInput>
    create: XOR<EventCategoryCreateWithoutParentInput, EventCategoryUncheckedCreateWithoutParentInput>
  }

  export type EventCategoryUpdateWithWhereUniqueWithoutParentInput = {
    where: EventCategoryWhereUniqueInput
    data: XOR<EventCategoryUpdateWithoutParentInput, EventCategoryUncheckedUpdateWithoutParentInput>
  }

  export type EventCategoryUpdateManyWithWhereWithoutParentInput = {
    where: EventCategoryScalarWhereInput
    data: XOR<EventCategoryUpdateManyMutationInput, EventCategoryUncheckedUpdateManyWithoutParentInput>
  }

  export type EventCategoryScalarWhereInput = {
    AND?: EventCategoryScalarWhereInput | EventCategoryScalarWhereInput[]
    OR?: EventCategoryScalarWhereInput[]
    NOT?: EventCategoryScalarWhereInput | EventCategoryScalarWhereInput[]
    id?: StringFilter<"EventCategory"> | string
    name?: StringFilter<"EventCategory"> | string
    slug?: StringFilter<"EventCategory"> | string
    description?: StringNullableFilter<"EventCategory"> | string | null
    icon?: StringNullableFilter<"EventCategory"> | string | null
    color?: StringNullableFilter<"EventCategory"> | string | null
    parentId?: StringNullableFilter<"EventCategory"> | string | null
    createdAt?: DateTimeFilter<"EventCategory"> | Date | string
  }

  export type EventUpsertWithWhereUniqueWithoutCategoryInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutCategoryInput, EventUncheckedUpdateWithoutCategoryInput>
    create: XOR<EventCreateWithoutCategoryInput, EventUncheckedCreateWithoutCategoryInput>
  }

  export type EventUpdateWithWhereUniqueWithoutCategoryInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutCategoryInput, EventUncheckedUpdateWithoutCategoryInput>
  }

  export type EventUpdateManyWithWhereWithoutCategoryInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutCategoryInput>
  }

  export type EventTypeUpsertWithWhereUniqueWithoutCategoryInput = {
    where: EventTypeWhereUniqueInput
    update: XOR<EventTypeUpdateWithoutCategoryInput, EventTypeUncheckedUpdateWithoutCategoryInput>
    create: XOR<EventTypeCreateWithoutCategoryInput, EventTypeUncheckedCreateWithoutCategoryInput>
  }

  export type EventTypeUpdateWithWhereUniqueWithoutCategoryInput = {
    where: EventTypeWhereUniqueInput
    data: XOR<EventTypeUpdateWithoutCategoryInput, EventTypeUncheckedUpdateWithoutCategoryInput>
  }

  export type EventTypeUpdateManyWithWhereWithoutCategoryInput = {
    where: EventTypeScalarWhereInput
    data: XOR<EventTypeUpdateManyMutationInput, EventTypeUncheckedUpdateManyWithoutCategoryInput>
  }

  export type EventTypeScalarWhereInput = {
    AND?: EventTypeScalarWhereInput | EventTypeScalarWhereInput[]
    OR?: EventTypeScalarWhereInput[]
    NOT?: EventTypeScalarWhereInput | EventTypeScalarWhereInput[]
    id?: StringFilter<"EventType"> | string
    categoryId?: StringFilter<"EventType"> | string
    name?: StringFilter<"EventType"> | string
    slug?: StringFilter<"EventType"> | string
    description?: StringNullableFilter<"EventType"> | string | null
    defaultDurationHours?: IntNullableFilter<"EventType"> | number | null
    createdAt?: DateTimeFilter<"EventType"> | Date | string
  }

  export type EventCategoryCreateWithoutEventTypesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    parent?: EventCategoryCreateNestedOneWithoutChildrenInput
    children?: EventCategoryCreateNestedManyWithoutParentInput
    events?: EventCreateNestedManyWithoutCategoryInput
  }

  export type EventCategoryUncheckedCreateWithoutEventTypesInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
    children?: EventCategoryUncheckedCreateNestedManyWithoutParentInput
    events?: EventUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type EventCategoryCreateOrConnectWithoutEventTypesInput = {
    where: EventCategoryWhereUniqueInput
    create: XOR<EventCategoryCreateWithoutEventTypesInput, EventCategoryUncheckedCreateWithoutEventTypesInput>
  }

  export type EventCategoryUpsertWithoutEventTypesInput = {
    update: XOR<EventCategoryUpdateWithoutEventTypesInput, EventCategoryUncheckedUpdateWithoutEventTypesInput>
    create: XOR<EventCategoryCreateWithoutEventTypesInput, EventCategoryUncheckedCreateWithoutEventTypesInput>
    where?: EventCategoryWhereInput
  }

  export type EventCategoryUpdateToOneWithWhereWithoutEventTypesInput = {
    where?: EventCategoryWhereInput
    data: XOR<EventCategoryUpdateWithoutEventTypesInput, EventCategoryUncheckedUpdateWithoutEventTypesInput>
  }

  export type EventCategoryUpdateWithoutEventTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: EventCategoryUpdateOneWithoutChildrenNestedInput
    children?: EventCategoryUpdateManyWithoutParentNestedInput
    events?: EventUpdateManyWithoutCategoryNestedInput
  }

  export type EventCategoryUncheckedUpdateWithoutEventTypesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: EventCategoryUncheckedUpdateManyWithoutParentNestedInput
    events?: EventUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type EventCategoryCreateWithoutEventsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
    parent?: EventCategoryCreateNestedOneWithoutChildrenInput
    children?: EventCategoryCreateNestedManyWithoutParentInput
    eventTypes?: EventTypeCreateNestedManyWithoutCategoryInput
  }

  export type EventCategoryUncheckedCreateWithoutEventsInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    parentId?: string | null
    createdAt?: Date | string
    children?: EventCategoryUncheckedCreateNestedManyWithoutParentInput
    eventTypes?: EventTypeUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type EventCategoryCreateOrConnectWithoutEventsInput = {
    where: EventCategoryWhereUniqueInput
    create: XOR<EventCategoryCreateWithoutEventsInput, EventCategoryUncheckedCreateWithoutEventsInput>
  }

  export type UserCreateWithoutEventsCreatedInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutEventsCreatedInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutEventsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
  }

  export type RoadmapCreateWithoutEventsInput = {
    id?: string
    title: string
    description: string
    roleTarget: string
    createdAt?: Date | string
    phases?: RoadmapPhaseCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateWithoutEventsInput = {
    id?: string
    title: string
    description: string
    roleTarget: string
    createdAt?: Date | string
    phases?: RoadmapPhaseUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapCreateOrConnectWithoutEventsInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutEventsInput, RoadmapUncheckedCreateWithoutEventsInput>
  }

  export type EventRegistrationCreateWithoutEventInput = {
    id?: string
    participationType?: string
    paymentStatus?: string
    paymentId?: string | null
    amountPaid?: Decimal | DecimalJsLike | number | string | null
    paidAt?: Date | string | null
    status?: string
    registeredAt?: Date | string
    cancelledAt?: Date | string | null
    user: UserCreateNestedOneWithoutEventRegistrationsInput
    team?: TeamCreateNestedOneWithoutRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    teamId?: string | null
    participationType?: string
    paymentStatus?: string
    paymentId?: string | null
    amountPaid?: Decimal | DecimalJsLike | number | string | null
    paidAt?: Date | string | null
    status?: string
    registeredAt?: Date | string
    cancelledAt?: Date | string | null
  }

  export type EventRegistrationCreateOrConnectWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    create: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput>
  }

  export type EventRegistrationCreateManyEventInputEnvelope = {
    data: EventRegistrationCreateManyEventInput | EventRegistrationCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type TeamCreateWithoutEventInput = {
    id?: string
    teamName: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    leader: UserCreateNestedOneWithoutTeamsLeadingInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionCreateNestedManyWithoutTeamInput
    certificates?: CertificateCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutEventInput = {
    id?: string
    teamName: string
    teamLeaderId: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutTeamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutEventInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput>
  }

  export type TeamCreateManyEventInputEnvelope = {
    data: TeamCreateManyEventInput | TeamCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventSubmissionCreateWithoutEventInput = {
    id?: string
    projectDeckUrl?: string | null
    presentationPdfUrl?: string | null
    mvpLink?: string | null
    demoVideoUrl?: string | null
    githubRepoUrl?: string | null
    technologiesUsed?: string | null
    aiToolsIntegrated?: string | null
    solutionDescription?: string | null
    score?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    feedback?: string | null
    status?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    evaluatedAt?: Date | string | null
    user: UserCreateNestedOneWithoutSubmissionsInput
    team?: TeamCreateNestedOneWithoutSubmissionsInput
  }

  export type EventSubmissionUncheckedCreateWithoutEventInput = {
    id?: string
    userId: string
    teamId?: string | null
    projectDeckUrl?: string | null
    presentationPdfUrl?: string | null
    mvpLink?: string | null
    demoVideoUrl?: string | null
    githubRepoUrl?: string | null
    technologiesUsed?: string | null
    aiToolsIntegrated?: string | null
    solutionDescription?: string | null
    score?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    feedback?: string | null
    status?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    evaluatedAt?: Date | string | null
  }

  export type EventSubmissionCreateOrConnectWithoutEventInput = {
    where: EventSubmissionWhereUniqueInput
    create: XOR<EventSubmissionCreateWithoutEventInput, EventSubmissionUncheckedCreateWithoutEventInput>
  }

  export type EventSubmissionCreateManyEventInputEnvelope = {
    data: EventSubmissionCreateManyEventInput | EventSubmissionCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventChallengeCreateWithoutEventInput = {
    challenge: ChallengeCreateNestedOneWithoutEventChallengesInput
  }

  export type EventChallengeUncheckedCreateWithoutEventInput = {
    challengeId: string
  }

  export type EventChallengeCreateOrConnectWithoutEventInput = {
    where: EventChallengeWhereUniqueInput
    create: XOR<EventChallengeCreateWithoutEventInput, EventChallengeUncheckedCreateWithoutEventInput>
  }

  export type EventChallengeCreateManyEventInputEnvelope = {
    data: EventChallengeCreateManyEventInput | EventChallengeCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EmailLogCreateWithoutEventInput = {
    id?: string
    subject: string
    message: string
    recipientCount: number
    sentAt?: Date | string
    sender: UserCreateNestedOneWithoutEmailsSentInput
  }

  export type EmailLogUncheckedCreateWithoutEventInput = {
    id?: string
    subject: string
    message: string
    recipientCount: number
    sentBy: string
    sentAt?: Date | string
  }

  export type EmailLogCreateOrConnectWithoutEventInput = {
    where: EmailLogWhereUniqueInput
    create: XOR<EmailLogCreateWithoutEventInput, EmailLogUncheckedCreateWithoutEventInput>
  }

  export type EmailLogCreateManyEventInputEnvelope = {
    data: EmailLogCreateManyEventInput | EmailLogCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutEventInput = {
    id?: string
    certificateId: string
    participantName: string
    position?: string | null
    issuedAt?: Date | string
    user: UserCreateNestedOneWithoutCertificatesInput
    team?: TeamCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutEventInput = {
    id?: string
    certificateId: string
    userId: string
    teamId?: string | null
    participantName: string
    position?: string | null
    issuedAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutEventInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutEventInput, CertificateUncheckedCreateWithoutEventInput>
  }

  export type CertificateCreateManyEventInputEnvelope = {
    data: CertificateCreateManyEventInput | CertificateCreateManyEventInput[]
    skipDuplicates?: boolean
  }

  export type EventCategoryUpsertWithoutEventsInput = {
    update: XOR<EventCategoryUpdateWithoutEventsInput, EventCategoryUncheckedUpdateWithoutEventsInput>
    create: XOR<EventCategoryCreateWithoutEventsInput, EventCategoryUncheckedCreateWithoutEventsInput>
    where?: EventCategoryWhereInput
  }

  export type EventCategoryUpdateToOneWithWhereWithoutEventsInput = {
    where?: EventCategoryWhereInput
    data: XOR<EventCategoryUpdateWithoutEventsInput, EventCategoryUncheckedUpdateWithoutEventsInput>
  }

  export type EventCategoryUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    parent?: EventCategoryUpdateOneWithoutChildrenNestedInput
    children?: EventCategoryUpdateManyWithoutParentNestedInput
    eventTypes?: EventTypeUpdateManyWithoutCategoryNestedInput
  }

  export type EventCategoryUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    parentId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: EventCategoryUncheckedUpdateManyWithoutParentNestedInput
    eventTypes?: EventTypeUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type UserUpsertWithoutEventsCreatedInput = {
    update: XOR<UserUpdateWithoutEventsCreatedInput, UserUncheckedUpdateWithoutEventsCreatedInput>
    create: XOR<UserCreateWithoutEventsCreatedInput, UserUncheckedCreateWithoutEventsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventsCreatedInput, UserUncheckedUpdateWithoutEventsCreatedInput>
  }

  export type UserUpdateWithoutEventsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutEventsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type RoadmapUpsertWithoutEventsInput = {
    update: XOR<RoadmapUpdateWithoutEventsInput, RoadmapUncheckedUpdateWithoutEventsInput>
    create: XOR<RoadmapCreateWithoutEventsInput, RoadmapUncheckedCreateWithoutEventsInput>
    where?: RoadmapWhereInput
  }

  export type RoadmapUpdateToOneWithWhereWithoutEventsInput = {
    where?: RoadmapWhereInput
    data: XOR<RoadmapUpdateWithoutEventsInput, RoadmapUncheckedUpdateWithoutEventsInput>
  }

  export type RoadmapUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    roleTarget?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: RoadmapPhaseUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutEventsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    roleTarget?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    phases?: RoadmapPhaseUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type EventRegistrationUpsertWithWhereUniqueWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    update: XOR<EventRegistrationUpdateWithoutEventInput, EventRegistrationUncheckedUpdateWithoutEventInput>
    create: XOR<EventRegistrationCreateWithoutEventInput, EventRegistrationUncheckedCreateWithoutEventInput>
  }

  export type EventRegistrationUpdateWithWhereUniqueWithoutEventInput = {
    where: EventRegistrationWhereUniqueInput
    data: XOR<EventRegistrationUpdateWithoutEventInput, EventRegistrationUncheckedUpdateWithoutEventInput>
  }

  export type EventRegistrationUpdateManyWithWhereWithoutEventInput = {
    where: EventRegistrationScalarWhereInput
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyWithoutEventInput>
  }

  export type TeamUpsertWithWhereUniqueWithoutEventInput = {
    where: TeamWhereUniqueInput
    update: XOR<TeamUpdateWithoutEventInput, TeamUncheckedUpdateWithoutEventInput>
    create: XOR<TeamCreateWithoutEventInput, TeamUncheckedCreateWithoutEventInput>
  }

  export type TeamUpdateWithWhereUniqueWithoutEventInput = {
    where: TeamWhereUniqueInput
    data: XOR<TeamUpdateWithoutEventInput, TeamUncheckedUpdateWithoutEventInput>
  }

  export type TeamUpdateManyWithWhereWithoutEventInput = {
    where: TeamScalarWhereInput
    data: XOR<TeamUpdateManyMutationInput, TeamUncheckedUpdateManyWithoutEventInput>
  }

  export type EventSubmissionUpsertWithWhereUniqueWithoutEventInput = {
    where: EventSubmissionWhereUniqueInput
    update: XOR<EventSubmissionUpdateWithoutEventInput, EventSubmissionUncheckedUpdateWithoutEventInput>
    create: XOR<EventSubmissionCreateWithoutEventInput, EventSubmissionUncheckedCreateWithoutEventInput>
  }

  export type EventSubmissionUpdateWithWhereUniqueWithoutEventInput = {
    where: EventSubmissionWhereUniqueInput
    data: XOR<EventSubmissionUpdateWithoutEventInput, EventSubmissionUncheckedUpdateWithoutEventInput>
  }

  export type EventSubmissionUpdateManyWithWhereWithoutEventInput = {
    where: EventSubmissionScalarWhereInput
    data: XOR<EventSubmissionUpdateManyMutationInput, EventSubmissionUncheckedUpdateManyWithoutEventInput>
  }

  export type EventChallengeUpsertWithWhereUniqueWithoutEventInput = {
    where: EventChallengeWhereUniqueInput
    update: XOR<EventChallengeUpdateWithoutEventInput, EventChallengeUncheckedUpdateWithoutEventInput>
    create: XOR<EventChallengeCreateWithoutEventInput, EventChallengeUncheckedCreateWithoutEventInput>
  }

  export type EventChallengeUpdateWithWhereUniqueWithoutEventInput = {
    where: EventChallengeWhereUniqueInput
    data: XOR<EventChallengeUpdateWithoutEventInput, EventChallengeUncheckedUpdateWithoutEventInput>
  }

  export type EventChallengeUpdateManyWithWhereWithoutEventInput = {
    where: EventChallengeScalarWhereInput
    data: XOR<EventChallengeUpdateManyMutationInput, EventChallengeUncheckedUpdateManyWithoutEventInput>
  }

  export type EventChallengeScalarWhereInput = {
    AND?: EventChallengeScalarWhereInput | EventChallengeScalarWhereInput[]
    OR?: EventChallengeScalarWhereInput[]
    NOT?: EventChallengeScalarWhereInput | EventChallengeScalarWhereInput[]
    eventId?: StringFilter<"EventChallenge"> | string
    challengeId?: StringFilter<"EventChallenge"> | string
  }

  export type EmailLogUpsertWithWhereUniqueWithoutEventInput = {
    where: EmailLogWhereUniqueInput
    update: XOR<EmailLogUpdateWithoutEventInput, EmailLogUncheckedUpdateWithoutEventInput>
    create: XOR<EmailLogCreateWithoutEventInput, EmailLogUncheckedCreateWithoutEventInput>
  }

  export type EmailLogUpdateWithWhereUniqueWithoutEventInput = {
    where: EmailLogWhereUniqueInput
    data: XOR<EmailLogUpdateWithoutEventInput, EmailLogUncheckedUpdateWithoutEventInput>
  }

  export type EmailLogUpdateManyWithWhereWithoutEventInput = {
    where: EmailLogScalarWhereInput
    data: XOR<EmailLogUpdateManyMutationInput, EmailLogUncheckedUpdateManyWithoutEventInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutEventInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutEventInput, CertificateUncheckedUpdateWithoutEventInput>
    create: XOR<CertificateCreateWithoutEventInput, CertificateUncheckedCreateWithoutEventInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutEventInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutEventInput, CertificateUncheckedUpdateWithoutEventInput>
  }

  export type CertificateUpdateManyWithWhereWithoutEventInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutEventInput>
  }

  export type EventCreateWithoutTeamsInput = {
    id?: string
    title: string
    slug: string
    description: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    hasChallenges?: boolean
    problemCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: EventCategoryCreateNestedOneWithoutEventsInput
    creator?: UserCreateNestedOneWithoutEventsCreatedInput
    roadmap?: RoadmapCreateNestedOneWithoutEventsInput
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogCreateNestedManyWithoutEventInput
    certificates?: CertificateCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutTeamsInput = {
    id?: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: string | null
    hasChallenges?: boolean
    problemCount?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutEventInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutTeamsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutTeamsInput, EventUncheckedCreateWithoutTeamsInput>
  }

  export type UserCreateWithoutTeamsLeadingInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutTeamsLeadingInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutTeamsLeadingInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamsLeadingInput, UserUncheckedCreateWithoutTeamsLeadingInput>
  }

  export type TeamMemberCreateWithoutTeamInput = {
    id?: string
    isLeader?: boolean
    status?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
    user: UserCreateNestedOneWithoutTeamMembershipsInput
  }

  export type TeamMemberUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    isLeader?: boolean
    status?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TeamMemberCreateOrConnectWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberCreateManyTeamInputEnvelope = {
    data: TeamMemberCreateManyTeamInput | TeamMemberCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type TeamJoinRequestCreateWithoutTeamInput = {
    id?: string
    requestType: string
    status?: string
    message?: string | null
    responseMessage?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
    user: UserCreateNestedOneWithoutTeamJoinRequestsInput
  }

  export type TeamJoinRequestUncheckedCreateWithoutTeamInput = {
    id?: string
    userId: string
    requestType: string
    status?: string
    message?: string | null
    responseMessage?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type TeamJoinRequestCreateOrConnectWithoutTeamInput = {
    where: TeamJoinRequestWhereUniqueInput
    create: XOR<TeamJoinRequestCreateWithoutTeamInput, TeamJoinRequestUncheckedCreateWithoutTeamInput>
  }

  export type TeamJoinRequestCreateManyTeamInputEnvelope = {
    data: TeamJoinRequestCreateManyTeamInput | TeamJoinRequestCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type EventRegistrationCreateWithoutTeamInput = {
    id?: string
    participationType?: string
    paymentStatus?: string
    paymentId?: string | null
    amountPaid?: Decimal | DecimalJsLike | number | string | null
    paidAt?: Date | string | null
    status?: string
    registeredAt?: Date | string
    cancelledAt?: Date | string | null
    event: EventCreateNestedOneWithoutRegistrationsInput
    user: UserCreateNestedOneWithoutEventRegistrationsInput
  }

  export type EventRegistrationUncheckedCreateWithoutTeamInput = {
    id?: string
    eventId: string
    userId: string
    participationType?: string
    paymentStatus?: string
    paymentId?: string | null
    amountPaid?: Decimal | DecimalJsLike | number | string | null
    paidAt?: Date | string | null
    status?: string
    registeredAt?: Date | string
    cancelledAt?: Date | string | null
  }

  export type EventRegistrationCreateOrConnectWithoutTeamInput = {
    where: EventRegistrationWhereUniqueInput
    create: XOR<EventRegistrationCreateWithoutTeamInput, EventRegistrationUncheckedCreateWithoutTeamInput>
  }

  export type EventRegistrationCreateManyTeamInputEnvelope = {
    data: EventRegistrationCreateManyTeamInput | EventRegistrationCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type EventSubmissionCreateWithoutTeamInput = {
    id?: string
    projectDeckUrl?: string | null
    presentationPdfUrl?: string | null
    mvpLink?: string | null
    demoVideoUrl?: string | null
    githubRepoUrl?: string | null
    technologiesUsed?: string | null
    aiToolsIntegrated?: string | null
    solutionDescription?: string | null
    score?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    feedback?: string | null
    status?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    evaluatedAt?: Date | string | null
    event: EventCreateNestedOneWithoutSubmissionsInput
    user: UserCreateNestedOneWithoutSubmissionsInput
  }

  export type EventSubmissionUncheckedCreateWithoutTeamInput = {
    id?: string
    eventId: string
    userId: string
    projectDeckUrl?: string | null
    presentationPdfUrl?: string | null
    mvpLink?: string | null
    demoVideoUrl?: string | null
    githubRepoUrl?: string | null
    technologiesUsed?: string | null
    aiToolsIntegrated?: string | null
    solutionDescription?: string | null
    score?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    feedback?: string | null
    status?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    evaluatedAt?: Date | string | null
  }

  export type EventSubmissionCreateOrConnectWithoutTeamInput = {
    where: EventSubmissionWhereUniqueInput
    create: XOR<EventSubmissionCreateWithoutTeamInput, EventSubmissionUncheckedCreateWithoutTeamInput>
  }

  export type EventSubmissionCreateManyTeamInputEnvelope = {
    data: EventSubmissionCreateManyTeamInput | EventSubmissionCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type CertificateCreateWithoutTeamInput = {
    id?: string
    certificateId: string
    participantName: string
    position?: string | null
    issuedAt?: Date | string
    event: EventCreateNestedOneWithoutCertificatesInput
    user: UserCreateNestedOneWithoutCertificatesInput
  }

  export type CertificateUncheckedCreateWithoutTeamInput = {
    id?: string
    certificateId: string
    eventId: string
    userId: string
    participantName: string
    position?: string | null
    issuedAt?: Date | string
  }

  export type CertificateCreateOrConnectWithoutTeamInput = {
    where: CertificateWhereUniqueInput
    create: XOR<CertificateCreateWithoutTeamInput, CertificateUncheckedCreateWithoutTeamInput>
  }

  export type CertificateCreateManyTeamInputEnvelope = {
    data: CertificateCreateManyTeamInput | CertificateCreateManyTeamInput[]
    skipDuplicates?: boolean
  }

  export type EventUpsertWithoutTeamsInput = {
    update: XOR<EventUpdateWithoutTeamsInput, EventUncheckedUpdateWithoutTeamsInput>
    create: XOR<EventCreateWithoutTeamsInput, EventUncheckedCreateWithoutTeamsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutTeamsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutTeamsInput, EventUncheckedUpdateWithoutTeamsInput>
  }

  export type EventUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EventCategoryUpdateOneRequiredWithoutEventsNestedInput
    creator?: UserUpdateOneWithoutEventsCreatedNestedInput
    roadmap?: RoadmapUpdateOneWithoutEventsNestedInput
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUpdateManyWithoutEventNestedInput
    certificates?: CertificateUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutTeamsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutEventNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UserUpsertWithoutTeamsLeadingInput = {
    update: XOR<UserUpdateWithoutTeamsLeadingInput, UserUncheckedUpdateWithoutTeamsLeadingInput>
    create: XOR<UserCreateWithoutTeamsLeadingInput, UserUncheckedCreateWithoutTeamsLeadingInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamsLeadingInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamsLeadingInput, UserUncheckedUpdateWithoutTeamsLeadingInput>
  }

  export type UserUpdateWithoutTeamsLeadingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamsLeadingInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type TeamMemberUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    update: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamMemberCreateWithoutTeamInput, TeamMemberUncheckedCreateWithoutTeamInput>
  }

  export type TeamMemberUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamMemberWhereUniqueInput
    data: XOR<TeamMemberUpdateWithoutTeamInput, TeamMemberUncheckedUpdateWithoutTeamInput>
  }

  export type TeamMemberUpdateManyWithWhereWithoutTeamInput = {
    where: TeamMemberScalarWhereInput
    data: XOR<TeamMemberUpdateManyMutationInput, TeamMemberUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamJoinRequestUpsertWithWhereUniqueWithoutTeamInput = {
    where: TeamJoinRequestWhereUniqueInput
    update: XOR<TeamJoinRequestUpdateWithoutTeamInput, TeamJoinRequestUncheckedUpdateWithoutTeamInput>
    create: XOR<TeamJoinRequestCreateWithoutTeamInput, TeamJoinRequestUncheckedCreateWithoutTeamInput>
  }

  export type TeamJoinRequestUpdateWithWhereUniqueWithoutTeamInput = {
    where: TeamJoinRequestWhereUniqueInput
    data: XOR<TeamJoinRequestUpdateWithoutTeamInput, TeamJoinRequestUncheckedUpdateWithoutTeamInput>
  }

  export type TeamJoinRequestUpdateManyWithWhereWithoutTeamInput = {
    where: TeamJoinRequestScalarWhereInput
    data: XOR<TeamJoinRequestUpdateManyMutationInput, TeamJoinRequestUncheckedUpdateManyWithoutTeamInput>
  }

  export type EventRegistrationUpsertWithWhereUniqueWithoutTeamInput = {
    where: EventRegistrationWhereUniqueInput
    update: XOR<EventRegistrationUpdateWithoutTeamInput, EventRegistrationUncheckedUpdateWithoutTeamInput>
    create: XOR<EventRegistrationCreateWithoutTeamInput, EventRegistrationUncheckedCreateWithoutTeamInput>
  }

  export type EventRegistrationUpdateWithWhereUniqueWithoutTeamInput = {
    where: EventRegistrationWhereUniqueInput
    data: XOR<EventRegistrationUpdateWithoutTeamInput, EventRegistrationUncheckedUpdateWithoutTeamInput>
  }

  export type EventRegistrationUpdateManyWithWhereWithoutTeamInput = {
    where: EventRegistrationScalarWhereInput
    data: XOR<EventRegistrationUpdateManyMutationInput, EventRegistrationUncheckedUpdateManyWithoutTeamInput>
  }

  export type EventSubmissionUpsertWithWhereUniqueWithoutTeamInput = {
    where: EventSubmissionWhereUniqueInput
    update: XOR<EventSubmissionUpdateWithoutTeamInput, EventSubmissionUncheckedUpdateWithoutTeamInput>
    create: XOR<EventSubmissionCreateWithoutTeamInput, EventSubmissionUncheckedCreateWithoutTeamInput>
  }

  export type EventSubmissionUpdateWithWhereUniqueWithoutTeamInput = {
    where: EventSubmissionWhereUniqueInput
    data: XOR<EventSubmissionUpdateWithoutTeamInput, EventSubmissionUncheckedUpdateWithoutTeamInput>
  }

  export type EventSubmissionUpdateManyWithWhereWithoutTeamInput = {
    where: EventSubmissionScalarWhereInput
    data: XOR<EventSubmissionUpdateManyMutationInput, EventSubmissionUncheckedUpdateManyWithoutTeamInput>
  }

  export type CertificateUpsertWithWhereUniqueWithoutTeamInput = {
    where: CertificateWhereUniqueInput
    update: XOR<CertificateUpdateWithoutTeamInput, CertificateUncheckedUpdateWithoutTeamInput>
    create: XOR<CertificateCreateWithoutTeamInput, CertificateUncheckedCreateWithoutTeamInput>
  }

  export type CertificateUpdateWithWhereUniqueWithoutTeamInput = {
    where: CertificateWhereUniqueInput
    data: XOR<CertificateUpdateWithoutTeamInput, CertificateUncheckedUpdateWithoutTeamInput>
  }

  export type CertificateUpdateManyWithWhereWithoutTeamInput = {
    where: CertificateScalarWhereInput
    data: XOR<CertificateUpdateManyMutationInput, CertificateUncheckedUpdateManyWithoutTeamInput>
  }

  export type TeamCreateWithoutMembersInput = {
    id?: string
    teamName: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutTeamsInput
    leader: UserCreateNestedOneWithoutTeamsLeadingInput
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionCreateNestedManyWithoutTeamInput
    certificates?: CertificateCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutMembersInput = {
    id?: string
    eventId: string
    teamName: string
    teamLeaderId: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutTeamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutMembersInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
  }

  export type UserCreateWithoutTeamMembershipsInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutTeamMembershipsInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutTeamMembershipsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
  }

  export type TeamUpsertWithoutMembersInput = {
    update: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
    create: XOR<TeamCreateWithoutMembersInput, TeamUncheckedCreateWithoutMembersInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutMembersInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutMembersInput, TeamUncheckedUpdateWithoutMembersInput>
  }

  export type TeamUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput
    leader?: UserUpdateOneRequiredWithoutTeamsLeadingNestedInput
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutMembersInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamLeaderId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUncheckedUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamMembershipsInput = {
    update: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
    create: XOR<UserCreateWithoutTeamMembershipsInput, UserUncheckedCreateWithoutTeamMembershipsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamMembershipsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamMembershipsInput, UserUncheckedUpdateWithoutTeamMembershipsInput>
  }

  export type UserUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamMembershipsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type TeamCreateWithoutJoinRequestsInput = {
    id?: string
    teamName: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutTeamsInput
    leader: UserCreateNestedOneWithoutTeamsLeadingInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionCreateNestedManyWithoutTeamInput
    certificates?: CertificateCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutJoinRequestsInput = {
    id?: string
    eventId: string
    teamName: string
    teamLeaderId: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutTeamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutJoinRequestsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutJoinRequestsInput, TeamUncheckedCreateWithoutJoinRequestsInput>
  }

  export type UserCreateWithoutTeamJoinRequestsInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutTeamJoinRequestsInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutTeamJoinRequestsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTeamJoinRequestsInput, UserUncheckedCreateWithoutTeamJoinRequestsInput>
  }

  export type TeamUpsertWithoutJoinRequestsInput = {
    update: XOR<TeamUpdateWithoutJoinRequestsInput, TeamUncheckedUpdateWithoutJoinRequestsInput>
    create: XOR<TeamCreateWithoutJoinRequestsInput, TeamUncheckedCreateWithoutJoinRequestsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutJoinRequestsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutJoinRequestsInput, TeamUncheckedUpdateWithoutJoinRequestsInput>
  }

  export type TeamUpdateWithoutJoinRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput
    leader?: UserUpdateOneRequiredWithoutTeamsLeadingNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutJoinRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamLeaderId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUncheckedUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserUpsertWithoutTeamJoinRequestsInput = {
    update: XOR<UserUpdateWithoutTeamJoinRequestsInput, UserUncheckedUpdateWithoutTeamJoinRequestsInput>
    create: XOR<UserCreateWithoutTeamJoinRequestsInput, UserUncheckedCreateWithoutTeamJoinRequestsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTeamJoinRequestsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTeamJoinRequestsInput, UserUncheckedUpdateWithoutTeamJoinRequestsInput>
  }

  export type UserUpdateWithoutTeamJoinRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutTeamJoinRequestsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type EventCreateWithoutRegistrationsInput = {
    id?: string
    title: string
    slug: string
    description: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    hasChallenges?: boolean
    problemCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: EventCategoryCreateNestedOneWithoutEventsInput
    creator?: UserCreateNestedOneWithoutEventsCreatedInput
    roadmap?: RoadmapCreateNestedOneWithoutEventsInput
    teams?: TeamCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogCreateNestedManyWithoutEventInput
    certificates?: CertificateCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutRegistrationsInput = {
    id?: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: string | null
    hasChallenges?: boolean
    problemCount?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutEventInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutRegistrationsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
  }

  export type UserCreateWithoutEventRegistrationsInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutEventRegistrationsInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutEventRegistrationsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEventRegistrationsInput, UserUncheckedCreateWithoutEventRegistrationsInput>
  }

  export type TeamCreateWithoutRegistrationsInput = {
    id?: string
    teamName: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutTeamsInput
    leader: UserCreateNestedOneWithoutTeamsLeadingInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionCreateNestedManyWithoutTeamInput
    certificates?: CertificateCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutRegistrationsInput = {
    id?: string
    eventId: string
    teamName: string
    teamLeaderId: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutTeamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutRegistrationsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutRegistrationsInput, TeamUncheckedCreateWithoutRegistrationsInput>
  }

  export type EventUpsertWithoutRegistrationsInput = {
    update: XOR<EventUpdateWithoutRegistrationsInput, EventUncheckedUpdateWithoutRegistrationsInput>
    create: XOR<EventCreateWithoutRegistrationsInput, EventUncheckedCreateWithoutRegistrationsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutRegistrationsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutRegistrationsInput, EventUncheckedUpdateWithoutRegistrationsInput>
  }

  export type EventUpdateWithoutRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EventCategoryUpdateOneRequiredWithoutEventsNestedInput
    creator?: UserUpdateOneWithoutEventsCreatedNestedInput
    roadmap?: RoadmapUpdateOneWithoutEventsNestedInput
    teams?: TeamUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUpdateManyWithoutEventNestedInput
    certificates?: CertificateUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutEventNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UserUpsertWithoutEventRegistrationsInput = {
    update: XOR<UserUpdateWithoutEventRegistrationsInput, UserUncheckedUpdateWithoutEventRegistrationsInput>
    create: XOR<UserCreateWithoutEventRegistrationsInput, UserUncheckedCreateWithoutEventRegistrationsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEventRegistrationsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEventRegistrationsInput, UserUncheckedUpdateWithoutEventRegistrationsInput>
  }

  export type UserUpdateWithoutEventRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutEventRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type TeamUpsertWithoutRegistrationsInput = {
    update: XOR<TeamUpdateWithoutRegistrationsInput, TeamUncheckedUpdateWithoutRegistrationsInput>
    create: XOR<TeamCreateWithoutRegistrationsInput, TeamUncheckedCreateWithoutRegistrationsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutRegistrationsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutRegistrationsInput, TeamUncheckedUpdateWithoutRegistrationsInput>
  }

  export type TeamUpdateWithoutRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput
    leader?: UserUpdateOneRequiredWithoutTeamsLeadingNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutRegistrationsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamLeaderId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type EventCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    slug: string
    description: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    hasChallenges?: boolean
    problemCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: EventCategoryCreateNestedOneWithoutEventsInput
    creator?: UserCreateNestedOneWithoutEventsCreatedInput
    roadmap?: RoadmapCreateNestedOneWithoutEventsInput
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
    teams?: TeamCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogCreateNestedManyWithoutEventInput
    certificates?: CertificateCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: string | null
    hasChallenges?: boolean
    problemCount?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutEventInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutSubmissionsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutSubmissionsInput, EventUncheckedCreateWithoutSubmissionsInput>
  }

  export type UserCreateWithoutSubmissionsInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutSubmissionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
  }

  export type TeamCreateWithoutSubmissionsInput = {
    id?: string
    teamName: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutTeamsInput
    leader: UserCreateNestedOneWithoutTeamsLeadingInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationCreateNestedManyWithoutTeamInput
    certificates?: CertificateCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutSubmissionsInput = {
    id?: string
    eventId: string
    teamName: string
    teamLeaderId: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutTeamInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutSubmissionsInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutSubmissionsInput, TeamUncheckedCreateWithoutSubmissionsInput>
  }

  export type EventUpsertWithoutSubmissionsInput = {
    update: XOR<EventUpdateWithoutSubmissionsInput, EventUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<EventCreateWithoutSubmissionsInput, EventUncheckedCreateWithoutSubmissionsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutSubmissionsInput, EventUncheckedUpdateWithoutSubmissionsInput>
  }

  export type EventUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EventCategoryUpdateOneRequiredWithoutEventsNestedInput
    creator?: UserUpdateOneWithoutEventsCreatedNestedInput
    roadmap?: RoadmapUpdateOneWithoutEventsNestedInput
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
    teams?: TeamUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUpdateManyWithoutEventNestedInput
    certificates?: CertificateUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutEventNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UserUpsertWithoutSubmissionsInput = {
    update: XOR<UserUpdateWithoutSubmissionsInput, UserUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<UserCreateWithoutSubmissionsInput, UserUncheckedCreateWithoutSubmissionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutSubmissionsInput, UserUncheckedUpdateWithoutSubmissionsInput>
  }

  export type UserUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type TeamUpsertWithoutSubmissionsInput = {
    update: XOR<TeamUpdateWithoutSubmissionsInput, TeamUncheckedUpdateWithoutSubmissionsInput>
    create: XOR<TeamCreateWithoutSubmissionsInput, TeamUncheckedCreateWithoutSubmissionsInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutSubmissionsInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutSubmissionsInput, TeamUncheckedUpdateWithoutSubmissionsInput>
  }

  export type TeamUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput
    leader?: UserUpdateOneRequiredWithoutTeamsLeadingNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutSubmissionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamLeaderId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUncheckedUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type UserCreateWithoutChallengesCreatedInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutChallengesCreatedInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutChallengesCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChallengesCreatedInput, UserUncheckedCreateWithoutChallengesCreatedInput>
  }

  export type ChallengeTaskCreateWithoutChallengeInput = {
    id?: string
    dayNumber: number
    title: string
    description?: string | null
    taskType: string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    points?: number
    autoValidate?: boolean
    validationUrl?: string | null
    createdAt?: Date | string
    completions?: UserTaskCompletionCreateNestedManyWithoutTaskInput
  }

  export type ChallengeTaskUncheckedCreateWithoutChallengeInput = {
    id?: string
    dayNumber: number
    title: string
    description?: string | null
    taskType: string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    points?: number
    autoValidate?: boolean
    validationUrl?: string | null
    createdAt?: Date | string
    completions?: UserTaskCompletionUncheckedCreateNestedManyWithoutTaskInput
  }

  export type ChallengeTaskCreateOrConnectWithoutChallengeInput = {
    where: ChallengeTaskWhereUniqueInput
    create: XOR<ChallengeTaskCreateWithoutChallengeInput, ChallengeTaskUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeTaskCreateManyChallengeInputEnvelope = {
    data: ChallengeTaskCreateManyChallengeInput | ChallengeTaskCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type UserChallengeProgressCreateWithoutChallengeInput = {
    id?: string
    status?: string
    completedDays?: number
    totalDays: number
    completionPercentage?: Decimal | DecimalJsLike | number | string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    totalPoints?: number
    bonusPoints?: number
    currentRank?: number | null
    startedAt?: Date | string
    lastActivity?: Date | string
    completedAt?: Date | string | null
    certificateIssued?: boolean
    certificateUrl?: string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutChallengeProgressInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutProgressInput
  }

  export type UserChallengeProgressUncheckedCreateWithoutChallengeInput = {
    id?: string
    userId: string
    status?: string
    completedDays?: number
    totalDays: number
    completionPercentage?: Decimal | DecimalJsLike | number | string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    totalPoints?: number
    bonusPoints?: number
    currentRank?: number | null
    startedAt?: Date | string
    lastActivity?: Date | string
    completedAt?: Date | string | null
    certificateIssued?: boolean
    certificateUrl?: string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutProgressInput
  }

  export type UserChallengeProgressCreateOrConnectWithoutChallengeInput = {
    where: UserChallengeProgressWhereUniqueInput
    create: XOR<UserChallengeProgressCreateWithoutChallengeInput, UserChallengeProgressUncheckedCreateWithoutChallengeInput>
  }

  export type UserChallengeProgressCreateManyChallengeInputEnvelope = {
    data: UserChallengeProgressCreateManyChallengeInput | UserChallengeProgressCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type EventChallengeCreateWithoutChallengeInput = {
    event: EventCreateNestedOneWithoutEventChallengesInput
  }

  export type EventChallengeUncheckedCreateWithoutChallengeInput = {
    eventId: string
  }

  export type EventChallengeCreateOrConnectWithoutChallengeInput = {
    where: EventChallengeWhereUniqueInput
    create: XOR<EventChallengeCreateWithoutChallengeInput, EventChallengeUncheckedCreateWithoutChallengeInput>
  }

  export type EventChallengeCreateManyChallengeInputEnvelope = {
    data: EventChallengeCreateManyChallengeInput | EventChallengeCreateManyChallengeInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutChallengesCreatedInput = {
    update: XOR<UserUpdateWithoutChallengesCreatedInput, UserUncheckedUpdateWithoutChallengesCreatedInput>
    create: XOR<UserCreateWithoutChallengesCreatedInput, UserUncheckedCreateWithoutChallengesCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChallengesCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChallengesCreatedInput, UserUncheckedUpdateWithoutChallengesCreatedInput>
  }

  export type UserUpdateWithoutChallengesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutChallengesCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type ChallengeTaskUpsertWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeTaskWhereUniqueInput
    update: XOR<ChallengeTaskUpdateWithoutChallengeInput, ChallengeTaskUncheckedUpdateWithoutChallengeInput>
    create: XOR<ChallengeTaskCreateWithoutChallengeInput, ChallengeTaskUncheckedCreateWithoutChallengeInput>
  }

  export type ChallengeTaskUpdateWithWhereUniqueWithoutChallengeInput = {
    where: ChallengeTaskWhereUniqueInput
    data: XOR<ChallengeTaskUpdateWithoutChallengeInput, ChallengeTaskUncheckedUpdateWithoutChallengeInput>
  }

  export type ChallengeTaskUpdateManyWithWhereWithoutChallengeInput = {
    where: ChallengeTaskScalarWhereInput
    data: XOR<ChallengeTaskUpdateManyMutationInput, ChallengeTaskUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeTaskScalarWhereInput = {
    AND?: ChallengeTaskScalarWhereInput | ChallengeTaskScalarWhereInput[]
    OR?: ChallengeTaskScalarWhereInput[]
    NOT?: ChallengeTaskScalarWhereInput | ChallengeTaskScalarWhereInput[]
    id?: StringFilter<"ChallengeTask"> | string
    challengeId?: StringFilter<"ChallengeTask"> | string
    dayNumber?: IntFilter<"ChallengeTask"> | number
    title?: StringFilter<"ChallengeTask"> | string
    description?: StringNullableFilter<"ChallengeTask"> | string | null
    taskType?: StringFilter<"ChallengeTask"> | string
    content?: JsonNullableFilter<"ChallengeTask">
    resourceLinks?: JsonNullableFilter<"ChallengeTask">
    hints?: JsonNullableFilter<"ChallengeTask">
    difficulty?: StringNullableFilter<"ChallengeTask"> | string | null
    points?: IntFilter<"ChallengeTask"> | number
    autoValidate?: BoolFilter<"ChallengeTask"> | boolean
    validationUrl?: StringNullableFilter<"ChallengeTask"> | string | null
    createdAt?: DateTimeFilter<"ChallengeTask"> | Date | string
  }

  export type UserChallengeProgressUpsertWithWhereUniqueWithoutChallengeInput = {
    where: UserChallengeProgressWhereUniqueInput
    update: XOR<UserChallengeProgressUpdateWithoutChallengeInput, UserChallengeProgressUncheckedUpdateWithoutChallengeInput>
    create: XOR<UserChallengeProgressCreateWithoutChallengeInput, UserChallengeProgressUncheckedCreateWithoutChallengeInput>
  }

  export type UserChallengeProgressUpdateWithWhereUniqueWithoutChallengeInput = {
    where: UserChallengeProgressWhereUniqueInput
    data: XOR<UserChallengeProgressUpdateWithoutChallengeInput, UserChallengeProgressUncheckedUpdateWithoutChallengeInput>
  }

  export type UserChallengeProgressUpdateManyWithWhereWithoutChallengeInput = {
    where: UserChallengeProgressScalarWhereInput
    data: XOR<UserChallengeProgressUpdateManyMutationInput, UserChallengeProgressUncheckedUpdateManyWithoutChallengeInput>
  }

  export type EventChallengeUpsertWithWhereUniqueWithoutChallengeInput = {
    where: EventChallengeWhereUniqueInput
    update: XOR<EventChallengeUpdateWithoutChallengeInput, EventChallengeUncheckedUpdateWithoutChallengeInput>
    create: XOR<EventChallengeCreateWithoutChallengeInput, EventChallengeUncheckedCreateWithoutChallengeInput>
  }

  export type EventChallengeUpdateWithWhereUniqueWithoutChallengeInput = {
    where: EventChallengeWhereUniqueInput
    data: XOR<EventChallengeUpdateWithoutChallengeInput, EventChallengeUncheckedUpdateWithoutChallengeInput>
  }

  export type EventChallengeUpdateManyWithWhereWithoutChallengeInput = {
    where: EventChallengeScalarWhereInput
    data: XOR<EventChallengeUpdateManyMutationInput, EventChallengeUncheckedUpdateManyWithoutChallengeInput>
  }

  export type ChallengeCreateWithoutTasksInput = {
    id?: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date | string
    endDate: Date | string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: number | null
    bannerImage?: string | null
    icon?: string | null
    status?: string
    totalParticipants?: number
    activeParticipants?: number
    completionRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutChallengesCreatedInput
    userProgress?: UserChallengeProgressCreateNestedManyWithoutChallengeInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutTasksInput = {
    id?: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date | string
    endDate: Date | string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: number | null
    bannerImage?: string | null
    icon?: string | null
    status?: string
    totalParticipants?: number
    activeParticipants?: number
    completionRate?: Decimal | DecimalJsLike | number | string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    userProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutChallengeInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutTasksInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutTasksInput, ChallengeUncheckedCreateWithoutTasksInput>
  }

  export type UserTaskCompletionCreateWithoutTaskInput = {
    id?: string
    challengeId: string
    completedAt?: Date | string
    timeTaken?: number | null
    submissionUrl?: string | null
    submissionText?: string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    score?: Decimal | DecimalJsLike | number | string | null
    pointsEarned?: number | null
    userNotes?: string | null
    feedback?: string | null
    user: UserCreateNestedOneWithoutTaskCompletionsInput
    progress: UserChallengeProgressCreateNestedOneWithoutTaskCompletionsInput
  }

  export type UserTaskCompletionUncheckedCreateWithoutTaskInput = {
    id?: string
    userId: string
    challengeId: string
    progressId: string
    completedAt?: Date | string
    timeTaken?: number | null
    submissionUrl?: string | null
    submissionText?: string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    score?: Decimal | DecimalJsLike | number | string | null
    pointsEarned?: number | null
    userNotes?: string | null
    feedback?: string | null
  }

  export type UserTaskCompletionCreateOrConnectWithoutTaskInput = {
    where: UserTaskCompletionWhereUniqueInput
    create: XOR<UserTaskCompletionCreateWithoutTaskInput, UserTaskCompletionUncheckedCreateWithoutTaskInput>
  }

  export type UserTaskCompletionCreateManyTaskInputEnvelope = {
    data: UserTaskCompletionCreateManyTaskInput | UserTaskCompletionCreateManyTaskInput[]
    skipDuplicates?: boolean
  }

  export type ChallengeUpsertWithoutTasksInput = {
    update: XOR<ChallengeUpdateWithoutTasksInput, ChallengeUncheckedUpdateWithoutTasksInput>
    create: XOR<ChallengeCreateWithoutTasksInput, ChallengeUncheckedCreateWithoutTasksInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutTasksInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutTasksInput, ChallengeUncheckedUpdateWithoutTasksInput>
  }

  export type ChallengeUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutChallengesCreatedNestedInput
    userProgress?: UserChallengeProgressUpdateManyWithoutChallengeNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutTasksInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    userProgress?: UserChallengeProgressUncheckedUpdateManyWithoutChallengeNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type UserTaskCompletionUpsertWithWhereUniqueWithoutTaskInput = {
    where: UserTaskCompletionWhereUniqueInput
    update: XOR<UserTaskCompletionUpdateWithoutTaskInput, UserTaskCompletionUncheckedUpdateWithoutTaskInput>
    create: XOR<UserTaskCompletionCreateWithoutTaskInput, UserTaskCompletionUncheckedCreateWithoutTaskInput>
  }

  export type UserTaskCompletionUpdateWithWhereUniqueWithoutTaskInput = {
    where: UserTaskCompletionWhereUniqueInput
    data: XOR<UserTaskCompletionUpdateWithoutTaskInput, UserTaskCompletionUncheckedUpdateWithoutTaskInput>
  }

  export type UserTaskCompletionUpdateManyWithWhereWithoutTaskInput = {
    where: UserTaskCompletionScalarWhereInput
    data: XOR<UserTaskCompletionUpdateManyMutationInput, UserTaskCompletionUncheckedUpdateManyWithoutTaskInput>
  }

  export type UserCreateWithoutChallengeProgressInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutChallengeProgressInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutChallengeProgressInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutChallengeProgressInput, UserUncheckedCreateWithoutChallengeProgressInput>
  }

  export type ChallengeCreateWithoutUserProgressInput = {
    id?: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date | string
    endDate: Date | string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: number | null
    bannerImage?: string | null
    icon?: string | null
    status?: string
    totalParticipants?: number
    activeParticipants?: number
    completionRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutChallengesCreatedInput
    tasks?: ChallengeTaskCreateNestedManyWithoutChallengeInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutUserProgressInput = {
    id?: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date | string
    endDate: Date | string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: number | null
    bannerImage?: string | null
    icon?: string | null
    status?: string
    totalParticipants?: number
    activeParticipants?: number
    completionRate?: Decimal | DecimalJsLike | number | string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: ChallengeTaskUncheckedCreateNestedManyWithoutChallengeInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutUserProgressInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutUserProgressInput, ChallengeUncheckedCreateWithoutUserProgressInput>
  }

  export type UserTaskCompletionCreateWithoutProgressInput = {
    id?: string
    challengeId: string
    completedAt?: Date | string
    timeTaken?: number | null
    submissionUrl?: string | null
    submissionText?: string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    score?: Decimal | DecimalJsLike | number | string | null
    pointsEarned?: number | null
    userNotes?: string | null
    feedback?: string | null
    user: UserCreateNestedOneWithoutTaskCompletionsInput
    task: ChallengeTaskCreateNestedOneWithoutCompletionsInput
  }

  export type UserTaskCompletionUncheckedCreateWithoutProgressInput = {
    id?: string
    userId: string
    challengeId: string
    taskId: string
    completedAt?: Date | string
    timeTaken?: number | null
    submissionUrl?: string | null
    submissionText?: string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    score?: Decimal | DecimalJsLike | number | string | null
    pointsEarned?: number | null
    userNotes?: string | null
    feedback?: string | null
  }

  export type UserTaskCompletionCreateOrConnectWithoutProgressInput = {
    where: UserTaskCompletionWhereUniqueInput
    create: XOR<UserTaskCompletionCreateWithoutProgressInput, UserTaskCompletionUncheckedCreateWithoutProgressInput>
  }

  export type UserTaskCompletionCreateManyProgressInputEnvelope = {
    data: UserTaskCompletionCreateManyProgressInput | UserTaskCompletionCreateManyProgressInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutChallengeProgressInput = {
    update: XOR<UserUpdateWithoutChallengeProgressInput, UserUncheckedUpdateWithoutChallengeProgressInput>
    create: XOR<UserCreateWithoutChallengeProgressInput, UserUncheckedCreateWithoutChallengeProgressInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutChallengeProgressInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutChallengeProgressInput, UserUncheckedUpdateWithoutChallengeProgressInput>
  }

  export type UserUpdateWithoutChallengeProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutChallengeProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type ChallengeUpsertWithoutUserProgressInput = {
    update: XOR<ChallengeUpdateWithoutUserProgressInput, ChallengeUncheckedUpdateWithoutUserProgressInput>
    create: XOR<ChallengeCreateWithoutUserProgressInput, ChallengeUncheckedCreateWithoutUserProgressInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutUserProgressInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutUserProgressInput, ChallengeUncheckedUpdateWithoutUserProgressInput>
  }

  export type ChallengeUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutChallengesCreatedNestedInput
    tasks?: ChallengeTaskUpdateManyWithoutChallengeNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutUserProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ChallengeTaskUncheckedUpdateManyWithoutChallengeNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type UserTaskCompletionUpsertWithWhereUniqueWithoutProgressInput = {
    where: UserTaskCompletionWhereUniqueInput
    update: XOR<UserTaskCompletionUpdateWithoutProgressInput, UserTaskCompletionUncheckedUpdateWithoutProgressInput>
    create: XOR<UserTaskCompletionCreateWithoutProgressInput, UserTaskCompletionUncheckedCreateWithoutProgressInput>
  }

  export type UserTaskCompletionUpdateWithWhereUniqueWithoutProgressInput = {
    where: UserTaskCompletionWhereUniqueInput
    data: XOR<UserTaskCompletionUpdateWithoutProgressInput, UserTaskCompletionUncheckedUpdateWithoutProgressInput>
  }

  export type UserTaskCompletionUpdateManyWithWhereWithoutProgressInput = {
    where: UserTaskCompletionScalarWhereInput
    data: XOR<UserTaskCompletionUpdateManyMutationInput, UserTaskCompletionUncheckedUpdateManyWithoutProgressInput>
  }

  export type UserCreateWithoutTaskCompletionsInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutTaskCompletionsInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutTaskCompletionsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTaskCompletionsInput, UserUncheckedCreateWithoutTaskCompletionsInput>
  }

  export type ChallengeTaskCreateWithoutCompletionsInput = {
    id?: string
    dayNumber: number
    title: string
    description?: string | null
    taskType: string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    points?: number
    autoValidate?: boolean
    validationUrl?: string | null
    createdAt?: Date | string
    challenge: ChallengeCreateNestedOneWithoutTasksInput
  }

  export type ChallengeTaskUncheckedCreateWithoutCompletionsInput = {
    id?: string
    challengeId: string
    dayNumber: number
    title: string
    description?: string | null
    taskType: string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    points?: number
    autoValidate?: boolean
    validationUrl?: string | null
    createdAt?: Date | string
  }

  export type ChallengeTaskCreateOrConnectWithoutCompletionsInput = {
    where: ChallengeTaskWhereUniqueInput
    create: XOR<ChallengeTaskCreateWithoutCompletionsInput, ChallengeTaskUncheckedCreateWithoutCompletionsInput>
  }

  export type UserChallengeProgressCreateWithoutTaskCompletionsInput = {
    id?: string
    status?: string
    completedDays?: number
    totalDays: number
    completionPercentage?: Decimal | DecimalJsLike | number | string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    totalPoints?: number
    bonusPoints?: number
    currentRank?: number | null
    startedAt?: Date | string
    lastActivity?: Date | string
    completedAt?: Date | string | null
    certificateIssued?: boolean
    certificateUrl?: string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    user: UserCreateNestedOneWithoutChallengeProgressInput
    challenge: ChallengeCreateNestedOneWithoutUserProgressInput
  }

  export type UserChallengeProgressUncheckedCreateWithoutTaskCompletionsInput = {
    id?: string
    userId: string
    challengeId: string
    status?: string
    completedDays?: number
    totalDays: number
    completionPercentage?: Decimal | DecimalJsLike | number | string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    totalPoints?: number
    bonusPoints?: number
    currentRank?: number | null
    startedAt?: Date | string
    lastActivity?: Date | string
    completedAt?: Date | string | null
    certificateIssued?: boolean
    certificateUrl?: string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserChallengeProgressCreateOrConnectWithoutTaskCompletionsInput = {
    where: UserChallengeProgressWhereUniqueInput
    create: XOR<UserChallengeProgressCreateWithoutTaskCompletionsInput, UserChallengeProgressUncheckedCreateWithoutTaskCompletionsInput>
  }

  export type UserUpsertWithoutTaskCompletionsInput = {
    update: XOR<UserUpdateWithoutTaskCompletionsInput, UserUncheckedUpdateWithoutTaskCompletionsInput>
    create: XOR<UserCreateWithoutTaskCompletionsInput, UserUncheckedCreateWithoutTaskCompletionsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTaskCompletionsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTaskCompletionsInput, UserUncheckedUpdateWithoutTaskCompletionsInput>
  }

  export type UserUpdateWithoutTaskCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutTaskCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type ChallengeTaskUpsertWithoutCompletionsInput = {
    update: XOR<ChallengeTaskUpdateWithoutCompletionsInput, ChallengeTaskUncheckedUpdateWithoutCompletionsInput>
    create: XOR<ChallengeTaskCreateWithoutCompletionsInput, ChallengeTaskUncheckedCreateWithoutCompletionsInput>
    where?: ChallengeTaskWhereInput
  }

  export type ChallengeTaskUpdateToOneWithWhereWithoutCompletionsInput = {
    where?: ChallengeTaskWhereInput
    data: XOR<ChallengeTaskUpdateWithoutCompletionsInput, ChallengeTaskUncheckedUpdateWithoutCompletionsInput>
  }

  export type ChallengeTaskUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    autoValidate?: BoolFieldUpdateOperationsInput | boolean
    validationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    challenge?: ChallengeUpdateOneRequiredWithoutTasksNestedInput
  }

  export type ChallengeTaskUncheckedUpdateWithoutCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    autoValidate?: BoolFieldUpdateOperationsInput | boolean
    validationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChallengeProgressUpsertWithoutTaskCompletionsInput = {
    update: XOR<UserChallengeProgressUpdateWithoutTaskCompletionsInput, UserChallengeProgressUncheckedUpdateWithoutTaskCompletionsInput>
    create: XOR<UserChallengeProgressCreateWithoutTaskCompletionsInput, UserChallengeProgressUncheckedCreateWithoutTaskCompletionsInput>
    where?: UserChallengeProgressWhereInput
  }

  export type UserChallengeProgressUpdateToOneWithWhereWithoutTaskCompletionsInput = {
    where?: UserChallengeProgressWhereInput
    data: XOR<UserChallengeProgressUpdateWithoutTaskCompletionsInput, UserChallengeProgressUncheckedUpdateWithoutTaskCompletionsInput>
  }

  export type UserChallengeProgressUpdateWithoutTaskCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedDays?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    completionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    bonusPoints?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateIssued?: BoolFieldUpdateOperationsInput | boolean
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutChallengeProgressNestedInput
    challenge?: ChallengeUpdateOneRequiredWithoutUserProgressNestedInput
  }

  export type UserChallengeProgressUncheckedUpdateWithoutTaskCompletionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedDays?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    completionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    bonusPoints?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateIssued?: BoolFieldUpdateOperationsInput | boolean
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserCreateWithoutBadgesInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutBadgesInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutBadgesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
  }

  export type UserUpsertWithoutBadgesInput = {
    update: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
    create: XOR<UserCreateWithoutBadgesInput, UserUncheckedCreateWithoutBadgesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutBadgesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutBadgesInput, UserUncheckedUpdateWithoutBadgesInput>
  }

  export type UserUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutBadgesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutAchievementsInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutAchievementsInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutAchievementsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
  }

  export type UserUpsertWithoutAchievementsInput = {
    update: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
    create: XOR<UserCreateWithoutAchievementsInput, UserUncheckedCreateWithoutAchievementsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAchievementsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAchievementsInput, UserUncheckedUpdateWithoutAchievementsInput>
  }

  export type UserUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutAchievementsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type UserCreateWithoutLeaderboardEntriesInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutLeaderboardEntriesInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutLeaderboardEntriesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
  }

  export type UserUpsertWithoutLeaderboardEntriesInput = {
    update: XOR<UserUpdateWithoutLeaderboardEntriesInput, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
    create: XOR<UserCreateWithoutLeaderboardEntriesInput, UserUncheckedCreateWithoutLeaderboardEntriesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaderboardEntriesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaderboardEntriesInput, UserUncheckedUpdateWithoutLeaderboardEntriesInput>
  }

  export type UserUpdateWithoutLeaderboardEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaderboardEntriesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type EventCreateWithoutEventChallengesInput = {
    id?: string
    title: string
    slug: string
    description: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    hasChallenges?: boolean
    problemCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: EventCategoryCreateNestedOneWithoutEventsInput
    creator?: UserCreateNestedOneWithoutEventsCreatedInput
    roadmap?: RoadmapCreateNestedOneWithoutEventsInput
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
    teams?: TeamCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogCreateNestedManyWithoutEventInput
    certificates?: CertificateCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutEventChallengesInput = {
    id?: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: string | null
    hasChallenges?: boolean
    problemCount?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutEventInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutEventChallengesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEventChallengesInput, EventUncheckedCreateWithoutEventChallengesInput>
  }

  export type ChallengeCreateWithoutEventChallengesInput = {
    id?: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date | string
    endDate: Date | string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: number | null
    bannerImage?: string | null
    icon?: string | null
    status?: string
    totalParticipants?: number
    activeParticipants?: number
    completionRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    creator?: UserCreateNestedOneWithoutChallengesCreatedInput
    tasks?: ChallengeTaskCreateNestedManyWithoutChallengeInput
    userProgress?: UserChallengeProgressCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeUncheckedCreateWithoutEventChallengesInput = {
    id?: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date | string
    endDate: Date | string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: number | null
    bannerImage?: string | null
    icon?: string | null
    status?: string
    totalParticipants?: number
    activeParticipants?: number
    completionRate?: Decimal | DecimalJsLike | number | string | null
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    tasks?: ChallengeTaskUncheckedCreateNestedManyWithoutChallengeInput
    userProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutChallengeInput
  }

  export type ChallengeCreateOrConnectWithoutEventChallengesInput = {
    where: ChallengeWhereUniqueInput
    create: XOR<ChallengeCreateWithoutEventChallengesInput, ChallengeUncheckedCreateWithoutEventChallengesInput>
  }

  export type EventUpsertWithoutEventChallengesInput = {
    update: XOR<EventUpdateWithoutEventChallengesInput, EventUncheckedUpdateWithoutEventChallengesInput>
    create: XOR<EventCreateWithoutEventChallengesInput, EventUncheckedCreateWithoutEventChallengesInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutEventChallengesInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutEventChallengesInput, EventUncheckedUpdateWithoutEventChallengesInput>
  }

  export type EventUpdateWithoutEventChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EventCategoryUpdateOneRequiredWithoutEventsNestedInput
    creator?: UserUpdateOneWithoutEventsCreatedNestedInput
    roadmap?: RoadmapUpdateOneWithoutEventsNestedInput
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
    teams?: TeamUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUpdateManyWithoutEventNestedInput
    certificates?: CertificateUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutEventChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutEventNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutEventNestedInput
  }

  export type ChallengeUpsertWithoutEventChallengesInput = {
    update: XOR<ChallengeUpdateWithoutEventChallengesInput, ChallengeUncheckedUpdateWithoutEventChallengesInput>
    create: XOR<ChallengeCreateWithoutEventChallengesInput, ChallengeUncheckedCreateWithoutEventChallengesInput>
    where?: ChallengeWhereInput
  }

  export type ChallengeUpdateToOneWithWhereWithoutEventChallengesInput = {
    where?: ChallengeWhereInput
    data: XOR<ChallengeUpdateWithoutEventChallengesInput, ChallengeUncheckedUpdateWithoutEventChallengesInput>
  }

  export type ChallengeUpdateWithoutEventChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutChallengesCreatedNestedInput
    tasks?: ChallengeTaskUpdateManyWithoutChallengeNestedInput
    userProgress?: UserChallengeProgressUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutEventChallengesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ChallengeTaskUncheckedUpdateManyWithoutChallengeNestedInput
    userProgress?: UserChallengeProgressUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type RoadmapPhaseCreateWithoutRoadmapInput = {
    id?: string
    order: number
    title: string
    level?: string | null
    duration?: string | null
    description?: string | null
    sections?: PhaseSectionCreateNestedManyWithoutPhaseInput
    playlists?: PhasePlaylistCreateNestedManyWithoutPhaseInput
    projects?: PhaseProjectCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseUncheckedCreateWithoutRoadmapInput = {
    id?: string
    order: number
    title: string
    level?: string | null
    duration?: string | null
    description?: string | null
    sections?: PhaseSectionUncheckedCreateNestedManyWithoutPhaseInput
    playlists?: PhasePlaylistUncheckedCreateNestedManyWithoutPhaseInput
    projects?: PhaseProjectUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseCreateOrConnectWithoutRoadmapInput = {
    where: RoadmapPhaseWhereUniqueInput
    create: XOR<RoadmapPhaseCreateWithoutRoadmapInput, RoadmapPhaseUncheckedCreateWithoutRoadmapInput>
  }

  export type RoadmapPhaseCreateManyRoadmapInputEnvelope = {
    data: RoadmapPhaseCreateManyRoadmapInput | RoadmapPhaseCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type EventCreateWithoutRoadmapInput = {
    id?: string
    title: string
    slug: string
    description: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    hasChallenges?: boolean
    problemCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: EventCategoryCreateNestedOneWithoutEventsInput
    creator?: UserCreateNestedOneWithoutEventsCreatedInput
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
    teams?: TeamCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogCreateNestedManyWithoutEventInput
    certificates?: CertificateCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutRoadmapInput = {
    id?: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    hasChallenges?: boolean
    problemCount?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutEventInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutRoadmapInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutRoadmapInput, EventUncheckedCreateWithoutRoadmapInput>
  }

  export type EventCreateManyRoadmapInputEnvelope = {
    data: EventCreateManyRoadmapInput | EventCreateManyRoadmapInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapPhaseUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: RoadmapPhaseWhereUniqueInput
    update: XOR<RoadmapPhaseUpdateWithoutRoadmapInput, RoadmapPhaseUncheckedUpdateWithoutRoadmapInput>
    create: XOR<RoadmapPhaseCreateWithoutRoadmapInput, RoadmapPhaseUncheckedCreateWithoutRoadmapInput>
  }

  export type RoadmapPhaseUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: RoadmapPhaseWhereUniqueInput
    data: XOR<RoadmapPhaseUpdateWithoutRoadmapInput, RoadmapPhaseUncheckedUpdateWithoutRoadmapInput>
  }

  export type RoadmapPhaseUpdateManyWithWhereWithoutRoadmapInput = {
    where: RoadmapPhaseScalarWhereInput
    data: XOR<RoadmapPhaseUpdateManyMutationInput, RoadmapPhaseUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type RoadmapPhaseScalarWhereInput = {
    AND?: RoadmapPhaseScalarWhereInput | RoadmapPhaseScalarWhereInput[]
    OR?: RoadmapPhaseScalarWhereInput[]
    NOT?: RoadmapPhaseScalarWhereInput | RoadmapPhaseScalarWhereInput[]
    id?: StringFilter<"RoadmapPhase"> | string
    roadmapId?: StringFilter<"RoadmapPhase"> | string
    order?: IntFilter<"RoadmapPhase"> | number
    title?: StringFilter<"RoadmapPhase"> | string
    level?: StringNullableFilter<"RoadmapPhase"> | string | null
    duration?: StringNullableFilter<"RoadmapPhase"> | string | null
    description?: StringNullableFilter<"RoadmapPhase"> | string | null
  }

  export type EventUpsertWithWhereUniqueWithoutRoadmapInput = {
    where: EventWhereUniqueInput
    update: XOR<EventUpdateWithoutRoadmapInput, EventUncheckedUpdateWithoutRoadmapInput>
    create: XOR<EventCreateWithoutRoadmapInput, EventUncheckedCreateWithoutRoadmapInput>
  }

  export type EventUpdateWithWhereUniqueWithoutRoadmapInput = {
    where: EventWhereUniqueInput
    data: XOR<EventUpdateWithoutRoadmapInput, EventUncheckedUpdateWithoutRoadmapInput>
  }

  export type EventUpdateManyWithWhereWithoutRoadmapInput = {
    where: EventScalarWhereInput
    data: XOR<EventUpdateManyMutationInput, EventUncheckedUpdateManyWithoutRoadmapInput>
  }

  export type RoadmapCreateWithoutPhasesInput = {
    id?: string
    title: string
    description: string
    roleTarget: string
    createdAt?: Date | string
    events?: EventCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapUncheckedCreateWithoutPhasesInput = {
    id?: string
    title: string
    description: string
    roleTarget: string
    createdAt?: Date | string
    events?: EventUncheckedCreateNestedManyWithoutRoadmapInput
  }

  export type RoadmapCreateOrConnectWithoutPhasesInput = {
    where: RoadmapWhereUniqueInput
    create: XOR<RoadmapCreateWithoutPhasesInput, RoadmapUncheckedCreateWithoutPhasesInput>
  }

  export type PhaseSectionCreateWithoutPhaseInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    items?: SectionItemCreateNestedManyWithoutSectionInput
  }

  export type PhaseSectionUncheckedCreateWithoutPhaseInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    items?: SectionItemUncheckedCreateNestedManyWithoutSectionInput
  }

  export type PhaseSectionCreateOrConnectWithoutPhaseInput = {
    where: PhaseSectionWhereUniqueInput
    create: XOR<PhaseSectionCreateWithoutPhaseInput, PhaseSectionUncheckedCreateWithoutPhaseInput>
  }

  export type PhaseSectionCreateManyPhaseInputEnvelope = {
    data: PhaseSectionCreateManyPhaseInput | PhaseSectionCreateManyPhaseInput[]
    skipDuplicates?: boolean
  }

  export type PhasePlaylistCreateWithoutPhaseInput = {
    id?: string
    title: string
    author?: string | null
    videoCount?: number
    url: string
    thumbnail?: string | null
  }

  export type PhasePlaylistUncheckedCreateWithoutPhaseInput = {
    id?: string
    title: string
    author?: string | null
    videoCount?: number
    url: string
    thumbnail?: string | null
  }

  export type PhasePlaylistCreateOrConnectWithoutPhaseInput = {
    where: PhasePlaylistWhereUniqueInput
    create: XOR<PhasePlaylistCreateWithoutPhaseInput, PhasePlaylistUncheckedCreateWithoutPhaseInput>
  }

  export type PhasePlaylistCreateManyPhaseInputEnvelope = {
    data: PhasePlaylistCreateManyPhaseInput | PhasePlaylistCreateManyPhaseInput[]
    skipDuplicates?: boolean
  }

  export type PhaseProjectCreateWithoutPhaseInput = {
    id?: string
    title: string
    description?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PhaseProjectUncheckedCreateWithoutPhaseInput = {
    id?: string
    title: string
    description?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PhaseProjectCreateOrConnectWithoutPhaseInput = {
    where: PhaseProjectWhereUniqueInput
    create: XOR<PhaseProjectCreateWithoutPhaseInput, PhaseProjectUncheckedCreateWithoutPhaseInput>
  }

  export type PhaseProjectCreateManyPhaseInputEnvelope = {
    data: PhaseProjectCreateManyPhaseInput | PhaseProjectCreateManyPhaseInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapUpsertWithoutPhasesInput = {
    update: XOR<RoadmapUpdateWithoutPhasesInput, RoadmapUncheckedUpdateWithoutPhasesInput>
    create: XOR<RoadmapCreateWithoutPhasesInput, RoadmapUncheckedCreateWithoutPhasesInput>
    where?: RoadmapWhereInput
  }

  export type RoadmapUpdateToOneWithWhereWithoutPhasesInput = {
    where?: RoadmapWhereInput
    data: XOR<RoadmapUpdateWithoutPhasesInput, RoadmapUncheckedUpdateWithoutPhasesInput>
  }

  export type RoadmapUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    roleTarget?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUpdateManyWithoutRoadmapNestedInput
  }

  export type RoadmapUncheckedUpdateWithoutPhasesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    roleTarget?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    events?: EventUncheckedUpdateManyWithoutRoadmapNestedInput
  }

  export type PhaseSectionUpsertWithWhereUniqueWithoutPhaseInput = {
    where: PhaseSectionWhereUniqueInput
    update: XOR<PhaseSectionUpdateWithoutPhaseInput, PhaseSectionUncheckedUpdateWithoutPhaseInput>
    create: XOR<PhaseSectionCreateWithoutPhaseInput, PhaseSectionUncheckedCreateWithoutPhaseInput>
  }

  export type PhaseSectionUpdateWithWhereUniqueWithoutPhaseInput = {
    where: PhaseSectionWhereUniqueInput
    data: XOR<PhaseSectionUpdateWithoutPhaseInput, PhaseSectionUncheckedUpdateWithoutPhaseInput>
  }

  export type PhaseSectionUpdateManyWithWhereWithoutPhaseInput = {
    where: PhaseSectionScalarWhereInput
    data: XOR<PhaseSectionUpdateManyMutationInput, PhaseSectionUncheckedUpdateManyWithoutPhaseInput>
  }

  export type PhaseSectionScalarWhereInput = {
    AND?: PhaseSectionScalarWhereInput | PhaseSectionScalarWhereInput[]
    OR?: PhaseSectionScalarWhereInput[]
    NOT?: PhaseSectionScalarWhereInput | PhaseSectionScalarWhereInput[]
    id?: StringFilter<"PhaseSection"> | string
    phaseId?: StringFilter<"PhaseSection"> | string
    title?: StringFilter<"PhaseSection"> | string
    description?: StringNullableFilter<"PhaseSection"> | string | null
    order?: IntFilter<"PhaseSection"> | number
  }

  export type PhasePlaylistUpsertWithWhereUniqueWithoutPhaseInput = {
    where: PhasePlaylistWhereUniqueInput
    update: XOR<PhasePlaylistUpdateWithoutPhaseInput, PhasePlaylistUncheckedUpdateWithoutPhaseInput>
    create: XOR<PhasePlaylistCreateWithoutPhaseInput, PhasePlaylistUncheckedCreateWithoutPhaseInput>
  }

  export type PhasePlaylistUpdateWithWhereUniqueWithoutPhaseInput = {
    where: PhasePlaylistWhereUniqueInput
    data: XOR<PhasePlaylistUpdateWithoutPhaseInput, PhasePlaylistUncheckedUpdateWithoutPhaseInput>
  }

  export type PhasePlaylistUpdateManyWithWhereWithoutPhaseInput = {
    where: PhasePlaylistScalarWhereInput
    data: XOR<PhasePlaylistUpdateManyMutationInput, PhasePlaylistUncheckedUpdateManyWithoutPhaseInput>
  }

  export type PhasePlaylistScalarWhereInput = {
    AND?: PhasePlaylistScalarWhereInput | PhasePlaylistScalarWhereInput[]
    OR?: PhasePlaylistScalarWhereInput[]
    NOT?: PhasePlaylistScalarWhereInput | PhasePlaylistScalarWhereInput[]
    id?: StringFilter<"PhasePlaylist"> | string
    phaseId?: StringFilter<"PhasePlaylist"> | string
    title?: StringFilter<"PhasePlaylist"> | string
    author?: StringNullableFilter<"PhasePlaylist"> | string | null
    videoCount?: IntFilter<"PhasePlaylist"> | number
    url?: StringFilter<"PhasePlaylist"> | string
    thumbnail?: StringNullableFilter<"PhasePlaylist"> | string | null
  }

  export type PhaseProjectUpsertWithWhereUniqueWithoutPhaseInput = {
    where: PhaseProjectWhereUniqueInput
    update: XOR<PhaseProjectUpdateWithoutPhaseInput, PhaseProjectUncheckedUpdateWithoutPhaseInput>
    create: XOR<PhaseProjectCreateWithoutPhaseInput, PhaseProjectUncheckedCreateWithoutPhaseInput>
  }

  export type PhaseProjectUpdateWithWhereUniqueWithoutPhaseInput = {
    where: PhaseProjectWhereUniqueInput
    data: XOR<PhaseProjectUpdateWithoutPhaseInput, PhaseProjectUncheckedUpdateWithoutPhaseInput>
  }

  export type PhaseProjectUpdateManyWithWhereWithoutPhaseInput = {
    where: PhaseProjectScalarWhereInput
    data: XOR<PhaseProjectUpdateManyMutationInput, PhaseProjectUncheckedUpdateManyWithoutPhaseInput>
  }

  export type PhaseProjectScalarWhereInput = {
    AND?: PhaseProjectScalarWhereInput | PhaseProjectScalarWhereInput[]
    OR?: PhaseProjectScalarWhereInput[]
    NOT?: PhaseProjectScalarWhereInput | PhaseProjectScalarWhereInput[]
    id?: StringFilter<"PhaseProject"> | string
    phaseId?: StringFilter<"PhaseProject"> | string
    title?: StringFilter<"PhaseProject"> | string
    description?: StringNullableFilter<"PhaseProject"> | string | null
    tags?: JsonNullableFilter<"PhaseProject">
  }

  export type RoadmapPhaseCreateWithoutSectionsInput = {
    id?: string
    order: number
    title: string
    level?: string | null
    duration?: string | null
    description?: string | null
    roadmap: RoadmapCreateNestedOneWithoutPhasesInput
    playlists?: PhasePlaylistCreateNestedManyWithoutPhaseInput
    projects?: PhaseProjectCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseUncheckedCreateWithoutSectionsInput = {
    id?: string
    roadmapId: string
    order: number
    title: string
    level?: string | null
    duration?: string | null
    description?: string | null
    playlists?: PhasePlaylistUncheckedCreateNestedManyWithoutPhaseInput
    projects?: PhaseProjectUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseCreateOrConnectWithoutSectionsInput = {
    where: RoadmapPhaseWhereUniqueInput
    create: XOR<RoadmapPhaseCreateWithoutSectionsInput, RoadmapPhaseUncheckedCreateWithoutSectionsInput>
  }

  export type SectionItemCreateWithoutSectionInput = {
    id?: string
    title: string
    order?: number
    subItems?: SubItemCreateNestedManyWithoutItemInput
  }

  export type SectionItemUncheckedCreateWithoutSectionInput = {
    id?: string
    title: string
    order?: number
    subItems?: SubItemUncheckedCreateNestedManyWithoutItemInput
  }

  export type SectionItemCreateOrConnectWithoutSectionInput = {
    where: SectionItemWhereUniqueInput
    create: XOR<SectionItemCreateWithoutSectionInput, SectionItemUncheckedCreateWithoutSectionInput>
  }

  export type SectionItemCreateManySectionInputEnvelope = {
    data: SectionItemCreateManySectionInput | SectionItemCreateManySectionInput[]
    skipDuplicates?: boolean
  }

  export type RoadmapPhaseUpsertWithoutSectionsInput = {
    update: XOR<RoadmapPhaseUpdateWithoutSectionsInput, RoadmapPhaseUncheckedUpdateWithoutSectionsInput>
    create: XOR<RoadmapPhaseCreateWithoutSectionsInput, RoadmapPhaseUncheckedCreateWithoutSectionsInput>
    where?: RoadmapPhaseWhereInput
  }

  export type RoadmapPhaseUpdateToOneWithWhereWithoutSectionsInput = {
    where?: RoadmapPhaseWhereInput
    data: XOR<RoadmapPhaseUpdateWithoutSectionsInput, RoadmapPhaseUncheckedUpdateWithoutSectionsInput>
  }

  export type RoadmapPhaseUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadmap?: RoadmapUpdateOneRequiredWithoutPhasesNestedInput
    playlists?: PhasePlaylistUpdateManyWithoutPhaseNestedInput
    projects?: PhaseProjectUpdateManyWithoutPhaseNestedInput
  }

  export type RoadmapPhaseUncheckedUpdateWithoutSectionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    playlists?: PhasePlaylistUncheckedUpdateManyWithoutPhaseNestedInput
    projects?: PhaseProjectUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type SectionItemUpsertWithWhereUniqueWithoutSectionInput = {
    where: SectionItemWhereUniqueInput
    update: XOR<SectionItemUpdateWithoutSectionInput, SectionItemUncheckedUpdateWithoutSectionInput>
    create: XOR<SectionItemCreateWithoutSectionInput, SectionItemUncheckedCreateWithoutSectionInput>
  }

  export type SectionItemUpdateWithWhereUniqueWithoutSectionInput = {
    where: SectionItemWhereUniqueInput
    data: XOR<SectionItemUpdateWithoutSectionInput, SectionItemUncheckedUpdateWithoutSectionInput>
  }

  export type SectionItemUpdateManyWithWhereWithoutSectionInput = {
    where: SectionItemScalarWhereInput
    data: XOR<SectionItemUpdateManyMutationInput, SectionItemUncheckedUpdateManyWithoutSectionInput>
  }

  export type SectionItemScalarWhereInput = {
    AND?: SectionItemScalarWhereInput | SectionItemScalarWhereInput[]
    OR?: SectionItemScalarWhereInput[]
    NOT?: SectionItemScalarWhereInput | SectionItemScalarWhereInput[]
    id?: StringFilter<"SectionItem"> | string
    sectionId?: StringFilter<"SectionItem"> | string
    title?: StringFilter<"SectionItem"> | string
    order?: IntFilter<"SectionItem"> | number
  }

  export type PhaseSectionCreateWithoutItemsInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
    phase: RoadmapPhaseCreateNestedOneWithoutSectionsInput
  }

  export type PhaseSectionUncheckedCreateWithoutItemsInput = {
    id?: string
    phaseId: string
    title: string
    description?: string | null
    order?: number
  }

  export type PhaseSectionCreateOrConnectWithoutItemsInput = {
    where: PhaseSectionWhereUniqueInput
    create: XOR<PhaseSectionCreateWithoutItemsInput, PhaseSectionUncheckedCreateWithoutItemsInput>
  }

  export type SubItemCreateWithoutItemInput = {
    id?: string
    title: string
    videoUrl?: string | null
    duration?: string | null
    order?: number
  }

  export type SubItemUncheckedCreateWithoutItemInput = {
    id?: string
    title: string
    videoUrl?: string | null
    duration?: string | null
    order?: number
  }

  export type SubItemCreateOrConnectWithoutItemInput = {
    where: SubItemWhereUniqueInput
    create: XOR<SubItemCreateWithoutItemInput, SubItemUncheckedCreateWithoutItemInput>
  }

  export type SubItemCreateManyItemInputEnvelope = {
    data: SubItemCreateManyItemInput | SubItemCreateManyItemInput[]
    skipDuplicates?: boolean
  }

  export type PhaseSectionUpsertWithoutItemsInput = {
    update: XOR<PhaseSectionUpdateWithoutItemsInput, PhaseSectionUncheckedUpdateWithoutItemsInput>
    create: XOR<PhaseSectionCreateWithoutItemsInput, PhaseSectionUncheckedCreateWithoutItemsInput>
    where?: PhaseSectionWhereInput
  }

  export type PhaseSectionUpdateToOneWithWhereWithoutItemsInput = {
    where?: PhaseSectionWhereInput
    data: XOR<PhaseSectionUpdateWithoutItemsInput, PhaseSectionUncheckedUpdateWithoutItemsInput>
  }

  export type PhaseSectionUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    phase?: RoadmapPhaseUpdateOneRequiredWithoutSectionsNestedInput
  }

  export type PhaseSectionUncheckedUpdateWithoutItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    phaseId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SubItemUpsertWithWhereUniqueWithoutItemInput = {
    where: SubItemWhereUniqueInput
    update: XOR<SubItemUpdateWithoutItemInput, SubItemUncheckedUpdateWithoutItemInput>
    create: XOR<SubItemCreateWithoutItemInput, SubItemUncheckedCreateWithoutItemInput>
  }

  export type SubItemUpdateWithWhereUniqueWithoutItemInput = {
    where: SubItemWhereUniqueInput
    data: XOR<SubItemUpdateWithoutItemInput, SubItemUncheckedUpdateWithoutItemInput>
  }

  export type SubItemUpdateManyWithWhereWithoutItemInput = {
    where: SubItemScalarWhereInput
    data: XOR<SubItemUpdateManyMutationInput, SubItemUncheckedUpdateManyWithoutItemInput>
  }

  export type SubItemScalarWhereInput = {
    AND?: SubItemScalarWhereInput | SubItemScalarWhereInput[]
    OR?: SubItemScalarWhereInput[]
    NOT?: SubItemScalarWhereInput | SubItemScalarWhereInput[]
    id?: StringFilter<"SubItem"> | string
    itemId?: StringFilter<"SubItem"> | string
    title?: StringFilter<"SubItem"> | string
    videoUrl?: StringNullableFilter<"SubItem"> | string | null
    duration?: StringNullableFilter<"SubItem"> | string | null
    order?: IntFilter<"SubItem"> | number
  }

  export type SectionItemCreateWithoutSubItemsInput = {
    id?: string
    title: string
    order?: number
    section: PhaseSectionCreateNestedOneWithoutItemsInput
  }

  export type SectionItemUncheckedCreateWithoutSubItemsInput = {
    id?: string
    sectionId: string
    title: string
    order?: number
  }

  export type SectionItemCreateOrConnectWithoutSubItemsInput = {
    where: SectionItemWhereUniqueInput
    create: XOR<SectionItemCreateWithoutSubItemsInput, SectionItemUncheckedCreateWithoutSubItemsInput>
  }

  export type SectionItemUpsertWithoutSubItemsInput = {
    update: XOR<SectionItemUpdateWithoutSubItemsInput, SectionItemUncheckedUpdateWithoutSubItemsInput>
    create: XOR<SectionItemCreateWithoutSubItemsInput, SectionItemUncheckedCreateWithoutSubItemsInput>
    where?: SectionItemWhereInput
  }

  export type SectionItemUpdateToOneWithWhereWithoutSubItemsInput = {
    where?: SectionItemWhereInput
    data: XOR<SectionItemUpdateWithoutSubItemsInput, SectionItemUncheckedUpdateWithoutSubItemsInput>
  }

  export type SectionItemUpdateWithoutSubItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    section?: PhaseSectionUpdateOneRequiredWithoutItemsNestedInput
  }

  export type SectionItemUncheckedUpdateWithoutSubItemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    sectionId?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type RoadmapPhaseCreateWithoutPlaylistsInput = {
    id?: string
    order: number
    title: string
    level?: string | null
    duration?: string | null
    description?: string | null
    roadmap: RoadmapCreateNestedOneWithoutPhasesInput
    sections?: PhaseSectionCreateNestedManyWithoutPhaseInput
    projects?: PhaseProjectCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseUncheckedCreateWithoutPlaylistsInput = {
    id?: string
    roadmapId: string
    order: number
    title: string
    level?: string | null
    duration?: string | null
    description?: string | null
    sections?: PhaseSectionUncheckedCreateNestedManyWithoutPhaseInput
    projects?: PhaseProjectUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseCreateOrConnectWithoutPlaylistsInput = {
    where: RoadmapPhaseWhereUniqueInput
    create: XOR<RoadmapPhaseCreateWithoutPlaylistsInput, RoadmapPhaseUncheckedCreateWithoutPlaylistsInput>
  }

  export type RoadmapPhaseUpsertWithoutPlaylistsInput = {
    update: XOR<RoadmapPhaseUpdateWithoutPlaylistsInput, RoadmapPhaseUncheckedUpdateWithoutPlaylistsInput>
    create: XOR<RoadmapPhaseCreateWithoutPlaylistsInput, RoadmapPhaseUncheckedCreateWithoutPlaylistsInput>
    where?: RoadmapPhaseWhereInput
  }

  export type RoadmapPhaseUpdateToOneWithWhereWithoutPlaylistsInput = {
    where?: RoadmapPhaseWhereInput
    data: XOR<RoadmapPhaseUpdateWithoutPlaylistsInput, RoadmapPhaseUncheckedUpdateWithoutPlaylistsInput>
  }

  export type RoadmapPhaseUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadmap?: RoadmapUpdateOneRequiredWithoutPhasesNestedInput
    sections?: PhaseSectionUpdateManyWithoutPhaseNestedInput
    projects?: PhaseProjectUpdateManyWithoutPhaseNestedInput
  }

  export type RoadmapPhaseUncheckedUpdateWithoutPlaylistsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: PhaseSectionUncheckedUpdateManyWithoutPhaseNestedInput
    projects?: PhaseProjectUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type RoadmapPhaseCreateWithoutProjectsInput = {
    id?: string
    order: number
    title: string
    level?: string | null
    duration?: string | null
    description?: string | null
    roadmap: RoadmapCreateNestedOneWithoutPhasesInput
    sections?: PhaseSectionCreateNestedManyWithoutPhaseInput
    playlists?: PhasePlaylistCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseUncheckedCreateWithoutProjectsInput = {
    id?: string
    roadmapId: string
    order: number
    title: string
    level?: string | null
    duration?: string | null
    description?: string | null
    sections?: PhaseSectionUncheckedCreateNestedManyWithoutPhaseInput
    playlists?: PhasePlaylistUncheckedCreateNestedManyWithoutPhaseInput
  }

  export type RoadmapPhaseCreateOrConnectWithoutProjectsInput = {
    where: RoadmapPhaseWhereUniqueInput
    create: XOR<RoadmapPhaseCreateWithoutProjectsInput, RoadmapPhaseUncheckedCreateWithoutProjectsInput>
  }

  export type RoadmapPhaseUpsertWithoutProjectsInput = {
    update: XOR<RoadmapPhaseUpdateWithoutProjectsInput, RoadmapPhaseUncheckedUpdateWithoutProjectsInput>
    create: XOR<RoadmapPhaseCreateWithoutProjectsInput, RoadmapPhaseUncheckedCreateWithoutProjectsInput>
    where?: RoadmapPhaseWhereInput
  }

  export type RoadmapPhaseUpdateToOneWithWhereWithoutProjectsInput = {
    where?: RoadmapPhaseWhereInput
    data: XOR<RoadmapPhaseUpdateWithoutProjectsInput, RoadmapPhaseUncheckedUpdateWithoutProjectsInput>
  }

  export type RoadmapPhaseUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    roadmap?: RoadmapUpdateOneRequiredWithoutPhasesNestedInput
    sections?: PhaseSectionUpdateManyWithoutPhaseNestedInput
    playlists?: PhasePlaylistUpdateManyWithoutPhaseNestedInput
  }

  export type RoadmapPhaseUncheckedUpdateWithoutProjectsInput = {
    id?: StringFieldUpdateOperationsInput | string
    roadmapId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: PhaseSectionUncheckedUpdateManyWithoutPhaseNestedInput
    playlists?: PhasePlaylistUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type DSATopicCreateWithoutSheetInput = {
    id?: string
    title: string
    order?: number
    problems?: DSAProblemCreateNestedManyWithoutTopicInput
  }

  export type DSATopicUncheckedCreateWithoutSheetInput = {
    id?: string
    title: string
    order?: number
    problems?: DSAProblemUncheckedCreateNestedManyWithoutTopicInput
  }

  export type DSATopicCreateOrConnectWithoutSheetInput = {
    where: DSATopicWhereUniqueInput
    create: XOR<DSATopicCreateWithoutSheetInput, DSATopicUncheckedCreateWithoutSheetInput>
  }

  export type DSATopicCreateManySheetInputEnvelope = {
    data: DSATopicCreateManySheetInput | DSATopicCreateManySheetInput[]
    skipDuplicates?: boolean
  }

  export type DSATopicUpsertWithWhereUniqueWithoutSheetInput = {
    where: DSATopicWhereUniqueInput
    update: XOR<DSATopicUpdateWithoutSheetInput, DSATopicUncheckedUpdateWithoutSheetInput>
    create: XOR<DSATopicCreateWithoutSheetInput, DSATopicUncheckedCreateWithoutSheetInput>
  }

  export type DSATopicUpdateWithWhereUniqueWithoutSheetInput = {
    where: DSATopicWhereUniqueInput
    data: XOR<DSATopicUpdateWithoutSheetInput, DSATopicUncheckedUpdateWithoutSheetInput>
  }

  export type DSATopicUpdateManyWithWhereWithoutSheetInput = {
    where: DSATopicScalarWhereInput
    data: XOR<DSATopicUpdateManyMutationInput, DSATopicUncheckedUpdateManyWithoutSheetInput>
  }

  export type DSATopicScalarWhereInput = {
    AND?: DSATopicScalarWhereInput | DSATopicScalarWhereInput[]
    OR?: DSATopicScalarWhereInput[]
    NOT?: DSATopicScalarWhereInput | DSATopicScalarWhereInput[]
    id?: StringFilter<"DSATopic"> | string
    title?: StringFilter<"DSATopic"> | string
    sheetId?: StringFilter<"DSATopic"> | string
    order?: IntFilter<"DSATopic"> | number
  }

  export type DSASheetCreateWithoutTopicsInput = {
    id?: string
    title: string
    description: string
    level: string
    createdAt?: Date | string
  }

  export type DSASheetUncheckedCreateWithoutTopicsInput = {
    id?: string
    title: string
    description: string
    level: string
    createdAt?: Date | string
  }

  export type DSASheetCreateOrConnectWithoutTopicsInput = {
    where: DSASheetWhereUniqueInput
    create: XOR<DSASheetCreateWithoutTopicsInput, DSASheetUncheckedCreateWithoutTopicsInput>
  }

  export type DSAProblemCreateWithoutTopicInput = {
    id?: string
    title: string
    description?: string | null
    difficulty: string
    order?: number
    solutions?: DSASolutionCreateNestedManyWithoutProblemInput
  }

  export type DSAProblemUncheckedCreateWithoutTopicInput = {
    id?: string
    title: string
    description?: string | null
    difficulty: string
    order?: number
    solutions?: DSASolutionUncheckedCreateNestedManyWithoutProblemInput
  }

  export type DSAProblemCreateOrConnectWithoutTopicInput = {
    where: DSAProblemWhereUniqueInput
    create: XOR<DSAProblemCreateWithoutTopicInput, DSAProblemUncheckedCreateWithoutTopicInput>
  }

  export type DSAProblemCreateManyTopicInputEnvelope = {
    data: DSAProblemCreateManyTopicInput | DSAProblemCreateManyTopicInput[]
    skipDuplicates?: boolean
  }

  export type DSASheetUpsertWithoutTopicsInput = {
    update: XOR<DSASheetUpdateWithoutTopicsInput, DSASheetUncheckedUpdateWithoutTopicsInput>
    create: XOR<DSASheetCreateWithoutTopicsInput, DSASheetUncheckedCreateWithoutTopicsInput>
    where?: DSASheetWhereInput
  }

  export type DSASheetUpdateToOneWithWhereWithoutTopicsInput = {
    where?: DSASheetWhereInput
    data: XOR<DSASheetUpdateWithoutTopicsInput, DSASheetUncheckedUpdateWithoutTopicsInput>
  }

  export type DSASheetUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSASheetUncheckedUpdateWithoutTopicsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    level?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DSAProblemUpsertWithWhereUniqueWithoutTopicInput = {
    where: DSAProblemWhereUniqueInput
    update: XOR<DSAProblemUpdateWithoutTopicInput, DSAProblemUncheckedUpdateWithoutTopicInput>
    create: XOR<DSAProblemCreateWithoutTopicInput, DSAProblemUncheckedCreateWithoutTopicInput>
  }

  export type DSAProblemUpdateWithWhereUniqueWithoutTopicInput = {
    where: DSAProblemWhereUniqueInput
    data: XOR<DSAProblemUpdateWithoutTopicInput, DSAProblemUncheckedUpdateWithoutTopicInput>
  }

  export type DSAProblemUpdateManyWithWhereWithoutTopicInput = {
    where: DSAProblemScalarWhereInput
    data: XOR<DSAProblemUpdateManyMutationInput, DSAProblemUncheckedUpdateManyWithoutTopicInput>
  }

  export type DSAProblemScalarWhereInput = {
    AND?: DSAProblemScalarWhereInput | DSAProblemScalarWhereInput[]
    OR?: DSAProblemScalarWhereInput[]
    NOT?: DSAProblemScalarWhereInput | DSAProblemScalarWhereInput[]
    id?: StringFilter<"DSAProblem"> | string
    title?: StringFilter<"DSAProblem"> | string
    description?: StringNullableFilter<"DSAProblem"> | string | null
    difficulty?: StringFilter<"DSAProblem"> | string
    topicId?: StringFilter<"DSAProblem"> | string
    order?: IntFilter<"DSAProblem"> | number
  }

  export type DSATopicCreateWithoutProblemsInput = {
    id?: string
    title: string
    order?: number
    sheet: DSASheetCreateNestedOneWithoutTopicsInput
  }

  export type DSATopicUncheckedCreateWithoutProblemsInput = {
    id?: string
    title: string
    sheetId: string
    order?: number
  }

  export type DSATopicCreateOrConnectWithoutProblemsInput = {
    where: DSATopicWhereUniqueInput
    create: XOR<DSATopicCreateWithoutProblemsInput, DSATopicUncheckedCreateWithoutProblemsInput>
  }

  export type DSASolutionCreateWithoutProblemInput = {
    id?: string
    language: string
    code: string
  }

  export type DSASolutionUncheckedCreateWithoutProblemInput = {
    id?: string
    language: string
    code: string
  }

  export type DSASolutionCreateOrConnectWithoutProblemInput = {
    where: DSASolutionWhereUniqueInput
    create: XOR<DSASolutionCreateWithoutProblemInput, DSASolutionUncheckedCreateWithoutProblemInput>
  }

  export type DSASolutionCreateManyProblemInputEnvelope = {
    data: DSASolutionCreateManyProblemInput | DSASolutionCreateManyProblemInput[]
    skipDuplicates?: boolean
  }

  export type DSATopicUpsertWithoutProblemsInput = {
    update: XOR<DSATopicUpdateWithoutProblemsInput, DSATopicUncheckedUpdateWithoutProblemsInput>
    create: XOR<DSATopicCreateWithoutProblemsInput, DSATopicUncheckedCreateWithoutProblemsInput>
    where?: DSATopicWhereInput
  }

  export type DSATopicUpdateToOneWithWhereWithoutProblemsInput = {
    where?: DSATopicWhereInput
    data: XOR<DSATopicUpdateWithoutProblemsInput, DSATopicUncheckedUpdateWithoutProblemsInput>
  }

  export type DSATopicUpdateWithoutProblemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    sheet?: DSASheetUpdateOneRequiredWithoutTopicsNestedInput
  }

  export type DSATopicUncheckedUpdateWithoutProblemsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    sheetId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type DSASolutionUpsertWithWhereUniqueWithoutProblemInput = {
    where: DSASolutionWhereUniqueInput
    update: XOR<DSASolutionUpdateWithoutProblemInput, DSASolutionUncheckedUpdateWithoutProblemInput>
    create: XOR<DSASolutionCreateWithoutProblemInput, DSASolutionUncheckedCreateWithoutProblemInput>
  }

  export type DSASolutionUpdateWithWhereUniqueWithoutProblemInput = {
    where: DSASolutionWhereUniqueInput
    data: XOR<DSASolutionUpdateWithoutProblemInput, DSASolutionUncheckedUpdateWithoutProblemInput>
  }

  export type DSASolutionUpdateManyWithWhereWithoutProblemInput = {
    where: DSASolutionScalarWhereInput
    data: XOR<DSASolutionUpdateManyMutationInput, DSASolutionUncheckedUpdateManyWithoutProblemInput>
  }

  export type DSASolutionScalarWhereInput = {
    AND?: DSASolutionScalarWhereInput | DSASolutionScalarWhereInput[]
    OR?: DSASolutionScalarWhereInput[]
    NOT?: DSASolutionScalarWhereInput | DSASolutionScalarWhereInput[]
    id?: StringFilter<"DSASolution"> | string
    language?: StringFilter<"DSASolution"> | string
    code?: StringFilter<"DSASolution"> | string
    problemId?: StringFilter<"DSASolution"> | string
  }

  export type DSAProblemCreateWithoutSolutionsInput = {
    id?: string
    title: string
    description?: string | null
    difficulty: string
    order?: number
    topic: DSATopicCreateNestedOneWithoutProblemsInput
  }

  export type DSAProblemUncheckedCreateWithoutSolutionsInput = {
    id?: string
    title: string
    description?: string | null
    difficulty: string
    topicId: string
    order?: number
  }

  export type DSAProblemCreateOrConnectWithoutSolutionsInput = {
    where: DSAProblemWhereUniqueInput
    create: XOR<DSAProblemCreateWithoutSolutionsInput, DSAProblemUncheckedCreateWithoutSolutionsInput>
  }

  export type DSAProblemUpsertWithoutSolutionsInput = {
    update: XOR<DSAProblemUpdateWithoutSolutionsInput, DSAProblemUncheckedUpdateWithoutSolutionsInput>
    create: XOR<DSAProblemCreateWithoutSolutionsInput, DSAProblemUncheckedCreateWithoutSolutionsInput>
    where?: DSAProblemWhereInput
  }

  export type DSAProblemUpdateToOneWithWhereWithoutSolutionsInput = {
    where?: DSAProblemWhereInput
    data: XOR<DSAProblemUpdateWithoutSolutionsInput, DSAProblemUncheckedUpdateWithoutSolutionsInput>
  }

  export type DSAProblemUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    topic?: DSATopicUpdateOneRequiredWithoutProblemsNestedInput
  }

  export type DSAProblemUncheckedUpdateWithoutSolutionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    topicId?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type EventCreateWithoutCertificatesInput = {
    id?: string
    title: string
    slug: string
    description: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    hasChallenges?: boolean
    problemCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: EventCategoryCreateNestedOneWithoutEventsInput
    creator?: UserCreateNestedOneWithoutEventsCreatedInput
    roadmap?: RoadmapCreateNestedOneWithoutEventsInput
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
    teams?: TeamCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutCertificatesInput = {
    id?: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: string | null
    hasChallenges?: boolean
    problemCount?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutEventInput
    emailLogs?: EmailLogUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutCertificatesInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutCertificatesInput, EventUncheckedCreateWithoutCertificatesInput>
  }

  export type UserCreateWithoutCertificatesInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    emailsSent?: EmailLogCreateNestedManyWithoutSenderInput
  }

  export type UserUncheckedCreateWithoutCertificatesInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    emailsSent?: EmailLogUncheckedCreateNestedManyWithoutSenderInput
  }

  export type UserCreateOrConnectWithoutCertificatesInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
  }

  export type TeamCreateWithoutCertificatesInput = {
    id?: string
    teamName: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    event: EventCreateNestedOneWithoutTeamsInput
    leader: UserCreateNestedOneWithoutTeamsLeadingInput
    members?: TeamMemberCreateNestedManyWithoutTeamInput
    joinRequests?: TeamJoinRequestCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionCreateNestedManyWithoutTeamInput
  }

  export type TeamUncheckedCreateWithoutCertificatesInput = {
    id?: string
    eventId: string
    teamName: string
    teamLeaderId: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    members?: TeamMemberUncheckedCreateNestedManyWithoutTeamInput
    joinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutTeamInput
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutTeamInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutTeamInput
  }

  export type TeamCreateOrConnectWithoutCertificatesInput = {
    where: TeamWhereUniqueInput
    create: XOR<TeamCreateWithoutCertificatesInput, TeamUncheckedCreateWithoutCertificatesInput>
  }

  export type EventUpsertWithoutCertificatesInput = {
    update: XOR<EventUpdateWithoutCertificatesInput, EventUncheckedUpdateWithoutCertificatesInput>
    create: XOR<EventCreateWithoutCertificatesInput, EventUncheckedCreateWithoutCertificatesInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutCertificatesInput, EventUncheckedUpdateWithoutCertificatesInput>
  }

  export type EventUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EventCategoryUpdateOneRequiredWithoutEventsNestedInput
    creator?: UserUpdateOneWithoutEventsCreatedNestedInput
    roadmap?: RoadmapUpdateOneWithoutEventsNestedInput
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
    teams?: TeamUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UserUpsertWithoutCertificatesInput = {
    update: XOR<UserUpdateWithoutCertificatesInput, UserUncheckedUpdateWithoutCertificatesInput>
    create: XOR<UserCreateWithoutCertificatesInput, UserUncheckedCreateWithoutCertificatesInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutCertificatesInput, UserUncheckedUpdateWithoutCertificatesInput>
  }

  export type UserUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    emailsSent?: EmailLogUpdateManyWithoutSenderNestedInput
  }

  export type UserUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    emailsSent?: EmailLogUncheckedUpdateManyWithoutSenderNestedInput
  }

  export type TeamUpsertWithoutCertificatesInput = {
    update: XOR<TeamUpdateWithoutCertificatesInput, TeamUncheckedUpdateWithoutCertificatesInput>
    create: XOR<TeamCreateWithoutCertificatesInput, TeamUncheckedCreateWithoutCertificatesInput>
    where?: TeamWhereInput
  }

  export type TeamUpdateToOneWithWhereWithoutCertificatesInput = {
    where?: TeamWhereInput
    data: XOR<TeamUpdateWithoutCertificatesInput, TeamUncheckedUpdateWithoutCertificatesInput>
  }

  export type TeamUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput
    leader?: UserUpdateOneRequiredWithoutTeamsLeadingNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutCertificatesInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamLeaderId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUncheckedUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type EventCreateWithoutEmailLogsInput = {
    id?: string
    title: string
    slug: string
    description: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    hasChallenges?: boolean
    problemCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    category: EventCategoryCreateNestedOneWithoutEventsInput
    creator?: UserCreateNestedOneWithoutEventsCreatedInput
    roadmap?: RoadmapCreateNestedOneWithoutEventsInput
    registrations?: EventRegistrationCreateNestedManyWithoutEventInput
    teams?: TeamCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeCreateNestedManyWithoutEventInput
    certificates?: CertificateCreateNestedManyWithoutEventInput
  }

  export type EventUncheckedCreateWithoutEmailLogsInput = {
    id?: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: string | null
    hasChallenges?: boolean
    problemCount?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    registrations?: EventRegistrationUncheckedCreateNestedManyWithoutEventInput
    teams?: TeamUncheckedCreateNestedManyWithoutEventInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutEventInput
    eventChallenges?: EventChallengeUncheckedCreateNestedManyWithoutEventInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutEventInput
  }

  export type EventCreateOrConnectWithoutEmailLogsInput = {
    where: EventWhereUniqueInput
    create: XOR<EventCreateWithoutEmailLogsInput, EventUncheckedCreateWithoutEmailLogsInput>
  }

  export type UserCreateWithoutEmailsSentInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationCreateNestedManyWithoutUserInput
    teamsLeading?: TeamCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionCreateNestedManyWithoutUserInput
    badges?: UserBadgeCreateNestedManyWithoutUserInput
    achievements?: UserAchievementCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardCreateNestedManyWithoutUserInput
    eventsCreated?: EventCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeCreateNestedManyWithoutCreatorInput
    certificates?: CertificateCreateNestedManyWithoutUserInput
  }

  export type UserUncheckedCreateWithoutEmailsSentInput = {
    id?: string
    email: string
    fullName: string
    whatsapp?: string | null
    gender?: string | null
    graduation?: string | null
    specialization?: string | null
    year?: string | null
    regNumber?: string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: string | null
    githubUrl?: string | null
    codingUrl?: string | null
    profilePicture?: string | null
    totalPoints?: number
    currentStreak?: number
    longestStreak?: number
    level?: number
    createdAt?: Date | string
    updatedAt?: Date | string
    lastActive?: Date | string | null
    eventRegistrations?: EventRegistrationUncheckedCreateNestedManyWithoutUserInput
    teamsLeading?: TeamUncheckedCreateNestedManyWithoutLeaderInput
    teamMemberships?: TeamMemberUncheckedCreateNestedManyWithoutUserInput
    teamJoinRequests?: TeamJoinRequestUncheckedCreateNestedManyWithoutUserInput
    submissions?: EventSubmissionUncheckedCreateNestedManyWithoutUserInput
    challengeProgress?: UserChallengeProgressUncheckedCreateNestedManyWithoutUserInput
    taskCompletions?: UserTaskCompletionUncheckedCreateNestedManyWithoutUserInput
    badges?: UserBadgeUncheckedCreateNestedManyWithoutUserInput
    achievements?: UserAchievementUncheckedCreateNestedManyWithoutUserInput
    leaderboardEntries?: LeaderboardUncheckedCreateNestedManyWithoutUserInput
    eventsCreated?: EventUncheckedCreateNestedManyWithoutCreatorInput
    challengesCreated?: ChallengeUncheckedCreateNestedManyWithoutCreatorInput
    certificates?: CertificateUncheckedCreateNestedManyWithoutUserInput
  }

  export type UserCreateOrConnectWithoutEmailsSentInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmailsSentInput, UserUncheckedCreateWithoutEmailsSentInput>
  }

  export type EventUpsertWithoutEmailLogsInput = {
    update: XOR<EventUpdateWithoutEmailLogsInput, EventUncheckedUpdateWithoutEmailLogsInput>
    create: XOR<EventCreateWithoutEmailLogsInput, EventUncheckedCreateWithoutEmailLogsInput>
    where?: EventWhereInput
  }

  export type EventUpdateToOneWithWhereWithoutEmailLogsInput = {
    where?: EventWhereInput
    data: XOR<EventUpdateWithoutEmailLogsInput, EventUncheckedUpdateWithoutEmailLogsInput>
  }

  export type EventUpdateWithoutEmailLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EventCategoryUpdateOneRequiredWithoutEventsNestedInput
    creator?: UserUpdateOneWithoutEventsCreatedNestedInput
    roadmap?: RoadmapUpdateOneWithoutEventsNestedInput
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
    teams?: TeamUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutEventNestedInput
    certificates?: CertificateUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutEmailLogsInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutEventNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutEventNestedInput
  }

  export type UserUpsertWithoutEmailsSentInput = {
    update: XOR<UserUpdateWithoutEmailsSentInput, UserUncheckedUpdateWithoutEmailsSentInput>
    create: XOR<UserCreateWithoutEmailsSentInput, UserUncheckedCreateWithoutEmailsSentInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmailsSentInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmailsSentInput, UserUncheckedUpdateWithoutEmailsSentInput>
  }

  export type UserUpdateWithoutEmailsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUpdateManyWithoutUserNestedInput
  }

  export type UserUncheckedUpdateWithoutEmailsSentInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    fullName?: StringFieldUpdateOperationsInput | string
    whatsapp?: NullableStringFieldUpdateOperationsInput | string | null
    gender?: NullableStringFieldUpdateOperationsInput | string | null
    graduation?: NullableStringFieldUpdateOperationsInput | string | null
    specialization?: NullableStringFieldUpdateOperationsInput | string | null
    year?: NullableStringFieldUpdateOperationsInput | string | null
    regNumber?: NullableStringFieldUpdateOperationsInput | string | null
    skills?: NullableJsonNullValueInput | InputJsonValue
    domain?: NullableStringFieldUpdateOperationsInput | string | null
    githubUrl?: NullableStringFieldUpdateOperationsInput | string | null
    codingUrl?: NullableStringFieldUpdateOperationsInput | string | null
    profilePicture?: NullableStringFieldUpdateOperationsInput | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    level?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActive?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    eventRegistrations?: EventRegistrationUncheckedUpdateManyWithoutUserNestedInput
    teamsLeading?: TeamUncheckedUpdateManyWithoutLeaderNestedInput
    teamMemberships?: TeamMemberUncheckedUpdateManyWithoutUserNestedInput
    teamJoinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutUserNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutUserNestedInput
    challengeProgress?: UserChallengeProgressUncheckedUpdateManyWithoutUserNestedInput
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutUserNestedInput
    badges?: UserBadgeUncheckedUpdateManyWithoutUserNestedInput
    achievements?: UserAchievementUncheckedUpdateManyWithoutUserNestedInput
    leaderboardEntries?: LeaderboardUncheckedUpdateManyWithoutUserNestedInput
    eventsCreated?: EventUncheckedUpdateManyWithoutCreatorNestedInput
    challengesCreated?: ChallengeUncheckedUpdateManyWithoutCreatorNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutUserNestedInput
  }

  export type EventRegistrationCreateManyUserInput = {
    id?: string
    eventId: string
    teamId?: string | null
    participationType?: string
    paymentStatus?: string
    paymentId?: string | null
    amountPaid?: Decimal | DecimalJsLike | number | string | null
    paidAt?: Date | string | null
    status?: string
    registeredAt?: Date | string
    cancelledAt?: Date | string | null
  }

  export type TeamCreateManyLeaderInput = {
    id?: string
    eventId: string
    teamName: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type TeamMemberCreateManyUserInput = {
    id?: string
    teamId: string
    isLeader?: boolean
    status?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TeamJoinRequestCreateManyUserInput = {
    id?: string
    teamId: string
    requestType: string
    status?: string
    message?: string | null
    responseMessage?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type EventSubmissionCreateManyUserInput = {
    id?: string
    eventId: string
    teamId?: string | null
    projectDeckUrl?: string | null
    presentationPdfUrl?: string | null
    mvpLink?: string | null
    demoVideoUrl?: string | null
    githubRepoUrl?: string | null
    technologiesUsed?: string | null
    aiToolsIntegrated?: string | null
    solutionDescription?: string | null
    score?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    feedback?: string | null
    status?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    evaluatedAt?: Date | string | null
  }

  export type UserChallengeProgressCreateManyUserInput = {
    id?: string
    challengeId: string
    status?: string
    completedDays?: number
    totalDays: number
    completionPercentage?: Decimal | DecimalJsLike | number | string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    totalPoints?: number
    bonusPoints?: number
    currentRank?: number | null
    startedAt?: Date | string
    lastActivity?: Date | string
    completedAt?: Date | string | null
    certificateIssued?: boolean
    certificateUrl?: string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserTaskCompletionCreateManyUserInput = {
    id?: string
    challengeId: string
    taskId: string
    progressId: string
    completedAt?: Date | string
    timeTaken?: number | null
    submissionUrl?: string | null
    submissionText?: string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    score?: Decimal | DecimalJsLike | number | string | null
    pointsEarned?: number | null
    userNotes?: string | null
    feedback?: string | null
  }

  export type UserBadgeCreateManyUserInput = {
    id?: string
    badgeType: string
    badgeName: string
    badgeDescription?: string | null
    badgeIcon?: string | null
    badgeColor?: string | null
    relatedChallengeId?: string | null
    relatedEventId?: string | null
    pointsAwarded?: number
    earnedAt?: Date | string
  }

  export type UserAchievementCreateManyUserInput = {
    id?: string
    achievementType: string
    achievementName: string
    description?: string | null
    value?: number | null
    target?: number | null
    rarity?: string | null
    earnedAt?: Date | string
  }

  export type LeaderboardCreateManyUserInput = {
    id?: string
    leaderboardType: string
    relatedId?: string | null
    timePeriod?: string | null
    score?: number
    rank?: number | null
    previousRank?: number | null
    totalCompletions?: number
    currentStreak?: number
    updatedAt?: Date | string
  }

  export type EventCreateManyCreatorInput = {
    id?: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: string | null
    hasChallenges?: boolean
    problemCount?: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ChallengeCreateManyCreatorInput = {
    id?: string
    title: string
    slug: string
    description: string
    challengeType: string
    difficulty: string
    durationDays: number
    startDate: Date | string
    endDate: Date | string
    category?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: boolean
    isPublic?: boolean
    maxParticipants?: number | null
    bannerImage?: string | null
    icon?: string | null
    status?: string
    totalParticipants?: number
    activeParticipants?: number
    completionRate?: Decimal | DecimalJsLike | number | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type CertificateCreateManyUserInput = {
    id?: string
    certificateId: string
    eventId: string
    teamId?: string | null
    participantName: string
    position?: string | null
    issuedAt?: Date | string
  }

  export type EmailLogCreateManySenderInput = {
    id?: string
    eventId: string
    subject: string
    message: string
    recipientCount: number
    sentAt?: Date | string
  }

  export type EventRegistrationUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: EventUpdateOneRequiredWithoutRegistrationsNestedInput
    team?: TeamUpdateOneWithoutRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventRegistrationUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamUpdateWithoutLeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutTeamsNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutLeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUncheckedUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutLeaderInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLeader?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    team?: TeamUpdateOneRequiredWithoutMembersNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    isLeader?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    isLeader?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamJoinRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    team?: TeamUpdateOneRequiredWithoutJoinRequestsNestedInput
  }

  export type TeamJoinRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamJoinRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamId?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventSubmissionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: EventUpdateOneRequiredWithoutSubmissionsNestedInput
    team?: TeamUpdateOneWithoutSubmissionsNestedInput
  }

  export type EventSubmissionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventSubmissionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type UserChallengeProgressUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedDays?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    completionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    bonusPoints?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateIssued?: BoolFieldUpdateOperationsInput | boolean
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    challenge?: ChallengeUpdateOneRequiredWithoutUserProgressNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutProgressNestedInput
  }

  export type UserChallengeProgressUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedDays?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    completionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    bonusPoints?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateIssued?: BoolFieldUpdateOperationsInput | boolean
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutProgressNestedInput
  }

  export type UserChallengeProgressUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedDays?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    completionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    bonusPoints?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateIssued?: BoolFieldUpdateOperationsInput | boolean
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
  }

  export type UserTaskCompletionUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    task?: ChallengeTaskUpdateOneRequiredWithoutCompletionsNestedInput
    progress?: UserChallengeProgressUpdateOneRequiredWithoutTaskCompletionsNestedInput
  }

  export type UserTaskCompletionUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    progressId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserTaskCompletionUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    progressId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserBadgeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeType?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    badgeIcon?: NullableStringFieldUpdateOperationsInput | string | null
    badgeColor?: NullableStringFieldUpdateOperationsInput | string | null
    relatedChallengeId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeType?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    badgeIcon?: NullableStringFieldUpdateOperationsInput | string | null
    badgeColor?: NullableStringFieldUpdateOperationsInput | string | null
    relatedChallengeId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserBadgeUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    badgeType?: StringFieldUpdateOperationsInput | string
    badgeName?: StringFieldUpdateOperationsInput | string
    badgeDescription?: NullableStringFieldUpdateOperationsInput | string | null
    badgeIcon?: NullableStringFieldUpdateOperationsInput | string | null
    badgeColor?: NullableStringFieldUpdateOperationsInput | string | null
    relatedChallengeId?: NullableStringFieldUpdateOperationsInput | string | null
    relatedEventId?: NullableStringFieldUpdateOperationsInput | string | null
    pointsAwarded?: IntFieldUpdateOperationsInput | number
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserAchievementUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    achievementType?: StringFieldUpdateOperationsInput | string
    achievementName?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    value?: NullableIntFieldUpdateOperationsInput | number | null
    target?: NullableIntFieldUpdateOperationsInput | number | null
    rarity?: NullableStringFieldUpdateOperationsInput | string | null
    earnedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaderboardType?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    timePeriod?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    totalCompletions?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaderboardType?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    timePeriod?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    totalCompletions?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaderboardUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaderboardType?: StringFieldUpdateOperationsInput | string
    relatedId?: NullableStringFieldUpdateOperationsInput | string | null
    timePeriod?: NullableStringFieldUpdateOperationsInput | string | null
    score?: IntFieldUpdateOperationsInput | number
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    previousRank?: NullableIntFieldUpdateOperationsInput | number | null
    totalCompletions?: IntFieldUpdateOperationsInput | number
    currentStreak?: IntFieldUpdateOperationsInput | number
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EventCategoryUpdateOneRequiredWithoutEventsNestedInput
    roadmap?: RoadmapUpdateOneWithoutEventsNestedInput
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
    teams?: TeamUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUpdateManyWithoutEventNestedInput
    certificates?: CertificateUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutEventNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ChallengeTaskUpdateManyWithoutChallengeNestedInput
    userProgress?: UserChallengeProgressUpdateManyWithoutChallengeNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    tasks?: ChallengeTaskUncheckedUpdateManyWithoutChallengeNestedInput
    userProgress?: UserChallengeProgressUncheckedUpdateManyWithoutChallengeNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutChallengeNestedInput
  }

  export type ChallengeUncheckedUpdateManyWithoutCreatorInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    challengeType?: StringFieldUpdateOperationsInput | string
    difficulty?: StringFieldUpdateOperationsInput | string
    durationDays?: IntFieldUpdateOperationsInput | number
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
    pointsPerDay?: IntFieldUpdateOperationsInput | number
    bonusPoints?: NullableJsonNullValueInput | InputJsonValue
    badges?: NullableJsonNullValueInput | InputJsonValue
    hasLeaderboard?: BoolFieldUpdateOperationsInput | boolean
    isPublic?: BoolFieldUpdateOperationsInput | boolean
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    totalParticipants?: IntFieldUpdateOperationsInput | number
    activeParticipants?: IntFieldUpdateOperationsInput | number
    completionRate?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutCertificatesNestedInput
    team?: TeamUpdateOneWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutEmailLogsNestedInput
  }

  export type EmailLogUncheckedUpdateWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateManyWithoutSenderInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventCategoryCreateManyParentInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    icon?: string | null
    color?: string | null
    createdAt?: Date | string
  }

  export type EventCreateManyCategoryInput = {
    id?: string
    title: string
    slug: string
    description: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    roadmapId?: string | null
    hasChallenges?: boolean
    problemCount?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventTypeCreateManyCategoryInput = {
    id?: string
    name: string
    slug: string
    description?: string | null
    defaultDurationHours?: number | null
    createdAt?: Date | string
  }

  export type EventCategoryUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: EventCategoryUpdateManyWithoutParentNestedInput
    events?: EventUpdateManyWithoutCategoryNestedInput
    eventTypes?: EventTypeUpdateManyWithoutCategoryNestedInput
  }

  export type EventCategoryUncheckedUpdateWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    children?: EventCategoryUncheckedUpdateManyWithoutParentNestedInput
    events?: EventUncheckedUpdateManyWithoutCategoryNestedInput
    eventTypes?: EventTypeUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type EventCategoryUncheckedUpdateManyWithoutParentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    icon?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    creator?: UserUpdateOneWithoutEventsCreatedNestedInput
    roadmap?: RoadmapUpdateOneWithoutEventsNestedInput
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
    teams?: TeamUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUpdateManyWithoutEventNestedInput
    certificates?: CertificateUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutEventNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    roadmapId?: NullableStringFieldUpdateOperationsInput | string | null
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTypeUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTypeUncheckedUpdateWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventTypeUncheckedUpdateManyWithoutCategoryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    defaultDurationHours?: NullableIntFieldUpdateOperationsInput | number | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventRegistrationCreateManyEventInput = {
    id?: string
    userId: string
    teamId?: string | null
    participationType?: string
    paymentStatus?: string
    paymentId?: string | null
    amountPaid?: Decimal | DecimalJsLike | number | string | null
    paidAt?: Date | string | null
    status?: string
    registeredAt?: Date | string
    cancelledAt?: Date | string | null
  }

  export type TeamCreateManyEventInput = {
    id?: string
    teamName: string
    teamLeaderId: string
    isComplete?: boolean
    isLocked?: boolean
    collegeName?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EventSubmissionCreateManyEventInput = {
    id?: string
    userId: string
    teamId?: string | null
    projectDeckUrl?: string | null
    presentationPdfUrl?: string | null
    mvpLink?: string | null
    demoVideoUrl?: string | null
    githubRepoUrl?: string | null
    technologiesUsed?: string | null
    aiToolsIntegrated?: string | null
    solutionDescription?: string | null
    score?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    feedback?: string | null
    status?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    evaluatedAt?: Date | string | null
  }

  export type EventChallengeCreateManyEventInput = {
    challengeId: string
  }

  export type EmailLogCreateManyEventInput = {
    id?: string
    subject: string
    message: string
    recipientCount: number
    sentBy: string
    sentAt?: Date | string
  }

  export type CertificateCreateManyEventInput = {
    id?: string
    certificateId: string
    userId: string
    teamId?: string | null
    participantName: string
    position?: string | null
    issuedAt?: Date | string
  }

  export type EventRegistrationUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutEventRegistrationsNestedInput
    team?: TeamUpdateOneWithoutRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventRegistrationUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leader?: UserUpdateOneRequiredWithoutTeamsLeadingNestedInput
    members?: TeamMemberUpdateManyWithoutTeamNestedInput
    joinRequests?: TeamJoinRequestUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamLeaderId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    members?: TeamMemberUncheckedUpdateManyWithoutTeamNestedInput
    joinRequests?: TeamJoinRequestUncheckedUpdateManyWithoutTeamNestedInput
    registrations?: EventRegistrationUncheckedUpdateManyWithoutTeamNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutTeamNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutTeamNestedInput
  }

  export type TeamUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    teamName?: StringFieldUpdateOperationsInput | string
    teamLeaderId?: StringFieldUpdateOperationsInput | string
    isComplete?: BoolFieldUpdateOperationsInput | boolean
    isLocked?: BoolFieldUpdateOperationsInput | boolean
    collegeName?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EventSubmissionUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutSubmissionsNestedInput
    team?: TeamUpdateOneWithoutSubmissionsNestedInput
  }

  export type EventSubmissionUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventSubmissionUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventChallengeUpdateWithoutEventInput = {
    challenge?: ChallengeUpdateOneRequiredWithoutEventChallengesNestedInput
  }

  export type EventChallengeUncheckedUpdateWithoutEventInput = {
    challengeId?: StringFieldUpdateOperationsInput | string
  }

  export type EventChallengeUncheckedUpdateManyWithoutEventInput = {
    challengeId?: StringFieldUpdateOperationsInput | string
  }

  export type EmailLogUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
    sender?: UserUpdateOneRequiredWithoutEmailsSentNestedInput
  }

  export type EmailLogUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentBy?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmailLogUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    subject?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    recipientCount?: IntFieldUpdateOperationsInput | number
    sentBy?: StringFieldUpdateOperationsInput | string
    sentAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
    team?: TeamUpdateOneWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutEventInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    teamId?: NullableStringFieldUpdateOperationsInput | string | null
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TeamMemberCreateManyTeamInput = {
    id?: string
    userId: string
    isLeader?: boolean
    status?: string
    joinedAt?: Date | string
    leftAt?: Date | string | null
  }

  export type TeamJoinRequestCreateManyTeamInput = {
    id?: string
    userId: string
    requestType: string
    status?: string
    message?: string | null
    responseMessage?: string | null
    createdAt?: Date | string
    respondedAt?: Date | string | null
  }

  export type EventRegistrationCreateManyTeamInput = {
    id?: string
    eventId: string
    userId: string
    participationType?: string
    paymentStatus?: string
    paymentId?: string | null
    amountPaid?: Decimal | DecimalJsLike | number | string | null
    paidAt?: Date | string | null
    status?: string
    registeredAt?: Date | string
    cancelledAt?: Date | string | null
  }

  export type EventSubmissionCreateManyTeamInput = {
    id?: string
    eventId: string
    userId: string
    projectDeckUrl?: string | null
    presentationPdfUrl?: string | null
    mvpLink?: string | null
    demoVideoUrl?: string | null
    githubRepoUrl?: string | null
    technologiesUsed?: string | null
    aiToolsIntegrated?: string | null
    solutionDescription?: string | null
    score?: Decimal | DecimalJsLike | number | string | null
    rank?: number | null
    feedback?: string | null
    status?: string
    submittedAt?: Date | string
    updatedAt?: Date | string
    evaluatedAt?: Date | string | null
  }

  export type CertificateCreateManyTeamInput = {
    id?: string
    certificateId: string
    eventId: string
    userId: string
    participantName: string
    position?: string | null
    issuedAt?: Date | string
  }

  export type TeamMemberUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    isLeader?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTeamMembershipsNestedInput
  }

  export type TeamMemberUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isLeader?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamMemberUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    isLeader?: BoolFieldUpdateOperationsInput | boolean
    status?: StringFieldUpdateOperationsInput | string
    joinedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    leftAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamJoinRequestUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    user?: UserUpdateOneRequiredWithoutTeamJoinRequestsNestedInput
  }

  export type TeamJoinRequestUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type TeamJoinRequestUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    requestType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    message?: NullableStringFieldUpdateOperationsInput | string | null
    responseMessage?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    respondedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventRegistrationUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: EventUpdateOneRequiredWithoutRegistrationsNestedInput
    user?: UserUpdateOneRequiredWithoutEventRegistrationsNestedInput
  }

  export type EventRegistrationUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventRegistrationUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participationType?: StringFieldUpdateOperationsInput | string
    paymentStatus?: StringFieldUpdateOperationsInput | string
    paymentId?: NullableStringFieldUpdateOperationsInput | string | null
    amountPaid?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    paidAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    status?: StringFieldUpdateOperationsInput | string
    registeredAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cancelledAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventSubmissionUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    event?: EventUpdateOneRequiredWithoutSubmissionsNestedInput
    user?: UserUpdateOneRequiredWithoutSubmissionsNestedInput
  }

  export type EventSubmissionUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type EventSubmissionUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    projectDeckUrl?: NullableStringFieldUpdateOperationsInput | string | null
    presentationPdfUrl?: NullableStringFieldUpdateOperationsInput | string | null
    mvpLink?: NullableStringFieldUpdateOperationsInput | string | null
    demoVideoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    githubRepoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    technologiesUsed?: NullableStringFieldUpdateOperationsInput | string | null
    aiToolsIntegrated?: NullableStringFieldUpdateOperationsInput | string | null
    solutionDescription?: NullableStringFieldUpdateOperationsInput | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    rank?: NullableIntFieldUpdateOperationsInput | number | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    submittedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    evaluatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
  }

  export type CertificateUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    event?: EventUpdateOneRequiredWithoutCertificatesNestedInput
    user?: UserUpdateOneRequiredWithoutCertificatesNestedInput
  }

  export type CertificateUncheckedUpdateWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type CertificateUncheckedUpdateManyWithoutTeamInput = {
    id?: StringFieldUpdateOperationsInput | string
    certificateId?: StringFieldUpdateOperationsInput | string
    eventId?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    participantName?: StringFieldUpdateOperationsInput | string
    position?: NullableStringFieldUpdateOperationsInput | string | null
    issuedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ChallengeTaskCreateManyChallengeInput = {
    id?: string
    dayNumber: number
    title: string
    description?: string | null
    taskType: string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: string | null
    points?: number
    autoValidate?: boolean
    validationUrl?: string | null
    createdAt?: Date | string
  }

  export type UserChallengeProgressCreateManyChallengeInput = {
    id?: string
    userId: string
    status?: string
    completedDays?: number
    totalDays: number
    completionPercentage?: Decimal | DecimalJsLike | number | string
    currentStreak?: number
    longestStreak?: number
    lastCompletedDate?: Date | string | null
    totalPoints?: number
    bonusPoints?: number
    currentRank?: number | null
    startedAt?: Date | string
    lastActivity?: Date | string
    completedAt?: Date | string | null
    certificateIssued?: boolean
    certificateUrl?: string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EventChallengeCreateManyChallengeInput = {
    eventId: string
  }

  export type ChallengeTaskUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    autoValidate?: BoolFieldUpdateOperationsInput | boolean
    validationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: UserTaskCompletionUpdateManyWithoutTaskNestedInput
  }

  export type ChallengeTaskUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    autoValidate?: BoolFieldUpdateOperationsInput | boolean
    validationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    completions?: UserTaskCompletionUncheckedUpdateManyWithoutTaskNestedInput
  }

  export type ChallengeTaskUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    dayNumber?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    taskType?: StringFieldUpdateOperationsInput | string
    content?: NullableJsonNullValueInput | InputJsonValue
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    hints?: NullableJsonNullValueInput | InputJsonValue
    difficulty?: NullableStringFieldUpdateOperationsInput | string | null
    points?: IntFieldUpdateOperationsInput | number
    autoValidate?: BoolFieldUpdateOperationsInput | boolean
    validationUrl?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserChallengeProgressUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedDays?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    completionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    bonusPoints?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateIssued?: BoolFieldUpdateOperationsInput | boolean
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    user?: UserUpdateOneRequiredWithoutChallengeProgressNestedInput
    taskCompletions?: UserTaskCompletionUpdateManyWithoutProgressNestedInput
  }

  export type UserChallengeProgressUncheckedUpdateWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedDays?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    completionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    bonusPoints?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateIssued?: BoolFieldUpdateOperationsInput | boolean
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    taskCompletions?: UserTaskCompletionUncheckedUpdateManyWithoutProgressNestedInput
  }

  export type UserChallengeProgressUncheckedUpdateManyWithoutChallengeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    completedDays?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    completionPercentage?: DecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string
    currentStreak?: IntFieldUpdateOperationsInput | number
    longestStreak?: IntFieldUpdateOperationsInput | number
    lastCompletedDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalPoints?: IntFieldUpdateOperationsInput | number
    bonusPoints?: IntFieldUpdateOperationsInput | number
    currentRank?: NullableIntFieldUpdateOperationsInput | number | null
    startedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    lastActivity?: DateTimeFieldUpdateOperationsInput | Date | string
    completedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    certificateIssued?: BoolFieldUpdateOperationsInput | boolean
    certificateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    completedTaskIds?: NullableJsonNullValueInput | InputJsonValue
    skippedTaskIds?: NullableJsonNullValueInput | InputJsonValue
  }

  export type EventChallengeUpdateWithoutChallengeInput = {
    event?: EventUpdateOneRequiredWithoutEventChallengesNestedInput
  }

  export type EventChallengeUncheckedUpdateWithoutChallengeInput = {
    eventId?: StringFieldUpdateOperationsInput | string
  }

  export type EventChallengeUncheckedUpdateManyWithoutChallengeInput = {
    eventId?: StringFieldUpdateOperationsInput | string
  }

  export type UserTaskCompletionCreateManyTaskInput = {
    id?: string
    userId: string
    challengeId: string
    progressId: string
    completedAt?: Date | string
    timeTaken?: number | null
    submissionUrl?: string | null
    submissionText?: string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    score?: Decimal | DecimalJsLike | number | string | null
    pointsEarned?: number | null
    userNotes?: string | null
    feedback?: string | null
  }

  export type UserTaskCompletionUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTaskCompletionsNestedInput
    progress?: UserChallengeProgressUpdateOneRequiredWithoutTaskCompletionsNestedInput
  }

  export type UserTaskCompletionUncheckedUpdateWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    progressId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserTaskCompletionUncheckedUpdateManyWithoutTaskInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    progressId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserTaskCompletionCreateManyProgressInput = {
    id?: string
    userId: string
    challengeId: string
    taskId: string
    completedAt?: Date | string
    timeTaken?: number | null
    submissionUrl?: string | null
    submissionText?: string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: boolean
    verifiedBy?: string | null
    verifiedAt?: Date | string | null
    score?: Decimal | DecimalJsLike | number | string | null
    pointsEarned?: number | null
    userNotes?: string | null
    feedback?: string | null
  }

  export type UserTaskCompletionUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
    user?: UserUpdateOneRequiredWithoutTaskCompletionsNestedInput
    task?: ChallengeTaskUpdateOneRequiredWithoutCompletionsNestedInput
  }

  export type UserTaskCompletionUncheckedUpdateWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type UserTaskCompletionUncheckedUpdateManyWithoutProgressInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: StringFieldUpdateOperationsInput | string
    challengeId?: StringFieldUpdateOperationsInput | string
    taskId?: StringFieldUpdateOperationsInput | string
    completedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    timeTaken?: NullableIntFieldUpdateOperationsInput | number | null
    submissionUrl?: NullableStringFieldUpdateOperationsInput | string | null
    submissionText?: NullableStringFieldUpdateOperationsInput | string | null
    submissionFiles?: NullableJsonNullValueInput | InputJsonValue
    isVerified?: BoolFieldUpdateOperationsInput | boolean
    verifiedBy?: NullableStringFieldUpdateOperationsInput | string | null
    verifiedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    score?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    pointsEarned?: NullableIntFieldUpdateOperationsInput | number | null
    userNotes?: NullableStringFieldUpdateOperationsInput | string | null
    feedback?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type RoadmapPhaseCreateManyRoadmapInput = {
    id?: string
    order: number
    title: string
    level?: string | null
    duration?: string | null
    description?: string | null
  }

  export type EventCreateManyRoadmapInput = {
    id?: string
    title: string
    slug: string
    description: string
    categoryId: string
    eventType: string
    mode: string
    registrationStart: Date | string
    registrationEnd: Date | string
    maxParticipants?: number | null
    isTeamEvent?: boolean
    allowIndividual?: boolean
    minTeamSize?: number
    maxTeamSize?: number
    teamFormationDeadline?: Date | string | null
    restrictSameCollege?: boolean
    eventStart: Date | string
    eventEnd: Date | string
    isPaid?: boolean
    registrationFee?: Decimal | DecimalJsLike | number | string | null
    currency?: string
    hasSubmission?: boolean
    submissionStart?: Date | string | null
    submissionDeadline?: Date | string | null
    submissionTemplateUrl?: string | null
    rules?: string | null
    eligibility?: string | null
    rewards?: string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: string | null
    meetingLink?: string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: string
    isFeatured?: boolean
    hasRoadmap?: boolean
    hasChallenges?: boolean
    problemCount?: number
    createdBy?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type RoadmapPhaseUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: PhaseSectionUpdateManyWithoutPhaseNestedInput
    playlists?: PhasePlaylistUpdateManyWithoutPhaseNestedInput
    projects?: PhaseProjectUpdateManyWithoutPhaseNestedInput
  }

  export type RoadmapPhaseUncheckedUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    sections?: PhaseSectionUncheckedUpdateManyWithoutPhaseNestedInput
    playlists?: PhasePlaylistUncheckedUpdateManyWithoutPhaseNestedInput
    projects?: PhaseProjectUncheckedUpdateManyWithoutPhaseNestedInput
  }

  export type RoadmapPhaseUncheckedUpdateManyWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    title?: StringFieldUpdateOperationsInput | string
    level?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type EventUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: EventCategoryUpdateOneRequiredWithoutEventsNestedInput
    creator?: UserUpdateOneWithoutEventsCreatedNestedInput
    registrations?: EventRegistrationUpdateManyWithoutEventNestedInput
    teams?: TeamUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUpdateManyWithoutEventNestedInput
    certificates?: CertificateUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    registrations?: EventRegistrationUncheckedUpdateManyWithoutEventNestedInput
    teams?: TeamUncheckedUpdateManyWithoutEventNestedInput
    submissions?: EventSubmissionUncheckedUpdateManyWithoutEventNestedInput
    eventChallenges?: EventChallengeUncheckedUpdateManyWithoutEventNestedInput
    emailLogs?: EmailLogUncheckedUpdateManyWithoutEventNestedInput
    certificates?: CertificateUncheckedUpdateManyWithoutEventNestedInput
  }

  export type EventUncheckedUpdateManyWithoutRoadmapInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    slug?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    categoryId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    mode?: StringFieldUpdateOperationsInput | string
    registrationStart?: DateTimeFieldUpdateOperationsInput | Date | string
    registrationEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    maxParticipants?: NullableIntFieldUpdateOperationsInput | number | null
    isTeamEvent?: BoolFieldUpdateOperationsInput | boolean
    allowIndividual?: BoolFieldUpdateOperationsInput | boolean
    minTeamSize?: IntFieldUpdateOperationsInput | number
    maxTeamSize?: IntFieldUpdateOperationsInput | number
    teamFormationDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    restrictSameCollege?: BoolFieldUpdateOperationsInput | boolean
    eventStart?: DateTimeFieldUpdateOperationsInput | Date | string
    eventEnd?: DateTimeFieldUpdateOperationsInput | Date | string
    isPaid?: BoolFieldUpdateOperationsInput | boolean
    registrationFee?: NullableDecimalFieldUpdateOperationsInput | Decimal | DecimalJsLike | number | string | null
    currency?: StringFieldUpdateOperationsInput | string
    hasSubmission?: BoolFieldUpdateOperationsInput | boolean
    submissionStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionDeadline?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    submissionTemplateUrl?: NullableStringFieldUpdateOperationsInput | string | null
    rules?: NullableStringFieldUpdateOperationsInput | string | null
    eligibility?: NullableStringFieldUpdateOperationsInput | string | null
    rewards?: NullableStringFieldUpdateOperationsInput | string | null
    prizes?: NullableJsonNullValueInput | InputJsonValue
    venue?: NullableStringFieldUpdateOperationsInput | string | null
    meetingLink?: NullableStringFieldUpdateOperationsInput | string | null
    resourceLinks?: NullableJsonNullValueInput | InputJsonValue
    bannerImage?: NullableStringFieldUpdateOperationsInput | string | null
    images?: NullableJsonNullValueInput | InputJsonValue
    status?: StringFieldUpdateOperationsInput | string
    isFeatured?: BoolFieldUpdateOperationsInput | boolean
    hasRoadmap?: BoolFieldUpdateOperationsInput | boolean
    hasChallenges?: BoolFieldUpdateOperationsInput | boolean
    problemCount?: IntFieldUpdateOperationsInput | number
    createdBy?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PhaseSectionCreateManyPhaseInput = {
    id?: string
    title: string
    description?: string | null
    order?: number
  }

  export type PhasePlaylistCreateManyPhaseInput = {
    id?: string
    title: string
    author?: string | null
    videoCount?: number
    url: string
    thumbnail?: string | null
  }

  export type PhaseProjectCreateManyPhaseInput = {
    id?: string
    title: string
    description?: string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PhaseSectionUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    items?: SectionItemUpdateManyWithoutSectionNestedInput
  }

  export type PhaseSectionUncheckedUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
    items?: SectionItemUncheckedUpdateManyWithoutSectionNestedInput
  }

  export type PhaseSectionUncheckedUpdateManyWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type PhasePlaylistUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    videoCount?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhasePlaylistUncheckedUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    videoCount?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhasePlaylistUncheckedUpdateManyWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    author?: NullableStringFieldUpdateOperationsInput | string | null
    videoCount?: IntFieldUpdateOperationsInput | number
    url?: StringFieldUpdateOperationsInput | string
    thumbnail?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type PhaseProjectUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PhaseProjectUncheckedUpdateWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type PhaseProjectUncheckedUpdateManyWithoutPhaseInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    tags?: NullableJsonNullValueInput | InputJsonValue
  }

  export type SectionItemCreateManySectionInput = {
    id?: string
    title: string
    order?: number
  }

  export type SectionItemUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    subItems?: SubItemUpdateManyWithoutItemNestedInput
  }

  export type SectionItemUncheckedUpdateWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    subItems?: SubItemUncheckedUpdateManyWithoutItemNestedInput
  }

  export type SectionItemUncheckedUpdateManyWithoutSectionInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SubItemCreateManyItemInput = {
    id?: string
    title: string
    videoUrl?: string | null
    duration?: string | null
    order?: number
  }

  export type SubItemUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SubItemUncheckedUpdateWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type SubItemUncheckedUpdateManyWithoutItemInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    videoUrl?: NullableStringFieldUpdateOperationsInput | string | null
    duration?: NullableStringFieldUpdateOperationsInput | string | null
    order?: IntFieldUpdateOperationsInput | number
  }

  export type DSATopicCreateManySheetInput = {
    id?: string
    title: string
    order?: number
  }

  export type DSATopicUpdateWithoutSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    problems?: DSAProblemUpdateManyWithoutTopicNestedInput
  }

  export type DSATopicUncheckedUpdateWithoutSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    problems?: DSAProblemUncheckedUpdateManyWithoutTopicNestedInput
  }

  export type DSATopicUncheckedUpdateManyWithoutSheetInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type DSAProblemCreateManyTopicInput = {
    id?: string
    title: string
    description?: string | null
    difficulty: string
    order?: number
  }

  export type DSAProblemUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    solutions?: DSASolutionUpdateManyWithoutProblemNestedInput
  }

  export type DSAProblemUncheckedUpdateWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
    solutions?: DSASolutionUncheckedUpdateManyWithoutProblemNestedInput
  }

  export type DSAProblemUncheckedUpdateManyWithoutTopicInput = {
    id?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    difficulty?: StringFieldUpdateOperationsInput | string
    order?: IntFieldUpdateOperationsInput | number
  }

  export type DSASolutionCreateManyProblemInput = {
    id?: string
    language: string
    code: string
  }

  export type DSASolutionUpdateWithoutProblemInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type DSASolutionUncheckedUpdateWithoutProblemInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }

  export type DSASolutionUncheckedUpdateManyWithoutProblemInput = {
    id?: StringFieldUpdateOperationsInput | string
    language?: StringFieldUpdateOperationsInput | string
    code?: StringFieldUpdateOperationsInput | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCategoryCountOutputTypeDefaultArgs instead
     */
    export type EventCategoryCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCategoryCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCountOutputTypeDefaultArgs instead
     */
    export type EventCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamCountOutputTypeDefaultArgs instead
     */
    export type TeamCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeCountOutputTypeDefaultArgs instead
     */
    export type ChallengeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeTaskCountOutputTypeDefaultArgs instead
     */
    export type ChallengeTaskCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeTaskCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserChallengeProgressCountOutputTypeDefaultArgs instead
     */
    export type UserChallengeProgressCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserChallengeProgressCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapCountOutputTypeDefaultArgs instead
     */
    export type RoadmapCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapPhaseCountOutputTypeDefaultArgs instead
     */
    export type RoadmapPhaseCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapPhaseCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhaseSectionCountOutputTypeDefaultArgs instead
     */
    export type PhaseSectionCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhaseSectionCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SectionItemCountOutputTypeDefaultArgs instead
     */
    export type SectionItemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SectionItemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DSASheetCountOutputTypeDefaultArgs instead
     */
    export type DSASheetCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DSASheetCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DSATopicCountOutputTypeDefaultArgs instead
     */
    export type DSATopicCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DSATopicCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DSAProblemCountOutputTypeDefaultArgs instead
     */
    export type DSAProblemCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DSAProblemCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventCategoryDefaultArgs instead
     */
    export type EventCategoryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventCategoryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventTypeDefaultArgs instead
     */
    export type EventTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventDefaultArgs instead
     */
    export type EventArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamDefaultArgs instead
     */
    export type TeamArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamMemberDefaultArgs instead
     */
    export type TeamMemberArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamMemberDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TeamJoinRequestDefaultArgs instead
     */
    export type TeamJoinRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TeamJoinRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventRegistrationDefaultArgs instead
     */
    export type EventRegistrationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventRegistrationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventSubmissionDefaultArgs instead
     */
    export type EventSubmissionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventSubmissionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeDefaultArgs instead
     */
    export type ChallengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ChallengeTaskDefaultArgs instead
     */
    export type ChallengeTaskArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ChallengeTaskDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserChallengeProgressDefaultArgs instead
     */
    export type UserChallengeProgressArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserChallengeProgressDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserTaskCompletionDefaultArgs instead
     */
    export type UserTaskCompletionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserTaskCompletionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserBadgeDefaultArgs instead
     */
    export type UserBadgeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserBadgeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserAchievementDefaultArgs instead
     */
    export type UserAchievementArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserAchievementDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaderboardDefaultArgs instead
     */
    export type LeaderboardArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaderboardDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EventChallengeDefaultArgs instead
     */
    export type EventChallengeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EventChallengeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapDefaultArgs instead
     */
    export type RoadmapArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapDefaultArgs<ExtArgs>
    /**
     * @deprecated Use RoadmapPhaseDefaultArgs instead
     */
    export type RoadmapPhaseArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = RoadmapPhaseDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhaseSectionDefaultArgs instead
     */
    export type PhaseSectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhaseSectionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SectionItemDefaultArgs instead
     */
    export type SectionItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SectionItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SubItemDefaultArgs instead
     */
    export type SubItemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SubItemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhasePlaylistDefaultArgs instead
     */
    export type PhasePlaylistArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhasePlaylistDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PhaseProjectDefaultArgs instead
     */
    export type PhaseProjectArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PhaseProjectDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DSASheetDefaultArgs instead
     */
    export type DSASheetArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DSASheetDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DSATopicDefaultArgs instead
     */
    export type DSATopicArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DSATopicDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DSAProblemDefaultArgs instead
     */
    export type DSAProblemArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DSAProblemDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DSASolutionDefaultArgs instead
     */
    export type DSASolutionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DSASolutionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use CertificateDefaultArgs instead
     */
    export type CertificateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = CertificateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmailLogDefaultArgs instead
     */
    export type EmailLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmailLogDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}